<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API reference · Merzbild</title><meta name="title" content="Public API reference · Merzbild"/><meta property="og:title" content="Public API reference · Merzbild"/><meta property="twitter:title" content="Public API reference · Merzbild"/><meta name="description" content="Documentation for Merzbild."/><meta property="og:description" content="Documentation for Merzbild."/><meta property="twitter:description" content="Documentation for Merzbild."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Merzbild</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview_capabilities/">Overview of capabilities</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview_blocks/">Overview of basic building blocks</a></li><li><a class="tocitem" href="../overview_fixedweight/">Fixed-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_varweight/">Variable-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_1d/">1D DSMC simulations</a></li><li><a class="tocitem" href="../overview_fp/">Fokker-Planck simulations</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../contiguous_indexing/">Contiguous indexing</a></li><li><a class="tocitem" href="../modelling_ionization/">Modelling ionization reactions</a></li><li><a class="tocitem" href="../multithreaded/">Multithreaded simulations</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li class="is-active"><a class="tocitem" href>Public API reference</a><ul class="internal"><li><a class="tocitem" href="#Particles"><span>Particles</span></a></li><li><a class="tocitem" href="#Particle-indexing"><span>Particle indexing</span></a></li><li><a class="tocitem" href="#Loading-species-and-interaction-data"><span>Loading species and interaction data</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Computing-grid-and-surface-macroscopic-properties"><span>Computing grid and surface macroscopic properties</span></a></li><li><a class="tocitem" href="#Collision-computations"><span>Collision computations</span></a></li><li><a class="tocitem" href="#Fokker-Planck-computations"><span>Fokker-Planck computations</span></a></li><li><a class="tocitem" href="#Electron-neutral-interactions"><span>Electron-neutral interactions</span></a></li><li><a class="tocitem" href="#Merging"><span>Merging</span></a></li><li><a class="tocitem" href="#Grids-and-particle-sorting"><span>Grids and particle sorting</span></a></li><li><a class="tocitem" href="#Particle-movement"><span>Particle movement</span></a></li><li><a class="tocitem" href="#Particle-surface-interactions"><span>Particle-surface interactions</span></a></li><li><a class="tocitem" href="#I/O"><span>I/O</span></a></li><li><a class="tocitem" href="#Parallel-computations"><span>Parallel computations</span></a></li><li><a class="tocitem" href="#Particle-in-Cell"><span>Particle-in-Cell</span></a></li><li><a class="tocitem" href="#Constants"><span>Constants</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li><li><a class="tocitem" href="../reference_internal/">Internal API reference</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API reference</a></li><li class="is-active"><a href>Public API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API reference</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Merzbild.jl-public-API-reference"><a class="docs-heading-anchor" href="#Merzbild.jl-public-API-reference">Merzbild.jl public API reference</a><a id="Merzbild.jl-public-API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Merzbild.jl-public-API-reference" title="Permalink"></a></h1><h2 id="Particles"><a class="docs-heading-anchor" href="#Particles">Particles</a><a id="Particles-1"></a><a class="docs-heading-anchor-permalink" href="#Particles" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.Particle" href="#Merzbild.Particle"><code>Merzbild.Particle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Particle</code></pre><p>A structure to store information about a single particle.</p><p><strong>Fields</strong></p><ul><li><code>w</code>: the computational weight of the particle</li><li><code>v</code>: the 3-dimensional velocity vector of the particle</li><li><code>x</code>: the 3-dimensional position of the particle</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleVector" href="#Merzbild.ParticleVector"><code>Merzbild.ParticleVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleVector</code></pre><p>The structure used to store particles, sort and keep track of particle indices, and keep track of unused particles. The lengths of the <code>particles</code>, <code>index</code>, <code>cell</code>, and <code>buffer</code> vectors are all the same (and stay the same during resizing of a <code>ParticleVector</code> instance). Only the first <code>nbuffer</code> elements of the <code>buffer</code> vector store indices of the actually unused particles.</p><p>Accessing <code>ParticleVector[i]</code> will return a <code>Particle</code>, with the actual particle returned being <code>ParticleVector.particles[ParticleVector.index[i]]</code>.</p><p><strong>Fields</strong></p><ul><li><code>particles</code>: the vector of particles of a single species</li><li><code>index</code>: the vector of indices of the particles (these are sorted in grid sorting, not the particles themselves)</li><li><code>cell</code>: the vector storing information in which cell a particle is located (used in grid sorting routines)</li><li><code>buffer</code>: a last-in-first-out (LIFO) queue keeping track of pre-allocated but unused particles</li><li><code>nbuffer</code>: the number of elements in the buffer</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleVector-Tuple{Any}" href="#Merzbild.ParticleVector-Tuple{Any}"><code>Merzbild.ParticleVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleVector(np)</code></pre><p>Create an empty <code>ParticleVector</code> instance of length <code>np</code> (all vectors will have length <code>np</code>).</p><p><strong>Positional arguments</strong></p><ul><li><code>np</code>: the length of the <code>ParticleVector</code> instance to create</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{ParticleVector, Any}" href="#Base.getindex-Tuple{ParticleVector, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.getindex(pv::ParticleVector, i)</code></pre><p>Returns the underlying particle in a <code>ParticleVector</code> instance with index <code>i</code>.</p><p>Is usually called as <code>ParticleVector[i]</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: <code>ParticleVector</code> instance</li><li><code>i</code>: the index of the particle to be selected</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{ParticleVector, Particle, Integer}" href="#Base.setindex!-Tuple{ParticleVector, Particle, Integer}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(pv::ParticleVector, p::Particle, i::Integer)</code></pre><p>Set the underlying particle in a <code>ParticleVector</code> instance with index <code>i</code> to a new particle.</p><p>Is usually called as <code>ParticleVector[i] = p</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: <code>ParticleVector</code> instance</li><li><code>p</code>: the <code>Particle</code> instance to write</li><li><code>i</code>: the index of the particle to be written to</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{ParticleVector}" href="#Base.length-Tuple{ParticleVector}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.length(pv::ParticleVector)</code></pre><p>Returns the length of a <code>ParticleVector</code> instance.</p><p>Is usually called as <code>length(ParticleVector)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: <code>ParticleVector</code> instance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.resize!-Tuple{ParticleVector, Integer}" href="#Base.resize!-Tuple{ParticleVector, Integer}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.resize!(pv::ParticleVector, n::Integer)</code></pre><p>Resize a <code>ParticleVector</code> instance.</p><p>Is usually called as <code>resize!(ParticleVector, n)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: <code>ParticleVector</code> instance</li><li><code>n</code>: the new length of the <code>ParticleVector</code> instance (i.e. the length of all the vector fields of the instance)</li></ul></div></section></article><h2 id="Particle-indexing"><a class="docs-heading-anchor" href="#Particle-indexing">Particle indexing</a><a id="Particle-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-indexing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexer" href="#Merzbild.ParticleIndexer"><code>Merzbild.ParticleIndexer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexer</code></pre><p>The structure used to index particles of a given species in a given cell. It is assumed that the particle indices are contiguous; they may be split across two groups of contiguous indices.</p><p><strong>Fields</strong></p><ul><li><code>n_local</code>: the number of particles in the cell</li><li><code>start1</code>: the first index in the first group of particle indices</li><li><code>end1</code>: the last index in the first group of particle indices</li><li><code>n_group1</code>: the number of particles in the first group (<code>n_group1 = end1 - start1 + 1</code>)</li><li><code>start2</code>: the first index in the second group of particle indices, if no particles are present   in the group, it should be &lt;= 0</li><li><code>end2</code>: the last index in the second group of particle indices</li><li><code>n_group2</code>: the number of particles in the second group (<code>n_group2 = end2 - start2 + 1</code>,   unless no particles are present in the second group)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexer-Tuple{}" href="#Merzbild.ParticleIndexer-Tuple{}"><code>Merzbild.ParticleIndexer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexer()</code></pre><p>Create an empty ParticleIndexer. <code>end1</code> and <code>end2</code> are set to -1, the other fields are set to 0.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexer-Tuple{Any}" href="#Merzbild.ParticleIndexer-Tuple{Any}"><code>Merzbild.ParticleIndexer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexer(n_particles)</code></pre><p>Create a ParticleIndexer given a number of particles. All particles are in group 1, with indices starting from 1.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_particles</code>: the number of particles</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray" href="#Merzbild.ParticleIndexerArray"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray</code></pre><p>A structure to store an array of <code>ParticleIndexer</code> instances for each species in each cell. It also stores information about the whether the ParticleIndexer instances for each species are &quot;contiguous&quot;. A set of ParticleIndexer instances (for a specific species) are &quot;contiguous&quot; if the following conditions are fulfilled (assuming all cells contain particles and in all cells have both <code>n_group1&gt;0</code> and <code>n_group2&gt;0</code>, for a more detailed explanation, one is referred to <a href="../contiguous_indexing/#Contiguous-indexing">the documentation on contiguous indexing</a>):</p><ul><li><code>pia.indexer[cell,species].end1 + 1 == pia.indexer[cell+1,species].start1</code>, <code>cell = 1,...,n_cells - 1</code></li><li><code>pia.indexer[n_cells,species].end1 + 1 == pia.indexer[1,species].start2</code></li><li><code>pia.indexer[cell,species].end2 + 1 == pia.indexer[cell+1,species].start2</code>, <code>cell = 1,...,n_cells - 1</code></li></ul><p><strong>Fields</strong></p><ul><li><code>indexer</code>: the array of size <code>(n_cells, n_species)</code> (number of grid cells * number of species in the simulation) storing the <code>ParticleIndexer</code> instances</li><li><code>n_total</code>: vector of length <code>n_species</code> storing the total number of particles of each species</li><li><code>contiguous</code>: vector of length <code>n_species</code> storing a boolean flag whether the ParticleIndexer instances for a species are &quot;contiguous&quot;</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray-Tuple{Matrix{ParticleIndexer}, Any}" href="#Merzbild.ParticleIndexerArray-Tuple{Matrix{ParticleIndexer}, Any}"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray(indexer_arr::Array{ParticleIndexer,2}, n_total)</code></pre><p>Creates a <code>ParticleIndexerArray</code> from a 2-D array of <code>ParticleIndexer</code> instances.</p><p><strong>Positional arguments</strong></p><ul><li><code>indexer_arr</code>: the 2-D array of <code>ParticleIndexer</code> instances</li><li><code>n_total</code>: the vector of the total number of particles of each species</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray-Tuple{Integer, Integer}" href="#Merzbild.ParticleIndexerArray-Tuple{Integer, Integer}"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray(n_cells::Integer, n_species::Integer)</code></pre><p>Create an empty <code>ParticleIndexerArray</code> given the number of cells and species</p><p><strong>Positional arguments</strong></p><ul><li><code>n_cells</code>: the number of grid cells</li><li><code>n_species</code>: the number of species</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray-Tuple{Integer}" href="#Merzbild.ParticleIndexerArray-Tuple{Integer}"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray(n_particles::Integer)</code></pre><p>Create a single-species/single-cell <code>ParticleIndexerArray</code> and set up the indexing for <code>n_particles</code> in group 1 in cell 1.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_particles</code>: the number of particles (integer number)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray-Tuple{T} where T&lt;:(AbstractVector)" href="#Merzbild.ParticleIndexerArray-Tuple{T} where T&lt;:(AbstractVector)"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray(n_particles::T) where T&lt;:AbstractVector</code></pre><p>Create a multi-species/single-cell <code>ParticleIndexerArray</code> and set up the indexing for <code>n_particles[species]</code> in group 1 in cell 1 for all <code>species</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_particles</code>: the number of particles of each species (vector-like)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ParticleIndexerArray-Tuple{Any, Array{Species}}" href="#Merzbild.ParticleIndexerArray-Tuple{Any, Array{Species}}"><code>Merzbild.ParticleIndexerArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleIndexerArray(grid, species_data::Array{Species}) where T&lt;:AbstractVector</code></pre><p>Create an empty multi-species/multi-cell <code>ParticleIndexerArray</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>grid</code>: the simulation grid</li><li><code>species_data</code>: array of <code>Species</code> data for all of the species in the simulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.squash_pia!" href="#Merzbild.squash_pia!"><code>Merzbild.squash_pia!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">squash_pia!(pv, pia, species)</code></pre><p>Restore the continuity of indices in a <code>ParticleVector and associated</code>ParticleIndexerArray<code>instance for a specific species. If for this species the instance has</code>contiguous == true`, nothing will be done.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: the <code>ParticleVector</code></li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species for which to restore continuity of indices</li></ul></div></section><section><div><pre><code class="language-julia hljs">squash_pia!(particles, pia)</code></pre><p>Restore the continuity of indices in a list of <code>ParticleVector</code>s and the associated <code>ParticleIndexerArray</code> instance for all species. If for a specific species the instance has <code>contiguous == true</code>, nothing will be done.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the list of <code>ParticleVector</code>s for all species in the flow</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.count_disordered_particles" href="#Merzbild.count_disordered_particles"><code>Merzbild.count_disordered_particles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count_disordered_particles(pv, pia, species)</code></pre><p>Count number of particles of species for which <code>pv.index[i] != i + offset(cell)</code>. The larger this count, the less orderly the layout of particles in memory, which can potentially lead to decreased performance. This only considers particles present in the simulation, i.e. <code>i&lt;=pia.n_total[species]</code>, assumes contiguous indexing, and that particles are only pointed to by the first group of a <code>ParticleIndexer</code>, which is the case after particles have been sorted.</p><p>In case <code>use_offset</code> is <code>false</code>, the value of <code>offset</code> is always 0, so the function simply counts all particles where <code>pv.index[i] != i</code>. If <code>use_offset</code> is set to <code>true</code>, for each cell <code>cell</code>, the offset is whilst iterating over the particles in a cell. So in case the indexing in a cell is simply offset by a constant value, or a subset of indices are offset by a constant value, and particles are still laid out continuously in memory, this provides a more accurate measurement of the degree of fragmentation of the particle array.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: the <code>ParticleVector</code> instance for which to compute the metric</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species for which the metric is computed</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_offset</code>: whether to account for cell-specific offsets in the indexing</li></ul><p><strong>Returns</strong></p><p>The number of particles where the index to the <code>index</code> array and the value of the <code>index</code> array do not coincide.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.check_unique_index" href="#Merzbild.check_unique_index"><code>Merzbild.check_unique_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_unique_index(pv, pia, species)</code></pre><p>Test that for all particles in a simulation, no two indices are the same, i.e. no two particles <code>i</code> and <code>j</code>, <code>i!=j</code> point to the same underlying particle. This function allocates a temporary array and is thus intended for debugging/verifying code and not for efficient simulations. It also checks that any particles present in the buffer are not pointed to by the indexing.</p><p><strong>Positional arguments</strong></p><ul><li><code>pv</code>: the <code>ParticleVector</code> instance for which to check indexing</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the species for which to check indexing</li></ul><p><strong>Returns</strong></p><p>If a particle exists to which more than 1 index is pointing, and particles in the buffer ARE NOT pointed to by the indicies, returns <code>(false, n_index)</code>, where <code>n_index</code> is the number of indices pointing to the same particle.</p><p>If a particle exists to which more than 1 index is pointing, and particles in the buffer ARE pointed to by the indicies, returns <code>(false, -n_index)</code>, where <code>n_index</code> is the number of indices pointing to the same particle.</p><p>If no particles exist to which more than 1 index is pointing, but a particle in a buffer is pointed to by the indexing, returns <code>(false, -1)</code>.</p><p>If indexing is correct, returns <code>(true, 0)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.check_pia_is_correct" href="#Merzbild.check_pia_is_correct"><code>Merzbild.check_pia_is_correct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_pia_is_correct(pia, species)</code></pre><p>Check that a <code>ParticleIndexerArray</code> instance entries are correct. This means that for each cell for each species, the following should hold:     * <code>n_local == n_group1 + n_group2</code>     * if <code>n_group1 &gt; 0</code>, then <code>n_group1 == end1 - start1 + 1</code>     * if <code>n_group1 == 0</code>, then <code>start1 == 0</code>, <code>end1 == -1</code>     * if <code>n_group2 &gt; 0</code>, then <code>n_group1 == end2 - start2 + 1</code>     * if <code>n_group2 == 0</code>, then <code>start2 == 0</code>, <code>end2 == -1</code>     * <code>pia.n_total[species] == sum([pia.indexer[cell, species].n_local for cell in 1:n_cells])</code></p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance for which to check consistency</li><li><code>species</code>: the species for which to check indexing</li></ul><p><strong>Returns</strong></p><p>If indexing is incorrect in a cell <code>i</code>, returns <code>(false, i)</code>.</p><p>If the total number of particles as given by cell-wise particle indices is not equal to <code>pia.n_total[species]</code>, returns <code>(false, 0)</code>.</p><p>If indexing is correct, returns <code>(true, 0)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.pretty_print_pia" href="#Merzbild.pretty_print_pia"><code>Merzbild.pretty_print_pia</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pretty_print_pia(pia)</code></pre><p>Display a <code>ParticleIndexerArray</code> instance by showing the starting/ending indices of the groups over all cells for a specific species.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species for which the indices are displayed</li></ul></div></section></article><h2 id="Loading-species-and-interaction-data"><a class="docs-heading-anchor" href="#Loading-species-and-interaction-data">Loading species and interaction data</a><a id="Loading-species-and-interaction-data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-species-and-interaction-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.Species" href="#Merzbild.Species"><code>Merzbild.Species</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Species</code></pre><p>A structure to store information about a chemical species.</p><p><strong>Fields</strong></p><ul><li><code>name</code>: the name of the species</li><li><code>mass</code>: the molecular mass of the species</li><li><code>charge</code>: the charge of the species in terms of elementary charge (i.e. 1, -1, etc.)</li><li><code>charge_div_mass</code>: the charge of the species divided by its mass, C/kg</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.Interaction" href="#Merzbild.Interaction"><code>Merzbild.Interaction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Interaction</code></pre><p>Structure to store interaction parameters for a 2-species interaction. The VHS model uses the following power law: <span>$\sigma_{VHS} = C g^(1 - 2 \omega_{VHS})$</span>, where <span>$omega$</span> is the exponent of the VHS potential, and <span>$C$</span> is the pre-computed factor: <span>$C = \pi D_{VHS}^2 (2 T_{ref,VHS}/m_r)^{(\omega_{VHS} - 0.5)} \frac{1}{\Gamma(2.5 - \omega_{VHS})}$</span>.</p><p><strong>Fields</strong></p><ul><li><code>m_r</code>: collision-reduced mass</li><li><code>μ1</code>: relative mass of the first species</li><li><code>μ2</code>: relative mass of the second species</li><li><code>vhs_d</code>: diameter for the VHS potential</li><li><code>vhs_o</code>: exponent for the VHS potential</li><li><code>vhs_Tref</code>: reference temperature for the VHS potential</li><li><code>vhs_muref</code>: reference viscosity for the VHS potential</li><li><code>vhs_factor</code>: pre-computed factor for calculation of the VHS cross-section</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.load_species_data" href="#Merzbild.load_species_data"><code>Merzbild.load_species_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_species_data(species_filename, species_names)</code></pre><p>Load a vector of species data (mass, charge, etc.) from a TOML file.</p><p><strong>Positional arguments</strong></p><ul><li><code>species_filename</code>: the path to the TOML file containing the data</li><li><code>species_names</code>: a list of the names of the species for which to load the data</li></ul><p><strong>Returns</strong></p><p>Vector of <code>Species</code> filled with data loaded from the file. </p></div></section><section><div><pre><code class="language-julia hljs">load_species_data(species_filename, species_name::String)</code></pre><p>Load a vector of species data (mass, charge, etc.) from a TOML file for a single species.</p><p><strong>Positional arguments</strong></p><ul><li><code>species_filename</code>: the path to the TOML file containing the data</li><li><code>species_name</code>: the name of the species for which to load the data</li></ul><p><strong>Returns</strong></p><p>Vector of <code>Species</code> filled with data loaded from the file.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.load_interaction_data" href="#Merzbild.load_interaction_data"><code>Merzbild.load_interaction_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_interaction_data(interactions_filename, species_data)</code></pre><p>Load interaction data from a TOML file given a list of species&#39; data (list of <code>Species</code> instances). It will load interaction data for all possible pair-wise interactions of the species in the list.</p><p>The resulting 2-D array has the interaction data for <code>Species[i]</code> with <code>Species[k]</code> in position <code>[i,k]</code>. It is not symmetric, as the relative collision masses <code>μ1</code> and <code>μ2</code> are swapped when comparing the <code>Interaction</code> instances in positions <code>[i,k]</code> and <code>[k,i]</code>. If no data is found, the function throws an error.</p><p><strong>Positional arguments</strong></p><ul><li><code>interactions_filename</code>: the path to the TOML file containing the data</li><li><code>species_data</code>: list of <code>Species</code> instances for which to search for the interaction data</li></ul><p><strong>Returns</strong></p><ul><li>2-dimensional array of <code>Interaction</code> instances of size <code>(n_species, n_species)</code></li></ul><p><strong>Throws</strong></p><p><code>KeyError</code> if interaction data not found in the file.</p></div></section><section><div><pre><code class="language-julia hljs">load_interaction_data(interactions_filename, species_data)</code></pre><p>Load interaction data from a TOML file given a list of species&#39; data (list of <code>Species</code> instances), filling in dummy VHS data in case no entry is found in the TOML file. Useful for interactions where the VHS model doesn&#39;t make sense, for example electron-neutral interactions.</p><p>It will load interaction data for all possible pair-wise interactions of the species in the list. The resulting 2-D array has the interaction data for <code>Species[i]</code> with <code>Species[k]</code> in position <code>[i,k]</code>. It is not symmetric, as the relative collision masses <code>μ1</code> and <code>μ2</code> are swapped when comparing the <code>Interaction</code> instances in positions <code>[i,k]</code> and <code>[k,i]</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>interactions_filename</code>: the path to the TOML file containing the data</li><li><code>species_data</code>: list of <code>Species</code> instances for which to search for the interaction data</li><li><code>dummy_vhs_d</code>: value to use for the VHS diameter if no interaction data found in the file</li><li><code>dummy_vhs_o</code>: value to use for the VHS exponent if no interaction data found in the file</li><li><code>dummy_vhs_Tref</code>: value to use for the VHS reference temperature if no interaction data found in the file</li></ul><p><strong>Returns</strong></p><ul><li>2-dimensional array of <code>Interaction</code> instances of size <code>(n_species, n_species)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.load_interaction_data_with_dummy" href="#Merzbild.load_interaction_data_with_dummy"><code>Merzbild.load_interaction_data_with_dummy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_interaction_data_with_dummy(interactions_filename, species_data)</code></pre><p>Load interaction data from a TOML file given a list of species&#39; data (list of <code>Species</code> instances), filling in dummy VHS data in case no entry is found in the TOML file. Useful for interactions where the VHS model doesn&#39;t make sense, for example electron-neutral interactions. Uses a value of <code>1e-10</code> for the dummy VHS diameter, <code>1.0</code> for the dummy VHS exponent, and <code>273.0</code> for the dummy VHS reference temperature.</p><p>It will load interaction data for all possible pair-wise interactions of the species in the list. The resulting 2-D array has the interaction data for <code>Species[i]</code> with <code>Species[k]</code> in position <code>[i,k]</code>. It is not symmetric, as the relative collision masses <code>μ1</code> and <code>μ2</code> are swapped when comparing the <code>Interaction</code> instances in positions <code>[i,k]</code> and <code>[k,i]</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>interactions_filename</code>: the path to the TOML file containing the data</li><li><code>species_data</code>: list of <code>Species</code> instances for which to search for the interaction data</li></ul><p><strong>Returns</strong></p><ul><li>2-dimensional array of <code>Interaction</code> instances of size <code>(n_species, n_species)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.load_species_and_interaction_data" href="#Merzbild.load_species_and_interaction_data"><code>Merzbild.load_species_and_interaction_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_species_and_interaction_data(species_filename, interactions_filename, species_names; fill_dummy=true)</code></pre><p>Given a list of species&#39; names, load the species and interaction data (filling with dummy data if needed).</p><p><strong>Positional arguments</strong></p><ul><li><code>species_filename</code>: the path to the TOML file containing the species&#39; data</li><li><code>interactions_filename</code>: the path to the TOML file containing the interaction data</li><li><code>species_name</code>: the name of the species for which to load the data</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>fill_dummy</code>: if <code>true</code>, fill interaction data with computed dummy values if no entry found for a species pair in the interaction file</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code> of <code>Species</code> instances</li><li>2-dimensional array of <code>Interaction</code> instances of size <code>(n_species, n_species)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.load_electron_neutral_interactions" href="#Merzbild.load_electron_neutral_interactions"><code>Merzbild.load_electron_neutral_interactions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_electron_neutral_interactions(species_data, filename, databases, scattering_laws, energy_splits)</code></pre><p>Load electron-neutral interaction data from an LXCAT format XML file for a set of given neutral species.</p><p><strong>Positional arguments</strong></p><ul><li><code>species_data</code>: vector of <code>Species</code> data for the neutral species</li><li><code>filename</code>: path to XML file</li><li><code>databases</code>: dictionary of <code>(species.name =&gt; database)</code> pairs, specifying the name</li></ul><p>of the cross-section database in the XML file to use for the species </p><ul><li><code>scattering_laws</code>: vector of <code>ScatteringLaw</code> instances to use for each species</li><li><code>energy_splits</code>: vector of <code>ElectronEnergySplit</code> instances to use for each species</li></ul><p><strong>Returns</strong></p><p><code>ElectronNeutralInteractions</code> structure containing the electron-neutral interaction data.</p><p><strong>Throws</strong></p><p><code>DataMissingException</code> if data not found or not all required data present.</p></div></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.maxwellian" href="#Merzbild.maxwellian"><code>Merzbild.maxwellian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxwellian(vx, vy, vz, m, T)</code></pre><p>Evaluate the Maxwell distribution with temperature <code>T</code> for a species with mass <code>m</code>     at a velocity <code>(vx, vy, vz)</code></p><p><strong>Positional arguments</strong></p><ul><li><code>vx</code>: x velocity</li><li><code>vy</code>: y velocity</li><li><code>vz</code>: z velocity</li><li><code>m</code>: species&#39; mass</li><li><code>T</code>: temperature</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.bkw" href="#Merzbild.bkw"><code>Merzbild.bkw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bkw(vx, vy, vz, m, T, scaled_time)</code></pre><p>Evaluate the Bobylev-Krook-Wu (BKW) distribution with temperature <code>T</code> for a species with mass <code>m</code>     at a velocity <code>(vx, vy, vz)</code> and scaled time <code>scaled_time</code></p><p><strong>Positional arguments</strong></p><ul><li><code>vx</code>: x velocity</li><li><code>vy</code>: y velocity</li><li><code>vz</code>: z velocity</li><li><code>m</code>: species&#39; mass</li><li><code>T</code>: temperature</li><li><code>scaled_time</code>: the scaled_time</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.sample_on_grid!" href="#Merzbild.sample_on_grid!"><code>Merzbild.sample_on_grid!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_on_grid!(rng, vdf_func, particles, nv, m, T, n_total,
                xlo, xhi, ylo, yhi, zlo, zhi; v_mult=3.5, cutoff_mult=3.5, noise=0.0,
                v_offset=[0.0, 0.0, 0.0])</code></pre><p>Sample particles by evaluating a distribution on a discrete velocity grid, considering only points inside a sphere of a given radius (the value of the VDF at points outside of the sphere will be 0.0). The values of the VDF at the grid points will then be the computational weights of the particles, and the particles velocities are taken to be the velocities of the corresponding grid nodes (with additional uniformly distributed noise). Note: this can produce a large amount of particles for fine grids (as the number of grid nodes scales as <code>nv^3</code>.) The grid is assumed to have the same number of nodes <code>nv</code> in each direction, and the extent is computed as <code>v_mult * v_thermal</code>, where <code>v_thermal</code> is the thermal velocity <span>$\sqrt(2kT/m)$</span>, and <code>v_mult</code> is a user-defined parameter. The positions of the particles are assumed to be randomly distributed in a cuboid.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: The random number generator</li><li><code>vdf_func</code>: the distribution function to be evaluated which takes the x, y, and z velocities as parameters</li><li><code>particles</code>: the <code>Vector</code>-like structure holding the particles</li><li><code>nv</code>: the number of grid nodes in each direction</li><li><code>m</code>: the molecular mass of the species</li><li><code>T</code>: the temperature used to compute the thermal velocity</li><li><code>n_total</code>: the total computational weight (number of physical particles) to be sampled</li><li><code>xlo</code>: the lower bound of the x coordinates of the particles</li><li><code>xhi</code>: the upper bound of the x coordinates of the particles</li><li><code>ylo</code>: the lower bound of the y coordinates of the particles</li><li><code>yhi</code>: the upper bound of the y coordinates of the particles</li><li><code>zlo</code>: the lower bound of the z coordinates of the particles</li><li><code>zhi</code>: the upper bound of the z coordinates of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>v_mult</code>: the value by which the thermal velocity is multiplied to compute the extent of the velocity grid</li><li><code>cutoff_mult</code>: the value by which the thermal velocity is multiplied to compute the radius for the sphere    used to cut-off the higher velocities</li><li><code>noise</code>: controls the amount of noise added to the particle velocities (the noise is uniformly distributed   on the interval <code>[-noise*dv, noise*dv]</code>, where <code>dv</code> is the grid spacing)</li><li><code>v_offset</code>: the streaming velocity vector to be added to the particle velocities</li></ul><p><strong>Returns</strong></p><ul><li>The number of particles created</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.sample_maxwellian_on_grid!" href="#Merzbild.sample_maxwellian_on_grid!"><code>Merzbild.sample_maxwellian_on_grid!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_maxwellian_on_grid!(rng, particles, nv, m, T, n_total,
                           xlo, xhi, ylo, yhi, zlo, zhi; v_mult=3.5, cutoff_mult=3.5, noise=0.0,
                           v_offset=[0.0, 0.0, 0.0])</code></pre><p>Sample particles by evaluating a Maxwellian on a discrete velocity grid, considering only points inside a sphere of a given radius (the value of the VDF at points outside of the sphere will be 0.0). The values of the VDF at the grid points will then be the computational weights of the particles, and the particles velocities are taken to be the velocities of the corresponding grid nodes (with additional uniformly distributed noise). Note: this can produce a large amount of particles for fine grids (as the number of grid nodes scales as <code>nv^3</code>.) The grid is assumed to have the same number of nodes <code>nv</code> in each direction, and the extent is computed as <code>v_mult * v_thermal</code>, where <code>v_thermal</code> is the thermal velocity <span>$\sqrt(2kT/m)$</span>, and <code>v_mult</code> is a user-defined parameter. The positions of the particles are assumed to be randomly distributed in a cuboid.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: The random number generator</li><li><code>particles</code>: the <code>Vector</code>-like structure holding the particles</li><li><code>nv</code>: the number of grid nodes in each direction</li><li><code>m</code>: the molecular mass of the species</li><li><code>T</code>: the temperature used to compute the thermal velocity</li><li><code>n_total</code>: the total computational weight (number of physical particles) to be sampled</li><li><code>xlo</code>: the lower bound of the x coordinates of the particles</li><li><code>xhi</code>: the upper bound of the x coordinates of the particles</li><li><code>ylo</code>: the lower bound of the y coordinates of the particles</li><li><code>yhi</code>: the upper bound of the y coordinates of the particles</li><li><code>zlo</code>: the lower bound of the z coordinates of the particles</li><li><code>zhi</code>: the upper bound of the z coordinates of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>v_mult</code>: the value by which the thermal velocity is multiplied to compute the extent of the velocity grid</li><li><code>cutoff_mult</code>: the value by which the thermal velocity is multiplied to compute the radius for the sphere    used to cut-off the higher velocities</li><li><code>noise</code>: controls the amount of noise added to the particle velocities (the noise is uniformly distributed   on the interval <code>[-noise*dv, noise*dv]</code>, where <code>dv</code> is the grid spacing)</li><li><code>v_offset</code>: the streaming velocity vector to be added to the particle velocities</li></ul><p><strong>Returns</strong></p><p>The function returns the number of particles created</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.sample_particles_equal_weight!" href="#Merzbild.sample_particles_equal_weight!"><code>Merzbild.sample_particles_equal_weight!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_particles_equal_weight!(rng, particles, pia, cell, species,
                                    nparticles, m, T, Fnum, xlo, xhi, ylo, yhi, zlo, zhi;
                                    distribution=:Maxwellian, vx0=0.0, vy0=0.0, vz0=0.0)</code></pre><p>Sample equal-weight particles of a specific species in a specific cell from a distribution. The positions of the particles are assumed to be randomly distributed in a cuboid. Note: this does not work if applied twice in a row to the same cell.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>particles</code>: the <code>Vector</code>-like structure holding the particles</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the cell index</li><li><code>species</code>: the species index</li><li><code>nparticles</code>: the number of particles to sample</li><li><code>m</code>: species&#39; mass</li><li><code>T</code>: temperature</li><li><code>Fnum</code>: the computational weight of the particles</li><li><code>xlo</code>: the lower bound of the x coordinates of the particles</li><li><code>xhi</code>: the upper bound of the x coordinates of the particles</li><li><code>ylo</code>: the lower bound of the y coordinates of the particles</li><li><code>yhi</code>: the upper bound of the y coordinates of the particles</li><li><code>zlo</code>: the lower bound of the z coordinates of the particles</li><li><code>zhi</code>: the upper bound of the z coordinates of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>distribution</code>: the distribution to sample from (either <code>:Maxwellian</code> or <code>:BKW</code>)</li><li><code>vx0</code>: the x-velocity offset to add to the particle velocities</li><li><code>vy0</code>: the y-velocity offset to add to the particle velocities</li><li><code>vz0</code>: the z-velocity offset to add to the particle velocities</li></ul></div></section><section><div><pre><code class="language-julia hljs">sample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ppc::Integer, T, Fnum)</code></pre><p>Sample particles from a Maxwellian distribution in each cell of a 1-D uniform grid given the number of particles per cell.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid1duniform</code>: the 1-D uniform grid</li><li><code>particles</code>: the <code>ParticleVector</code> of particles</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>species</code>: the index of the species to be sampled for</li><li><code>species_data</code>: <code>Vector</code> of <code>Species</code> data</li><li><code>ppc</code>: number of particles per cell to be sampled</li><li><code>T</code>: the temperature</li><li><code>Fnum</code>: the computational weight of the particles</li></ul></div></section><section><div><pre><code class="language-julia hljs">sample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ppc::Integer, T, Fnum, cell_chunk)</code></pre><p>Sample particles from a Maxwellian distribution in a sequentially ordered subset of cells of a 1-D uniform grid given the number of particles per cell.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid1duniform</code>: the 1-D uniform grid</li><li><code>particles</code>: the <code>ParticleVector</code> of particles</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>species</code>: the index of the species to be sampled for</li><li><code>species_data</code>: <code>Vector</code> of <code>Species</code> data</li><li><code>ppc</code>: number of particles per cell to be sampled</li><li><code>T</code>: the temperature</li><li><code>Fnum</code>: the computational weight of the particles</li><li><code>cell_chunk</code>: the list of cell indices or range in which to sample particles, should be ordered in increasing order</li></ul></div></section><section><div><pre><code class="language-julia hljs">sample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ndens::Float64, T, Fnum)</code></pre><p>Sample particles from a Maxwellian distribution in each cell in a sequentially ordered subset of cells of a 1-D uniform grid given the target number density. If the computed number of particles is not an integer value, the fractional remainder is used to probabilistically sample an extra particle, so that on average, the expected number density is achieved.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid1duniform</code>: the 1-D uniform grid</li><li><code>particles</code>: the <code>ParticleVector</code> of particles</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>species</code>: the index of the species to be sampled for</li><li><code>species_data</code>: <code>Vector</code> of <code>Species</code> data</li><li><code>ndens</code>: target number density</li><li><code>T</code>: the temperature</li><li><code>Fnum</code>: the computational weight of the particles</li></ul></div></section><section><div><pre><code class="language-julia hljs">sample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ndens::Float64, T, Fnum)</code></pre><p>Sample particles from a Maxwellian distribution in each cell of 1-D uniform grid given the target number density. If the computed number of particles is not an integer value, the fractional remainder is used to probabilistically sample an extra particle, so that on average, the expected number density is achieved.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid1duniform</code>: the 1-D uniform grid</li><li><code>particles</code>: the <code>ParticleVector</code> of particles</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>species</code>: the index of the species to be sampled for</li><li><code>species_data</code>: <code>Vector</code> of <code>Species</code> data</li><li><code>ndens</code>: target number density</li><li><code>T</code>: the temperature</li><li><code>Fnum</code>: the computational weight of the particles</li><li><code>cell_chunk</code>: the list of cell indices or range in which to sample particles, should be ordered in increasing order</li></ul></div></section></article><h2 id="Computing-grid-and-surface-macroscopic-properties"><a class="docs-heading-anchor" href="#Computing-grid-and-surface-macroscopic-properties">Computing grid and surface macroscopic properties</a><a id="Computing-grid-and-surface-macroscopic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-grid-and-surface-macroscopic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.PhysProps" href="#Merzbild.PhysProps"><code>Merzbild.PhysProps</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhysProps</code></pre><p>Structure to store computed physical properties in a physical cell.</p><p><strong>Fields</strong></p><ul><li><code>ndens_not_Np</code>: whether the <code>n</code> field stores number density (if <code>true</code>) and not the number of physical particles in a cell (if <code>false</code>)</li><li><code>n_cells</code>: number of physical cells</li><li><code>n_species</code>: number of species</li><li><code>n_moments</code>: number of total moments computed</li><li><code>lpa</code>: length of the particle array (vector of length <code>n_species</code>)</li><li><code>np</code>: number of particles (array of shape <code>(n_cells, n_species)</code>)</li><li><code>n</code>: number density or number of physical particles in a cell (array of shape <code>(n_cells, n_species)</code>)</li><li><code>v</code>: per-species flow velocity in a cell (array of shape <code>(3, n_cells, n_species)</code>)</li><li><code>T</code>: per-species temperature in a cell (array of shape <code>(n_cells, n_species)</code>)</li><li><code>moment_powers</code>: powers of the total moments computed (vector of length <code>n_moments</code>)</li><li><code>moments</code>: values of the total moments computed (array of shape <code>(n_moments, n_cells, n_species)</code>)</li><li><code>Tref</code>: reference temperature used to scale moments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.PhysProps-Tuple{Any, Any, Any}" href="#Merzbild.PhysProps-Tuple{Any, Any, Any}"><code>Merzbild.PhysProps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhysProps(n_cells, n_species, moments_list; ndens_not_Np=false, Tref=300.0)</code></pre><p>Construct physical properties given the number of cells and species, as well as the list of the orders of total moments to compute. The total moment of order <span>$M$</span> is defined as <span>$\int \sqrt{v_x^2+v_y^2+v_z^2}^M f(v_x,v_y,v_z)dv_x dv_y dv_z$</span>.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_cells</code>: number of cells</li><li><code>n_species</code>: number of species</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ndens_not_Np</code>: whether the <code>n</code> field stores number density (if <code>true</code>) and not the number of physical particles in a cell (if <code>false</code>)</li><li><code>Tref</code>: reference temperature used to compute the total moments of a Maxwellian distribution which   are used to scale the total moments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.PhysProps-Tuple{Any, Any}" href="#Merzbild.PhysProps-Tuple{Any, Any}"><code>Merzbild.PhysProps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhysProps(pia, moments_list; ndens_not_Np=false, Tref=300.0)</code></pre><p>Construct physical properties given a <code>ParticleIndexerArray</code> instance, as well as the list of the orders of total moments to compute. The total moment of order <span>$M$</span> is defined as <span>$\int \sqrt{v_x^2+v_y^2+v_z^2}^M f(v_x,v_y,v_z)dv_x dv_y dv_z$</span>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>n_species</code>: number of species</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ndens_not_Np</code>: whether the <code>n</code> field stores number density (if <code>true</code>) and not the number of physical particles in a cell (if <code>false</code>)</li><li><code>Tref</code>: reference temperature used to compute the total moments of a Maxwellian distribution which   are used to scale the total moments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.PhysProps-Tuple{Any}" href="#Merzbild.PhysProps-Tuple{Any}"><code>Merzbild.PhysProps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhysProps(pia; ndens_not_Np=false)</code></pre><p>Construct physical properties given a <code>ParticleIndexerArray</code> instance, with no computation of the total moments.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ndens_not_Np</code>: whether the <code>n</code> field stores number density (if <code>true</code>) and not the number of physical particles in a cell (if <code>false</code>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.SurfProps" href="#Merzbild.SurfProps"><code>Merzbild.SurfProps</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurfProps</code></pre><p>Structure to store computed surface properties.</p><p><strong>Fields</strong></p><ul><li><code>n_elements</code>: number of physical cells</li><li><code>n_species</code>: number of species</li><li><code>areas</code>: the vector of surface element areas</li><li><code>inv_areas</code>: the vector of the inverse surface element areas</li><li><code>normals</code>: the array of surface element normals with shape  <code>(3, n_elements)</code></li><li><code>np</code>: number of particles impacting the surface elements, array of shape <code>(n_elements, n_species)</code></li><li><code>flux_incident</code>: incident mass flux per surface element, array of shape <code>(n_elements, n_species)</code></li><li><code>flux_reflected</code>: reflected mass flux per surface element, array of shape <code>(n_elements, n_species)</code></li><li><code>force</code>: force acting per surface element, array of shape <code>(3, n_elements, n_species)</code></li><li><code>normal_pressure</code>: normal pressure per surface element, array of shape <code>(n_elements, n_species)</code></li><li><code>shear_pressure</code>: shear pressure per surface element, array of shape <code>(3, n_elements, n_species)</code></li><li><code>kinetic_energy_flux</code>: kinetic energy flux per surface element, array of shape <code>(n_elements, n_species)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.SurfProps-NTuple{4, Any}" href="#Merzbild.SurfProps-NTuple{4, Any}"><code>Merzbild.SurfProps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurfProps(n_elements, n_species, area, normals)</code></pre><p><strong>Positional arguments</strong></p><ul><li><code>n_elements</code></li><li><code>n_species</code></li><li><code>areas</code></li><li><code>normals</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.SurfProps-Tuple{Any, Grid1DUniform}" href="#Merzbild.SurfProps-Tuple{Any, Grid1DUniform}"><code>Merzbild.SurfProps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurfProps(pia, grid::Grid1DUniform)</code></pre><p>Create a <code>SurfProps</code> struct for a 1-D grid, with element 1 corresponding to the left wall and element 2 corresponding to the right wall. The areas of the wall are assumed to be equal to 1, the normals are parallel to the x axis.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>grid</code>: the <code>Grid1DUniform</code> grid</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.compute_props!" href="#Merzbild.compute_props!"><code>Merzbild.compute_props!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_props!(particles, pia, species_data, phys_props)</code></pre><p>Compute the physical properties of all species in all cells and store the result in a <code>PhysProps</code> instance. This function does not compute the total moments, even if <code>phys_props.n_moments &gt; 0</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.compute_props_with_total_moments!" href="#Merzbild.compute_props_with_total_moments!"><code>Merzbild.compute_props_with_total_moments!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_props_with_total_moments!(particles, pia, species_data, phys_props)</code></pre><p>Compute the physical properties of all species in all cells and store the result in a <code>PhysProps</code> instance. This function computes the total moments.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.compute_props_sorted!" href="#Merzbild.compute_props_sorted!"><code>Merzbild.compute_props_sorted!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_props_sorted!(particles, pia, species_data, phys_props, cell_chunk)</code></pre><p>Compute the physical properties of all species in a subset of cells and store the result in a <code>PhysProps</code> instance, assuming the particles are sorted. This function does not compute the total moments, even if <code>phys_props.n_moments &gt; 0</code>. Currently this does not compute the length of the particle array.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li><li><code>cell_chunk</code>: the list of cell indices or range of cell indices in which to compute the properties</li></ul></div></section><section><div><pre><code class="language-julia hljs">compute_props_sorted!(particles, pia, species_data, phys_props)</code></pre><p>Compute the physical properties of all species in all cells and store the result in a <code>PhysProps</code> instance, assuming the particles are sorted. This function does not compute the total moments, even if <code>phys_props.n_moments &gt; 0</code>. Currently this does not compute the length of the particle array.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li></ul></div></section><section><div><pre><code class="language-julia hljs">compute_props_sorted!(particles, pia, species_data, phys_props, grid::G, cell_chunk) where {G&lt;:AbstractGrid}</code></pre><p>Compute the physical properties of all species in a subset of cells and store the result in a <code>PhysProps</code> instance, assuming the particles are sorted. This function does not compute the total moments, even if <code>phys_props.n_moments &gt; 0</code>. If <code>ndens_not_Np</code> is <code>true</code>, the number density will be computed based on the volumes of the grid cells; otherwise, the number of physical particles in each cell will be computed. Currently this does not compute the length of the particle array.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li><li><code>grid</code>: the physical grid</li><li><code>cell_chunk</code>: the list of cell indices or range of cell indices in which to compute the properties</li></ul></div></section><section><div><pre><code class="language-julia hljs">compute_props_sorted!(particles, pia, species_data, phys_props, grid::AbstractGrid)</code></pre><p>Compute the physical properties of all species in all cells and store the result in a <code>PhysProps</code> instance, assuming the particles are sorted. This function does not compute the total moments, even if <code>phys_props.n_moments &gt; 0</code>. If <code>ndens_not_Np</code> is <code>true</code>, the number density will be computed based on the volumes of the grid cells; otherwise, the number of physical particles in each cell will be computed. Currently this does not compute the length of the particle array.</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: the <code>Vector</code> of <code>ParticleVector</code>s containing all the particles in a simulation</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species_data</code>: the <code>Vector</code> of <code>SpeciesData</code></li><li><code>phys_props</code>: the <code>PhysProps</code> instance in which the computed physical properties are stored</li><li><code>grid</code>: the physical grid</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.avg_props!" href="#Merzbild.avg_props!"><code>Merzbild.avg_props!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_props!(phys_props_avg, phys_props::PhysProps, n_avg_timesteps)</code></pre><p>Used to time-average computed physical properties, not including the total moments. For each instantaneous value of a property computed and stored in <code>phys_props</code>, it is divided by <code>n_avg_timesteps</code> and added to <code>phys_props_avg</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>phys_props_avg</code>: the <code>PhysProps</code> instance used to store the time-averaged properties</li><li><code>phys_props</code>: the <code>PhysProps</code> instance holding the current values of the properties   to be used for the averaging at the current timestep</li><li><code>n_avg_timesteps</code>: the number of timesteps over which the averaging is performed</li></ul><p><strong>Throws</strong></p><p><code>ErrorException</code> if <code>phys_props_avg</code> computes number density and <code>phys_props</code> computes number of physical particles, or vice versa.</p></div></section><section><div><pre><code class="language-julia hljs">avg_props!(surf_props_avg, surf_props::SurfProps, n_avg_timesteps)</code></pre><p>Used to time-average computed surface properties. For each instantaneous value of a property computed and stored in <code>surf_props</code>, it is divided by <code>n_avg_timesteps</code> and added to <code>surf_props_avg</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>surf_props_avg</code>: the <code>SurfProps</code> instance used to store the time-averaged properties</li><li><code>surf_props</code>: the <code>SurfProps</code> instance holding the current values of the properties   to be used for the averaging at the current timestep</li><li><code>n_avg_timesteps</code>: the number of timesteps over which the averaging is performed</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.clear_props!" href="#Merzbild.clear_props!"><code>Merzbild.clear_props!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear_props!(phys_props::PhysProps)</code></pre><p>Clear all data from PhysProps, for use when physical properties are averaged over timesteps and averaging over a new set of timesteps needs to be started.</p><p><strong>Positional arguments</strong></p><ul><li><code>phys_props</code>: the <code>PhysProps</code> instance to be cleared</li></ul></div></section><section><div><pre><code class="language-julia hljs">clear_props!(surf_props::SurfProps)</code></pre><p>Clear all data from a <code>SurfProps</code> instance, either at the start of a new convection step, or when physical properties are averaged over timesteps and averaging over a new set of timesteps needs to be started.</p><p><strong>Positional arguments</strong></p><ul><li><code>surf_props</code>: the <code>SurfProps</code> instance to be cleared</li></ul></div></section></article><h2 id="Collision-computations"><a class="docs-heading-anchor" href="#Collision-computations">Collision computations</a><a id="Collision-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Collision-computations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionData" href="#Merzbild.CollisionData"><code>Merzbild.CollisionData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionData</code></pre><p>Structure to store temporary collision data for a specific collision (relative velocity, collision energy, post-collision velocities, etc.)</p><p><strong>Fields</strong></p><ul><li><code>v_com</code>: vector of center-of-mass velocity</li><li><code>g</code>: magnitude of relative velocity</li><li><code>E_coll</code>: relative translational energy of the colliding particles</li><li><code>E_coll_eV</code>: relative translational energy of the colliding particles in electron-volt</li><li><code>E_coll_electron_eV</code>: collisional energy of the an electron in electron-volt for electron-neutral collisions</li><li><code>g_vec</code>: vector of pre-collisional relative velocity</li><li><code>g_vec_new</code>: vector of post-collisional relative velocity</li><li><code>g_new_1</code>: magnitude of post-collisional relative velocity of the first particle in the collision pair</li><li><code>g_new_2</code>: magnitude of post-collisional relative velocity of the second particle in the collision pair</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionData-Tuple{}" href="#Merzbild.CollisionData-Tuple{}"><code>Merzbild.CollisionData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionData()</code></pre><p>Create an empty CollisionData instance.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionFactors" href="#Merzbild.CollisionFactors"><code>Merzbild.CollisionFactors</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionFactors</code></pre><p>Structure to store NTC-related collision factors for collisions between particles of two species in a given cell.</p><p><strong>Fields</strong></p><ul><li><code>n1</code>: the number of particles of the first species in the cell</li><li><code>n2</code>: the number of particles of the second species in the cell</li><li><code>sigma_g_w_max</code>: estimate of the <span>$(\sigma g w)_{max}$</span> (<span>$\sigma$</span> is the total collision cross-section,   <span>$g$</span> is the relative collision velocity, <span>$w$</span> is the computational weight of the particles)</li><li><code>n_coll</code>: number of collisions to be tested</li><li><code>n_coll_performed</code>: number of collisions actually performed</li><li><code>n_eq_w_coll_performed</code>: number of collisions between particles with equal weights actually performed</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionFactors-Tuple{}" href="#Merzbild.CollisionFactors-Tuple{}"><code>Merzbild.CollisionFactors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionFactors()</code></pre><p>Create an empty CollisionFactors instance (all values set to 0).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionDataFP" href="#Merzbild.CollisionDataFP"><code>Merzbild.CollisionDataFP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionData</code></pre><p>Structure to store temporary collision data for the particle Fokker-Planck approach.</p><p><strong>Fields</strong></p><ul><li><code>vel_ave</code>: average velocity of the particles in the cell</li><li><code>mean</code>: mean value of the sampled velocities</li><li><code>stddev</code>: standard deviation of the sampled velocities</li><li><code>xvel_rand</code>: pre-allocated storage for sampled x-velocity components</li><li><code>yvel_rand</code>: pre-allocated storage for sampled y-velocity components</li><li><code>zvel_rand</code>: pre-allocated storage for sampled z-velocity components</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionDataFP-Tuple{}" href="#Merzbild.CollisionDataFP-Tuple{}"><code>Merzbild.CollisionDataFP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionDataFP()</code></pre><p>Create an empty CollisionDataFP instance.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.CollisionDataFP-Tuple{Any}" href="#Merzbild.CollisionDataFP-Tuple{Any}"><code>Merzbild.CollisionDataFP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionDataFP(n_particles_in_cell)</code></pre><p>Create an empty CollisionDataFP instance, pre-allocating the arrays for sampled normal variables for <code>n_particles_in_cell</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_particles_in_cell</code>: estimate of expected maximum number of particles in cell</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_collision_factors_array-Tuple{Any}" href="#Merzbild.create_collision_factors_array-Tuple{Any}"><code>Merzbild.create_collision_factors_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_collision_factors_array(n_species)</code></pre><p>Create a 3-dimensional array of collision factors for all interaction pairs for a 0-D case (1 spatial cell), with shape <code>(n_species,n_species,1)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_species</code>: number of species in the flow</li></ul><p><strong>Returns</strong></p><p>3-dimensional array of <code>CollisionFactors</code> instances with shape <code>(n_species,n_species,1)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_collision_factors_array-Tuple{Any, Any}" href="#Merzbild.create_collision_factors_array-Tuple{Any, Any}"><code>Merzbild.create_collision_factors_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_collision_factors_array(n_species, n_cells)</code></pre><p>Create a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape <code>(n_species,n_species,n_cells)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_species</code>: number of species in the flow</li><li><code>n_cells</code>: number of cells in the simulation</li></ul><p><strong>Returns</strong></p><p>3-dimensional array of <code>CollisionFactors</code> instances with shape <code>(n_species,n_species,n_cells)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_collision_factors_array-Tuple{ParticleIndexerArray}" href="#Merzbild.create_collision_factors_array-Tuple{ParticleIndexerArray}"><code>Merzbild.create_collision_factors_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_collision_factors_array(pia)</code></pre><p>Create a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape <code>(n_species,n_species,n_cells)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the ParticleIndexerArray instance</li></ul><p><strong>Returns</strong></p><p>3-dimensional array of <code>CollisionFactors</code> instances with shape <code>(n_species,n_species,n_cells)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Real, Real}" href="#Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Real, Real}"><code>Merzbild.create_collision_factors_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_collision_factors_array(pia, interactions, species_data, T::Real, Fnum::Real; mult_factor=1.0)</code></pre><p>Create a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape <code>(n_species,n_species,n_cells)</code>. This will fill the array with the estimates <span>$(\sigma g w)_{max}$</span> for all species in all cells, assuming a constant particle computational weight <code>Fnum</code>, a VHS cross-section, and that all species have a single temperature that is constant across all cells.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the ParticleIndexerArray instance</li><li><code>interactions</code>: the 2-dimensional array of <code>Interaction</code> instances (of shape <code>(n_species, n_species)</code>) of all the pair-wise interactions</li><li><code>species_data</code>: the vector of <code>Species</code> instances of the species in the flow </li><li><code>T</code>: the temperatures of the flow</li><li><code>Fnum</code>: the constant computational weight of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul><p><strong>Returns</strong></p><p>3-dimensional array of <code>CollisionFactors</code> instances with shape <code>(n_species,n_species,n_cells)</code> fille with estimated values of <span>$(\sigma g w)_{max}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Any, Real}" href="#Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Any, Real}"><code>Merzbild.create_collision_factors_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_collision_factors_array(pia, interactions, species_data, T_list, Fnum::Real; mult_factor=1.0)</code></pre><p>Create a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape <code>(n_species,n_species,n_cells)</code>. This will fill the array with the estimates <span>$(\sigma g w)_{max}$</span> for all species in all cells, assuming a constant particle computational weight <code>Fnum</code>, a VHS cross-section, and that the temperature of each species is constant across all cells.</p><p><strong>Positional arguments</strong></p><ul><li><code>pia</code>: the ParticleIndexerArray instance</li><li><code>interactions</code>: the 2-dimensional array of <code>Interaction</code> instances (of shape <code>(n_species, n_species)</code>) of all the pair-wise interactions</li><li><code>species_data</code>: the vector of <code>Species</code> instances of the species in the flow </li><li><code>T_list</code>: the list of temperatures of the species</li><li><code>Fnum</code>: the constant computational weight of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul><p><strong>Returns</strong></p><p>3-dimensional array of <code>CollisionFactors</code> instances with shape <code>(n_species,n_species,n_cells)</code> fille with estimated values of <span>$(\sigma g w)_{max}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.create_computed_crosssections" href="#Merzbild.create_computed_crosssections"><code>Merzbild.create_computed_crosssections</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_computed_crosssections(electron_neutral_interactions)</code></pre><p>Create a vector of <code>ComputedCrossSection</code> instances for the electron-neutral interactions.</p><p>Positional arguments</p><ul><li><code>electron_neutral_interactions</code>: the <code>ElectronNeutralInteractions</code> instance for which the   cross-sections will be computed</li></ul><p><strong>Returns</strong></p><p>Vector of <code>ComputedCrossSection</code> of length <code>electron_neutral_interactions.n_neutrals</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.estimate_sigma_g_w_max" href="#Merzbild.estimate_sigma_g_w_max"><code>Merzbild.estimate_sigma_g_w_max</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_sigma_g_w_max(interaction, species1, species2, T1, T2, Fnum; mult_factor=1.0)</code></pre><p>Estimate <span>$(\sigma g w)_{max}$</span> for a two-species interaction, assuming a constant particle computational weight <code>Fnum</code> and a VHS cross-section. The relative velocity <span>$g$</span> is estimated as <span>$g = 0.5 (\sqrt{2T_1 k_B / m_1} + \sqrt{2T_2 k_B / m_2})$</span>, where <span>$T_1$</span> and <span>$m_1$</span> are the temperature and mass of the first species (<code>species1</code>), and  <span>$T_2$</span> and <span>$m_2$</span> are the temperature and mass of the second species (<code>species2</code>). This relative velocity estimate is then plugged into the VHS cross-section model to compute <span>$\sigma$</span>. The result is then multiplied by <code>Fnum</code> and an (optional) factor <code>mult_factor</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>interaction</code>: the <code>Interaction</code> instance for the interacting species</li><li><code>species1</code>: the <code>Species</code> instance of the first interacting species</li><li><code>species2</code>: the <code>Species</code> instance of the second interacting species</li><li><code>T1</code>: the temperature of the first interacting species</li><li><code>T2</code>: the temperature of the second interacting species</li><li><code>Fnum</code>: the constant computational weight of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul><p><strong>Returns</strong></p><ul><li>the estimate of <span>$(\sigma g w)_{max}$</span></li></ul></div></section><section><div><pre><code class="language-julia hljs">estimate_sigma_g_w_max(interaction, species, T, Fnum; mult_factor=1.0)</code></pre><p>Estimate <span>$(\sigma g w)_{max}$</span> for a single-species interaction, assuming a constant particle computational weight <code>Fnum</code> and a VHS cross-section. Uses the same methodology as the estimate for a two-species interaction.</p><p><strong>Positional arguments</strong></p><ul><li><code>interaction</code>: the <code>Interaction</code> instance for the interacting species</li><li><code>species</code>: the <code>Species</code> instance of the interacting species</li><li><code>T</code>: the temperature of the interacting species</li><li><code>Fnum</code>: the constant computational weight of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul><p><strong>Returns</strong></p><ul><li>the estimate of <span>$(\sigma g w)_{max}$</span></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.estimate_sigma_g_w_max!" href="#Merzbild.estimate_sigma_g_w_max!"><code>Merzbild.estimate_sigma_g_w_max!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0)</code></pre><p>Estimate <span>$(\sigma g w)_{max}$</span> for all species in all cells, assuming a constant particle computational weight <code>Fnum</code>, a VHS cross-section, and that each species&#39; temperature is constant across all cells. Uses the same methodology as the estimate for a two-species interaction.</p><p><strong>Positional arguments</strong></p><ul><li><code>collision_factors</code>: 3-dimensional array of <code>CollisionFactors</code> of shape <code>(n_species, n_species, n_cells)</code></li><li><code>interactions</code>: the 2-dimensional array of <code>Interaction</code> instances (of shape <code>(n_species, n_species)</code>) of all the pair-wise interactions</li><li><code>species_data</code>: the vector of <code>Species</code> instances of the species in the flow </li><li><code>T_list</code>: the list of temperatures of the species</li><li><code>Fnum</code>: the constant computational weight of the particles</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul></div></section><section><div><pre><code class="language-julia hljs">estimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0)</code></pre><p>Estimate <span>$(\sigma g w)_{max}$</span> for all species in all cells, assuming a species-specific computational weights <code>Fnum</code>, a VHS cross-section, and that each species&#39; temperature is constant across all cells. Uses the same methodology as the estimate for a two-species interaction.</p><p><strong>Positional arguments</strong></p><ul><li><code>collision_factors</code>: 3-dimensional array of <code>CollisionFactors</code> of shape <code>(n_species, n_species, n_cells)</code></li><li><code>interactions</code>: the 2-dimensional array of <code>Interaction</code> instances (of shape <code>(n_species, n_species)</code>) of all the pair-wise interactions</li><li><code>species_data</code>: the vector of <code>Species</code> instances of the species in the flow </li><li><code>T_list</code>: the list of temperatures of the species</li><li><code>Fnum</code>: a list of the computational weights of the species</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mult_factor</code>: a factor by which to multiply the result (default value is 1.0)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.estimate_sigma_g_w_max_ntc_n_e!" href="#Merzbild.estimate_sigma_g_w_max_ntc_n_e!"><code>Merzbild.estimate_sigma_g_w_max_ntc_n_e!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_sigma_g_w_max_ntc_n_e!(rng, collision_factors, collision_data, interaction,
                                n_e_interactions, n_e_cs, particles_n, particles_e,
                                pia, cell, species_n, species_e, Δt, V; min_coll=5, n_loops=3)</code></pre><p>Estimate <span>$(\sigma g w)_{max}$</span> for an electron-neutral interaction by stochastically choosing particle pairs multiple times and computing <span>$(\sigma g w)$</span> for each pair. The number of collisions is computed using the standard variable-weight NTC formula, the value of <code>min_coll</code> is added to this number, and particles are randomly sampled. The whole procedure is repeated <code>n_loops</code> times, so that an increased value <span>$(\sigma g w)_{max}$</span> can have an impact on the computed number of pairs to select during the next loop iteration.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_factors</code>: the <code>CollisionFactors</code> for the species in question in the cell</li><li><code>collision_data</code>: <code>CollisionData</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>n_e_interactions</code>: the <code>ElectronNeutralInteractions</code> instance</li><li><code>n_e_cs</code>: the <code>ComputedCrossSections</code> instance</li><li><code>particles_n</code>: <code>ParticleVector</code> of the particles of neutral species</li><li><code>particles_e</code>: <code>ParticleVector</code> of the particles of the electron species</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species_n</code>: the index of the neutral species</li><li><code>species_e</code>: the index of the electron species</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul><p><strong>Keyword arguments:</strong></p><ul><li><code>min_coll</code>: the minimum number of pairs to test</li><li><code>n_loops</code>: the number of loops to perform (in each loop the number of collisions is computed using the   estimated value of  <span>$(\sigma g w)_{max}$</span>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ntc!-NTuple{10, Any}" href="#Merzbild.ntc!-NTuple{10, Any}"><code>Merzbild.ntc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ntc!(rng, collision_factors, collision_data, interaction, particles, pia,
     cell, species, Δt, V)</code></pre><p>Perform elastic collisions between particles of same species using the NTC algorithm and the VHS cross-section model.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_factors</code>: the <code>CollisionFactors</code> for the species in question in the cell</li><li><code>collision_data</code>: <code>CollisionData</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>particles</code>: <code>ParticleVector</code> of the particles being collided</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species</code>: the index of the species for which collisions are performed</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ntc!-NTuple{12, Any}" href="#Merzbild.ntc!-NTuple{12, Any}"><code>Merzbild.ntc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ntc!(rng, collision_factors, collision_data, interaction,
     particles_1, particles_2, pia,
     cell, species1, species2, Δt, V)</code></pre><p>Perform elastic collisions between particles of different species using the NTC algorithm and the VHS cross-section model.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_factors</code>: the <code>CollisionFactors</code> for the species in question in the cell</li><li><code>collision_data</code>: <code>CollisionData</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>particles_1</code>: <code>ParticleVector</code> of the particles of the first species being collided</li><li><code>particles_2</code>: <code>ParticleVector</code> of the particles of the second species being collided</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species1</code>: the index of the first species for which collisions are performed</li><li><code>species1</code>: the index of the second species for which collisions are performed</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ntc_n_e!" href="#Merzbild.ntc_n_e!"><code>Merzbild.ntc_n_e!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ntc_n_e!(rng, collision_factors, collision_data, interaction,
         n_e_interactions, n_e_cs, particles_n, particles_e, particles_ion,
         pia, cell, species_n, species_e, species_ion, Δt, V)</code></pre><p>Perform electron-neutral elastic scattering and electron-impact ionization collisions.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_factors</code>: the <code>CollisionFactors</code> for the species in question in the cell</li><li><code>collision_data</code>: <code>CollisionData</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>n_e_interactions</code>: the <code>ElectronNeutralInteractions</code> instance</li><li><code>n_e_cs</code>: the <code>ComputedCrossSections</code> instance</li><li><code>particles_n</code>: <code>ParticleVector</code> of the particles of neutral species</li><li><code>particles_e</code>: <code>ParticleVector</code> of the particles of the electron species</li><li><code>particles_ion</code>: <code>ParticleVector</code> of the particles of the ion species</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species_n</code>: the index of the neutral species</li><li><code>species_e</code>: the index of the electron species</li><li><code>species_ion</code>: the index of the ion species</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ntc_n_e_es!" href="#Merzbild.ntc_n_e_es!"><code>Merzbild.ntc_n_e_es!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ntc_n_e_es!(rng, collision_factors, collision_data, interaction,
         n_e_interactions, n_e_cs, particles_n, particles_e, particles_ion,
         pia, cell, species_n, species_e, species_ion, Δt, V)</code></pre><p>Perform electron-neutral elastic scattering and electron-impact ionization collisions using the event splitting approach of <a href="https://doi.org/10.1016/j.jcp.2022.111390">Oblapenko et al. (2022)</a></p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_factors</code>: the <code>CollisionFactors</code> for the species in question in the cell</li><li><code>collision_data</code>: <code>CollisionData</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>n_e_interactions</code>: the <code>ElectronNeutralInteractions</code> instance</li><li><code>n_e_cs</code>: the <code>ComputedCrossSections</code> instance</li><li><code>particles_n</code>: <code>ParticleVector</code> of the particles of neutral species</li><li><code>particles_e</code>: <code>ParticleVector</code> of the particles of the electron species</li><li><code>particles_ion</code>: <code>ParticleVector</code> of the particles of the ion species</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species_n</code>: the index of the neutral species</li><li><code>species_e</code>: the index of the electron species</li><li><code>species_ion</code>: the index of the ion species</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul></div></section></article><h2 id="Fokker-Planck-computations"><a class="docs-heading-anchor" href="#Fokker-Planck-computations">Fokker-Planck computations</a><a id="Fokker-Planck-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Fokker-Planck-computations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.fp_linear!" href="#Merzbild.fp_linear!"><code>Merzbild.fp_linear!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fp_linear!(rng, collision_data_fp, interaction, species_data, particles, pia, cell, species, Δt, V)</code></pre><p>Model single-species elastic collisions using a linear Fokker-Planck approximation.</p><p>Positional arguments</p><ul><li><code>rng</code>: the random number generator</li><li><code>collision_data_fp</code>: <code>CollisionDataFP</code> instance used for storing collisional quantities</li><li><code>interaction</code>: 2-dimensional array of <code>Interaction</code> instances for all possible species pairs</li><li><code>species_data</code>: the vector of <code>SpeciesData</code></li><li><code>particles</code>: <code>ParticleVector</code> of the particles being collided</li><li><code>pia</code>: the <code>ParticleIndexerArray</code></li><li><code>cell</code>: the index of the cell in which collisions are performed</li><li><code>species</code>: the index of the species for which collisions are performed</li><li><code>Δt</code>: timestep</li><li><code>V</code>: cell volume</li></ul></div></section></article><h2 id="Electron-neutral-interactions"><a class="docs-heading-anchor" href="#Electron-neutral-interactions">Electron-neutral interactions</a><a id="Electron-neutral-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-neutral-interactions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ElectronNeutralInteractions" href="#Merzbild.ElectronNeutralInteractions"><code>Merzbild.ElectronNeutralInteractions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ElectronNeutralInteractions</code></pre><p>Structure to hold data on electron-neutral interactions. The <code>neutral_indexer</code> field is used to obtain the index of the species inside the structure, given an index of the neutral species in the full list of species in the simulation. For example, if we have a following list of species in the simulation: <code>[e-, He, Ar+, He+, Ar]</code>, <code>n_neutrals=2</code>, the <code>ElectronNeutralInteractions</code> instance stores data for interactions of electrons with <code>[He, Ar]</code>, and <code>neutral_indexer[2] = 1</code>, <code>neutral_indexer[5] = 2</code>.</p><p><strong>Fields</strong></p><ul><li><code>n_neutrals</code>: number of neutral species for which the data has been loaded</li><li><code>neutral_indexer</code>: array that maps indices of neutral species   in the full list of species to local indices in the <code>ElectronNeutralInteractions</code> structure</li><li><code>elastic</code>: an array of <code>ElasticScattering</code> instances (of length <code>n_neutrals</code>) holding the cross-section data on elastic scattering   for each neutral species</li><li><code>ionization</code>: an array of <code>Ionization</code> instances (of length <code>n_neutrals</code>) holding the cross-section data on electron-impact ionization   for each neutral species</li><li><code>excitation_sink</code>: an array of <code>ExcitationSink</code> instances (of length <code>n_neutrals</code>)   holding the cross-section data on electron-impact electronic excitation for each neutral species</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ComputedCrossSections" href="#Merzbild.ComputedCrossSections"><code>Merzbild.ComputedCrossSections</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComputedCrossSections</code></pre><p>Structure to hold data on computed cross-sections of electron-neutral interactions for a specific neutral species.</p><p><strong>Fields</strong></p><ul><li><code>n_excitations</code>: number of electron-impact excitation reactions</li><li><code>cs_total</code>: the computed total cross-section (sum of cross-sections of all processes)</li><li><code>cs_elastic</code>: the computed elastic scattering cross-section</li><li><code>cs_ionization</code>: the computed electron-impact ionization cross-section</li><li><code>cs_excitation</code>: the computed electron-impact electronic excitation cross-section</li><li><code>prob_vec</code>: a vector of probabilities of the processes (of length <code>2+n_excitations</code>). <code>prob_vec[1]</code> is the probability of elastic scattering,   <code>prob_vec[2]</code> is the probability of electron-impact ionization, <code>prob_vec[3:2+n_excitations]</code> are the probabilities   of th </li><li><code>cdf_prob_vec</code>: a vector of cumulative probabilities of the processes (of length <code>3+n_excitations</code>), used for sampling a specific process:   <code>cfd_prob_vec[1] = 0.0</code>, <code>cfd_prob_vec[n] = cfd_prob_vec[n-1] + prob_vec[n-1], n&gt;1</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ElectronEnergySplit" href="#Merzbild.ElectronEnergySplit"><code>Merzbild.ElectronEnergySplit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ElectronEnergySplit ElectronEnergySplitEqual=1 ElectronEnergySplitZeroE=2</code></pre><p>Enum for various splittings of electron energy in electron-impact ionization reactions. <code>ElectronEnergySplitEqual</code> corresponds to energy being shared equally amongst the electrons, <code>ElectronEnergySplitZeroE</code> corresponds to the one-takes-all sharing model.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ScatteringLaw" href="#Merzbild.ScatteringLaw"><code>Merzbild.ScatteringLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScatteringLaw ScatteringIsotropic=1 ScatteringOkhrimovskyy=2</code></pre><p>Enum for various scattering laws in electron-neutral interactions. <code>ScatteringIsotropic</code> corresponds to isotropic scattering, <code>ScatteringOkhrimovskyy</code> to the scattering model of <a href="https://doi.org/10.1103/PhysRevE.65.037402">A. Okhrimovskyy et al., 2002</a>.</p></div></section></article><h2 id="Merging"><a class="docs-heading-anchor" href="#Merging">Merging</a><a id="Merging-1"></a><a class="docs-heading-anchor-permalink" href="#Merging" title="Permalink"></a></h2><h3 id="Grid-merging"><a class="docs-heading-anchor" href="#Grid-merging">Grid merging</a><a id="Grid-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-merging" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge" href="#Merzbild.GridN2Merge"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge</code></pre><p>Struct for merging using a grid in velocity space. Particles in each cell are merged down. Particles outside of the grid are merged based on the octant they are in. So for an N:2 merge one would expect at most <code>2*(Nx*Ny*Nz+8)</code> post-merge particles, where <code>Nx</code>, <code>Ny</code>, <code>Nz</code> are the number of grid cells in each velocity direction. The grid bounds in each direction can be computed using the mean thermal velocity of the particles and the mean streaming velocity: <code>[v0-extent_multiplier*sqrt(2*k_B*T/m),v0+extent_multiplier*sqrt(2*k_B*T/m)]</code>. Here <code>T</code> is the temperature of the species in question, <code>m</code> is the molecular mass, <code>v0</code> is the mean velocity and <code>extent_multiplier</code> is a user-defined parameter (3.5 is a reasonable choice) defining the extent of the grid.</p><p><strong>Fields</strong></p><ul><li><code>Nx</code>: number of grid cells in x velocity direction</li><li><code>Ny</code>: number of grid cells in y velocity direction</li><li><code>Nz</code>: number of grid cells in z velocity direction</li><li><code>NyNz</code>: product of <code>Ny</code> and <code>Nz</code></li><li><code>Ntotal</code>: total number of grid cells (equal to <code>Nx*Ny*Nz+8</code>, as we account for the external octants)</li><li><code>extent_multiplier</code>: the vector of factors by which to multiply the thermal velocity to determine the grid bounds   in each velocity direction</li><li><code>extent_v_lower</code>: the lower bounds of the velocity grid in each velocity direction</li><li><code>extent_v_upper</code>: the upper bounds of the velocity grid in each velocity direction</li><li><code>extent_v_mid</code>: <code>(extent_v_lower + extent_v_upper)/2</code></li><li><code>Δv</code>: the grid cell size in each velocity direction</li><li><code>Δv_inv</code>: the inverse grid cell size in each velocity direction</li><li><code>direction_vec</code>: used to store randomly sampled direction signs</li><li><code>cells</code>: vector of <code>GridCell</code> instances for each grid cell, as well as the external octants</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, Int64, Int64, T}} where T&lt;:AbstractArray" href="#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, Int64, Int64, T}} where T&lt;:AbstractArray"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::T) where T &lt;: AbstractArray</code></pre><p>Create velocity grid-based merging.</p><p><strong>Positional arguments</strong></p><ul><li><code>Nx</code>: number of cells in vx direction</li><li><code>Ny</code>: number of cells in vy direction</li><li><code>Nz</code>: number of cells in vz direction</li><li><code>extent_multiplier</code>: the vector of factors by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in each velocity direction</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:AbstractArray" href="#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:AbstractArray"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge(N::Int, extent_multiplier::T) where T &lt;: AbstractArray</code></pre><p>Create velocity grid-based merging with equal number of cells in each direction.</p><p><strong>Positional arguments</strong></p><ul><li><code>N</code>: number of cells in each velocity direction</li><li><code>extent_multiplier</code>: the vector of factors by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in each velocity direction</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64}" href="#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64}"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::Float64)</code></pre><p>Create velocity grid-based merging with equal multipliers in each direction.</p><p><strong>Positional arguments</strong></p><ul><li><code>Nx</code>: number of cells in vx direction</li><li><code>Ny</code>: number of cells in vy direction</li><li><code>Nz</code>: number of cells in vz direction</li><li><code>extent_multiplier</code>: the factor by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in each velocity direction</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64, Float64, Float64}" href="#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64, Float64, Float64}"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge(Nx::Int, Ny::Int, Nz::Int,
            extent_multiplier_x::Float64,
            extent_multiplier_y::Float64,
            extent_multiplier_z::Float64)</code></pre><p>Create velocity grid-based merging</p><ul><li><code>Nx</code>: number of cells in vx direction</li><li><code>Ny</code>: number of cells in vy direction</li><li><code>Nz</code>: number of cells in vz direction</li><li><code>extent_multiplier_x</code>: the factor by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in the x-velocity direction</p><ul><li><code>extent_multiplier_y</code>: the factor by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in the y-velocity direction</p><ul><li><code>extent_multiplier_z</code>: the factor by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in the z-velocity direction</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridN2Merge-Tuple{Int64, Float64}" href="#Merzbild.GridN2Merge-Tuple{Int64, Float64}"><code>Merzbild.GridN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridN2Merge(N::Int, extent_multiplier::Float64)</code></pre><p>Create velocity grid-based merging with equal number of cells in each direction and equal multipliers in each direction.</p><p><strong>Positional arguments</strong></p><ul><li><code>N</code>: number of cells in each velocity direction</li><li><code>extent_multiplier</code>: the factor by which to multiply the thermal velocity to determine the grid bounds</li></ul><p>in each velocity direction</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.merge_grid_based!" href="#Merzbild.merge_grid_based!"><code>Merzbild.merge_grid_based!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_grid_based!(rng, merging_grid, particles, pia, cell, species, species_data, phys_props)</code></pre><p>Merge particles using a velocity grid-based merging approach. A Cartesian grid in velocity space is used to group particles together (particles outside of the grid are group by velocity octant), and in each cell/octant, particles are merged down to 2 particles. The extent of the grid is based on the temperature for the species in question in the physical grid cell being considered, as stored in the <code>phys_props</code> parameter.</p><p><strong>Positional arguments:</strong></p><ul><li><code>rng</code>: the random number generator instance</li><li><code>merging_grid</code>: the grid merging (<code>GridN2Merge</code>) instance defining the velocity space grid</li><li><code>particles</code>: the <code>ParticleVector</code> instance of the particles to be merged</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>cell</code>: the cell index</li><li><code>species</code>: the species index</li><li><code>species_data</code>: the array of <code>Species</code> data</li><li><code>phys_props</code>: the <code>PhysProps</code> instance containing the computed temperature</li></ul></div></section></article><h3 id="NNLS-merging"><a class="docs-heading-anchor" href="#NNLS-merging">NNLS merging</a><a id="NNLS-merging-1"></a><a class="docs-heading-anchor-permalink" href="#NNLS-merging" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NNLSMerge" href="#Merzbild.NNLSMerge"><code>Merzbild.NNLSMerge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NNLSMerge</code></pre><p>Struct for keeping track of merging-related quantities for NNLS-based merging.</p><p><strong>Fields</strong></p><ul><li><code>v0</code>: vector of the mean velocity of the particles</li><li><code>vref</code>: reference velocity magnitude for scaling</li><li><code>inv_vref</code>: inverse of reference velocity magnitude for scaling</li><li><code>Ex</code>: standard deviation of x velocity of particles</li><li><code>Ey</code>: standard deviation of y velocity of particles</li><li><code>Ez</code>: standard deviation of z velocity of particles</li><li><code>w_total</code>: total computational of the particles</li><li><code>minvx</code>: minimum x velocity of the particles</li><li><code>maxvx</code>: maximum x velocity of the particles</li><li><code>minvy</code>: minimum y velocity of the particles</li><li><code>maxvy</code>: maximum y velocity of the particles</li><li><code>minvz</code>: minimum z velocity of the particles</li><li><code>maxvz</code>: maximum z velocity of the particles</li><li><code>n_moments</code>: number of velocity moments to preserve</li><li><code>rhs_vector</code>: vector of computed moments</li><li><code>residual</code>: residual of solution</li><li><code>mim</code>: vector of 3-tuples of multi-indices for the velocity moments to preserve</li><li><code>tot_order</code>: vector of total orders of the velocity moments to preserve</li><li><code>work</code>: <code>NNLSWorkspace</code> instance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NNLSMerge-Tuple{Any, Any}" href="#Merzbild.NNLSMerge-Tuple{Any, Any}"><code>Merzbild.NNLSMerge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NNLSMerge(multi_index_moments, init_np; rate_preserving=false)</code></pre><p>Create NNLS-based merging. Mass, momentum, directional energy are always conserved: if not in the list <code>multi_index_moments</code> of moments to preserve, the corresponding moment multi-indices will be added automatically. These indices are <code>(0,0,0)</code> for mass, <code>(1,0,0)</code>, <code>(0,1,0)</code>, <code>(0,0,1)</code> for momentum, and <code>(2,0,0)</code>, <code>(0,2,0)</code>, <code>(0,0,2)</code> for directional energies.</p><p><strong>Positional arguments</strong></p><ul><li><code>multi_index_moments</code>: vector of mixed moments to preserve of the form <code>[(i1, j1, k1), (i2, j2, k2), ...]</code>`</li><li><code>init_np</code>: assumption on pre-merge number of particles to pre-allocate memory for</li></ul><p>Keyword arguments:</p><ul><li><code>rate_preserving</code>: used for rate-preserving merging of electrons, preserves approximate elastic collision and ionization rates</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.compute_multi_index_moments" href="#Merzbild.compute_multi_index_moments"><code>Merzbild.compute_multi_index_moments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_multi_index_moments(n)</code></pre><p>Compute all mixed moment multi-indices of total order up to n, i.e. all 3-tuples <code>(i,j,k)</code><code>such that</code>i+j+k &lt;= n`.</p><p><strong>Positional arguments</strong></p><ul><li><code>n</code>: maximum total order</li></ul><p><strong>Returns</strong></p><p>Vector of 3-tuples of moment multi-indices.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.merge_nnls_based!" href="#Merzbild.merge_nnls_based!"><code>Merzbild.merge_nnls_based!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_nnls_based!(rng, nnls_merging, particles, pia, cell, species, vref; n_rand_pairs=0, max_err=1e-11,
                  centered_at_mean=true, v_multipliers=[0.5, 1.0], iteration_mult=2)</code></pre><p>Perform NNLS-based merging. The NNLS system is scaled to improve numerical stability, the scaling algorithm is set by the <code>scaling</code> parameter. Even if scaling is done using the computed variances, <code>vref</code> might be used in case those variances are small.</p><p>To improve stability, additional fictitious particles can be created by randomly choosing particle pairs and creating new particles with a velocity and position that is a mean of the velocity and position of the randomly chosen pair; these particles are added as additional columns to the matrix. An additional fictitious particle can be created at the local mean velocity via the <code>centered_at_mean</code> parameter. Additionally, particles can be created with velocities that are a multiple of the computed velocity variance of the system of pre-merge particles in each direction. For a given variance multiplier (an entry in the <code>v_multipliers</code> parameter, which is a vector of multipliers), 8 particles are added, one in each octant. Each of the particles velocity components is given either by the value of the multiplier times the velocity variance of that component (times +1 or -1 depending on the octant), or, if this value is outside of the bounding box, the closest bounding value of the velocity component in that direction is used instead and also multiplied by the variance multiplier.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator instance</li><li><code>nnls_merging</code>: the <code>NNLSMerge</code> instance</li><li><code>particles</code>: the <code>ParticleVector</code> instance containing the particles to be merged</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>cell</code>: the index of the grid cell in which particles are being merged</li><li><code>species</code>: the index of the species being merged</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>vref</code>: the reference velocity used to scale the velocities</li><li><code>scaling</code>: how to scale entries in the LHS and RHS of the NNLS system - either based on   the reference velocity <code>vref</code> (<code>scaling=:vref</code>)   or on the computed variances in each direction (<code>scaling=:variance</code>)</li><li><code>n_rand_pairs</code>: the number of additional random pairs to sample to create additional entries in the matrix   to potentially improve the stability of the algorithm</li><li><code>max_err</code>: maximum allowed value of the residual of the NNLS system</li><li><code>centered_at_mean</code>: whether to add a particle centered at the mean velocity of the system of particles</li><li><code>v_multipliers</code>: the multipliers for the velocity variances of the particles to add aditional particles to the system</li><li><code>iteration_mult</code>: the number by which the number of columns of the NNLS system matrix is multiplied, this gives the maximum   number of iterations of the NNLS algorithm</li></ul><p><strong>Returns</strong></p><p>If the residual exceeds <code>max_err</code> or the number of non-zero elements in the solution vector is equal to the original number of particles, <code>-1</code> is returned to signify a failure of the merging algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.merge_nnls_based_rate_preserving!" href="#Merzbild.merge_nnls_based_rate_preserving!"><code>Merzbild.merge_nnls_based_rate_preserving!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_nnls_based_rate_preserving!(rng, nnls_merging,
                                       interaction, electron_neutral_interactions, computed_cs,
                                       particles, pia, cell, species, neutral_species_index,
                                       ref_cs_elatic, ref_cs_ion; scaling=:variance,
                                       vref=1.0, n_rand_pairs=0, max_err=1e-11,
                                       centered_at_mean=true, v_multipliers=[0.5, 1.0], iteration_mult=2)</code></pre><p>Perform NNLS-based merging of electrons that conserves approximate elastic scattering and electron-impact ionization rates. The NNLS system is scaled to improve numerical stability, the scaling algorithm is set by the <code>scaling</code> parameter. Even if scaling is done using the computed variances, <code>vref</code> might be used in case those variances are small.</p><p>To improve stability, additional fictitious particles can be created by randomly choosing particle pairs and creating new particles with a velocity and position that is a mean of the velocity and position of the randomly chosen pair; these particles are added as additional columns to the matrix. An additional fictitious particle can be created at the local mean velocity via the <code>centered_at_mean</code> parameter. Additionally, particles can be created with velocities that are a multiple of the computed velocity variance of the system of pre-merge particles in each direction. For a given variance multiplier (an entry in the <code>v_multipliers</code> parameter, which is a vector of multipliers), 8 particles are added, one in each octant. Each of the particles velocity components is given either by the value of the multiplier times the velocity variance of that component (times +1 or -1 depending on the octant), or, if this value is outside of the bounding box, the closest bounding value of the velocity component in that direction is used instead and also multiplied by the variance multiplier. The reference velocity is also used in conjunction with the reference cross-sections to scale the parts of the NNLS matrix and RHS corresponding to conservation of electron-neutral collision rates.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator instance</li><li><code>nnls_merging</code>: the <code>NNLSMerge</code> instance</li><li><code>interaction</code>: the <code>Interaction</code> instance describing the electron-neutral interaction being considered</li><li><code>electron_neutral_interactions</code>:  the <code>ElectronNeutralInteractions</code> instance storing the tabulated cross-section   data used to compute the rates</li><li><code>computed_cs</code>: the vector of <code>ComputedCrossSection</code> instances in which the computed values will be stored</li><li><code>particles</code>: the <code>ParticleVector</code> instance containing the particles to be merged</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>cell</code>: the index of the grid cell in which particles are being merged</li><li><code>species</code>: the index of the species being merged</li><li><code>neutral_species_index</code>: the index of the neutral species which is the collision partner in the electron-neutral   collisions for which approximate rates are being preserved.</li><li><code>ref_cs_elatic</code>: the reference elastic scattering cross-section used to scale the rates</li><li><code>ref_cs_ion</code>: the reference electron-impact ionization cross-section used to scale the rates</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>vref</code>: the reference velocity used to scale the velocities and the electron-neutral collision rates</li><li><code>scaling</code>: how to scale entries in the LHS and RHS of the NNLS system - either based on   the reference velocity <code>vref</code> (<code>scaling=:vref</code>)   or on the computed variances in each direction (<code>scaling=:variance</code>)</li><li><code>n_rand_pairs</code>: the number of additional random pairs to sample to create additional entries in the matrix   to potentially improve the stability of the algorithm</li><li><code>max_err</code>: maximum allowed value of the residual of the NNLS system</li><li><code>centered_at_mean</code>: whether to add a particle centered at the mean velocity of the system of particles</li><li><code>v_multipliers</code>: the multipliers for the velocity variances of the particles to add aditional particles to the system</li><li><code>iteration_mult</code>: the number by which the number of columns of the NNLS system matrix is multiplied, this gives the maximum   number of iterations of the NNLS algorithm</li></ul><p><strong>Returns</strong></p><p>If the residual exceeds <code>max_err</code> or the number of non-zero elements in the solution vector is equal to the original number of particles, <code>-1</code> is returned to signify a failure of the merging algorithm.</p></div></section></article><h3 id="Octree-merging"><a class="docs-heading-anchor" href="#Octree-merging">Octree merging</a><a id="Octree-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Octree-merging" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.OctreeBinSplit" href="#Merzbild.OctreeBinSplit"><code>Merzbild.OctreeBinSplit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OctreeBinSplit OctreeBinMidSplit=1 OctreeBinMeanSplit=2 OctreeBinMedianSplit=3</code></pre><p>Enum defining how the velocity along which the bin is split is chosen.</p><p><strong>Possible values:</strong></p><ul><li><code>OctreeBinMidSplit</code>: the bin is split along the middle velocity</li><li><code>OctreeBinMeanSplit</code>: the bin is split along the mean velocity of the particles in the bin</li><li><code>OctreeBinMedianSplit</code>: the bin is split along the median velocity of the particles in the bin</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.OctreeInitBin" href="#Merzbild.OctreeInitBin"><code>Merzbild.OctreeInitBin</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OctreeInitBin OctreeInitBinMinMaxVel=1 OctreeInitBinMinMaxVelSym=2 OctreeInitBinC=3</code></pre><p>Enum defining how the bounds of the initial bin are computed.</p><p><strong>Possible values:</strong></p><ul><li><code>OctreeInitBinMinMaxVel</code>: the minimum and maximum velocities of the particles being merged are used to compute the bounds</li><li><code>OctreeInitBinMinMaxVelSym</code>: the minimum and maximum velocities of the particles being merged are used to compute the bounds,   but the bounds are then symmetrized in each velocity direction: <code>[-max(abs(min_v), abs(max_v)), max(abs(min_v), abs(max_v))]</code></li><li><code>OctreeInitBinC</code>: the initial bounds are set to <code>[-c, c]</code><code>in each direction, where</code>c`` speed of light </li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.OctreeBinBounds" href="#Merzbild.OctreeBinBounds"><code>Merzbild.OctreeBinBounds</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OctreeBinBounds OctreeBinBoundsInherit=1 OctreeBinBoundsRecompute=2</code></pre><p>Enum defining how the bounds of a split sub-octant bin are computed.</p><p><strong>Possible values:</strong></p><ul><li><code>OctreeBinBoundsInherit</code>: the splitting velocity and the appropriate bounds of the parent bin are inherited</li><li><code>OctreeBinBoundsRecompute</code>: the bounds are recomputed based on the particles in the bin</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.OctreeN2Merge" href="#Merzbild.OctreeN2Merge"><code>Merzbild.OctreeN2Merge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OctreeN2Merge</code></pre><p>Struct for N:2 Octree merging.</p><p><strong>Fields</strong></p><ul><li><code>max_Nbins</code>: maximum possible number of bins</li><li><code>Nbins</code>: number of bins currently used</li><li><code>bins</code>: Vector of <code>OctreeCell</code> instances used to compute the properties required for bin refinement</li><li><code>full_bins</code>: Vector of <code>OctreeFullCell</code> instances used to compute the post-merge particles in each bin</li><li><code>n_particles</code>: total number of particles being merged</li><li><code>bin_start</code>: denotes start of indices of particles in bin <code>i</code> in the <code>particle_indexes_sorted</code> array</li><li><code>bin_end</code>: denotes end of indices of particles in bin <code>i</code> in the <code>particle_indexes_sorted</code> array</li><li><code>particle_indexes_sorted</code>: Vector of particle indices of the particles being merged</li><li><code>particle_octants</code>: Vector of particle octants for each particle used during radix sort</li><li><code>particles_sort_output</code>: Vector of integer indices used to store particle indices during radix sort</li><li><code>particle_in_bin_counter</code>: <code>MVector</code> of size 8, stores the number of particles in each bin</li><li><code>nonempty_counter</code>: <code>MVector</code> of size 8, stores the number of particles in each non-empty bin   (the octants to which these bins correspond to are in <code>nonempty_bins</code>)</li><li><code>nonempty_bins</code>: <code>MVector</code> of size 8, a sequential list of non-empty octants</li><li><code>ndens_counter</code>: <code>MVector</code> of size 8, used in bin splitting, stores number density in each (non-empty) bin</li><li><code>bin_bounds_compute</code>: enum of <code>OctreeBinBounds</code> type defining whether bin bounds are fully defined   by the parent bin and splitting velocity (<code>vel_middle</code>), or whether they are recomputed for each new sub-octant bin</li><li><code>split</code>: enum of <code>OctreeBinSplit</code> type defining how bins are split</li><li><code>vel_middle</code>: used to store the velocity along which a bin is split into octants</li><li><code>v_min_parent</code>: used in bin splitting to store the vector of the per-component lower bounds of the velocities in the cell</li><li><code>v_max_parent</code>: used in bin splitting to store the vector of the per-component upper bounds of the velocities in the cell</li><li><code>direction_vec</code>: used to store randomly sampled direction signs</li><li><code>init_bin_bounds</code>: enum of <code>OctreeInitBin</code> type defining how the bounds of the top-level bin are set</li><li><code>max_depth</code>: maximum allowed depth of a bin</li><li><code>total_post_merge_np</code>: used to keep track of number of post-merge particles</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.OctreeN2Merge-Tuple{Merzbild.OctreeBinSplit}" href="#Merzbild.OctreeN2Merge-Tuple{Merzbild.OctreeBinSplit}"><code>Merzbild.OctreeN2Merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OctreeN2Merge(split::OctreeBinSplit; init_bin_bounds=OctreeInitBinMinMaxVel, bin_bounds_compute=OctreeBinBoundsInherit,
          max_Nbins=4096, max_depth=10)</code></pre><p>Create an Octree N:2 merging instance.</p><p>Positional arguments:</p><ul><li><code>split</code>: a enum of <code>OctreeBinSplit</code> type which tells how to split a bin into sub-bins</li></ul><p>Keyword arguments:</p><ul><li><code>init_bin_bounds</code>: a enum of <code>OctreeInitBin</code> type which defines how the bounds of the top-level bin are set</li><li><code>bin_bounds_compute</code>: a enum of <code>OctreeBinBounds</code> type which defines whether the bounds of sub-bins are recomputed   based on the minimum/maximum velocities of the particles in those sub-bins, or the bounds are inherited from the   bin that was split</li><li><code>max_Nbins</code>: maximum number of bins allowed (this only counts leaf-level bins)</li><li><code>max_depth</code>: maximum depth of a sub-bin starting from the top-level bin containing all particles (which has a depth of 0)</li></ul><p>Returns: <code>OctreeN2Merge</code> instance with everything set to 0.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.merge_octree_N2_based!" href="#Merzbild.merge_octree_N2_based!"><code>Merzbild.merge_octree_N2_based!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_octree_N2_based!(rng, octree, particles, pia, cell, species, target_np)</code></pre><p>Perform N:2 merging without checking whether particle positions end up outside of the simulation domain.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator instance</li><li><code>octree</code>: the <code>OctreeN2Merge</code> instance</li><li><code>particles</code>: the <code>ParticleVector</code> instance containing the particles to be merged</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>cell</code>: the index of the grid cell in which particles are being merged</li><li><code>species</code>: the index of the species being merged</li><li><code>target_np</code>: the target post-merge number of particles; the post-merge number of particles will not exceed this value   but may be not exactly equal to it</li></ul></div></section><section><div><pre><code class="language-julia hljs">merge_octree_N2_based!(rng, octree, particles, pia, cell, species, target_np, grid)</code></pre><p>Perform N:2 merging, checking whether particle positions end up outside of the simulation domain, and pushing them back into the domain if needed.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator instance</li><li><code>octree</code>: the <code>OctreeN2Merge</code> instance</li><li><code>particles</code>: the <code>ParticleVector</code> instance containing the particles to be merged</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>cell</code>: the index of the grid cell in which particles are being merged</li><li><code>species</code>: the index of the species being merged</li><li><code>target_np</code>: the target post-merge number of particles; the post-merge number of particles will not exceed this value   but may be not exactly equal to it</li><li><code>grid</code>: the <code>Grid1DUniform</code> grid</li></ul></div></section></article><h2 id="Grids-and-particle-sorting"><a class="docs-heading-anchor" href="#Grids-and-particle-sorting">Grids and particle sorting</a><a id="Grids-and-particle-sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Grids-and-particle-sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.AbstractGrid" href="#Merzbild.AbstractGrid"><code>Merzbild.AbstractGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGrid</code></pre><p>Abstract grid type</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.Grid1DUniform" href="#Merzbild.Grid1DUniform"><code>Merzbild.Grid1DUniform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Grid1DUniform</code></pre><p>1-D Uniform grid for a domain <span>$[0,L]$</span></p><p><strong>Fields</strong></p><ul><li><code>L</code>: length of the domain</li><li><code>nx</code>: number of cells</li><li><code>Δx</code>: cell size</li><li><code>inv_Δx</code>: inverse of cell size</li><li><code>cells</code>: <code>Vector</code> of <code>Cell1D</code> elements</li><li><code>min_x</code>: minimum allowed <code>x</code> coordinate for particles (slightly larger than <span>$0$</span>)</li><li><code>max_x</code>: maximum allowed <code>x</code> coordinate for particles (slightly smaller than <span>$L$</span>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.Grid1DUniform-Tuple{Any, Any}" href="#Merzbild.Grid1DUniform-Tuple{Any, Any}"><code>Merzbild.Grid1DUniform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Grid1DUniform(L, nx; wall_offset=1e-12)</code></pre><p>Create 1-D uniform grid for a domain <span>$[0, L]$</span> with <code>nx</code> cells</p><p><strong>Positional arguments</strong></p><ul><li><code>L</code>: length of the domain</li><li><code>nx</code>: number of cells</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>wall_offset</code>: specifies a small relative offset from the walls so that particles   never end up with a coordinate of exactly <span>$0$</span> or <span>$L$</span>, otherwise some   sorting routines may produce cell indices outside of the <code>1:nx</code> range.   The offset is computed as <code>Δx * wall_offset</code>, where <code>Δx</code> is the cell size.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridSortInPlace" href="#Merzbild.GridSortInPlace"><code>Merzbild.GridSortInPlace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridSortInPlace</code></pre><p>Struct for in-place sorting of particles.</p><p><strong>Fields</strong></p><ul><li><code>cell_counts</code>: vector to store the number of particles in each cell + number of particles in all previous cells</li><li><code>sorted_indices</code>: vector to store sorted particle indices</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridSortInPlace-Tuple{Integer, Integer}" href="#Merzbild.GridSortInPlace-Tuple{Integer, Integer}"><code>Merzbild.GridSortInPlace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridSortInPlace(n_cells::Integer, n_particles::Integer)</code></pre><p>Create a <code>GridSortInPlace</code> instance given a number of grid cells and number of particles.</p><p><strong>Positional arguments</strong></p><ul><li><code>n_cells</code>: the number of grid cells</li><li><code>n_particles</code>: the (expected) number of particles in the simulation   (to pre-allocate the <code>sorted_indices</code> vector) - it is recommended   to set this to the maximum expected number of particles in the simulation to avoid resizing of arrays   during a simulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.GridSortInPlace-Union{Tuple{G}, Tuple{G, Integer}} where G&lt;:AbstractGrid" href="#Merzbild.GridSortInPlace-Union{Tuple{G}, Tuple{G, Integer}} where G&lt;:AbstractGrid"><code>Merzbild.GridSortInPlace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridSortInPlace(grid::G, n_particles::Integer) where {G&lt;:AbstractGrid}</code></pre><p>Create a <code>GridSortInPlace</code> instance given a grid and number of particles.</p><p><strong>Positional arguments</strong></p><ul><li><code>grid</code>: the grid on which to sort the particles</li><li><code>n_particles</code>: the (expected) number of particles in the simulation   (to pre-allocate the <code>sorted_indices</code> vector) - it is recommended   to set this to the maximum expected number of particles in the simulation to avoid resizing of arrays   during a simulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.sort_particles!" href="#Merzbild.sort_particles!"><code>Merzbild.sort_particles!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_particles!(gridsort::GridSortInPlace, grid, particles, pia, species)</code></pre><p>Sort particles on a grid using an in-place sorting algorithm. The <code>pia</code> instance is allowed to have non-contiguous indices (arising for example from merging).</p><p><strong>Positional arguments</strong></p><ul><li><code>gridsort</code>: the <code>GridSortInPlace</code> structure</li><li><code>grid</code>: the grid (should have an <code>n_cells</code> field, and a <code>get_cell</code> function has to be defined for the grid type)</li><li><code>particles</code>: the <code>ParticleVector</code> of particles to be sorted</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species being sorted</li></ul></div></section></article><h2 id="Particle-movement"><a class="docs-heading-anchor" href="#Particle-movement">Particle movement</a><a id="Particle-movement-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-movement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.convect_particles!" href="#Merzbild.convect_particles!"><code>Merzbild.convect_particles!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convect_particles!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, particles, pia, species, species_data, Δt)</code></pre><p>Convect particles on a 1-D uniform grid.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid</code>: the grid on which the convection is performed</li><li><code>boundaries</code>: the <code>MaxwellWalls1D</code> struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)</li><li><code>particles</code>: the <code>ParticleVector</code> of particles to be convected</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species being convected</li><li><code>species_data</code>: the vector of <code>Species</code> data</li><li><code>Δt</code>: the convection timestep</li></ul></div></section><section><div><pre><code class="language-julia hljs">convect_particles!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, surf_props::SurfProps, particles, pia, species, species_data, Δt)</code></pre><p>Convect particles on a 1-D uniform grid, computing surface properties if particles hit a surface.</p><p><strong>Positional arguments</strong></p><ul><li><code>rng</code>: the random number generator</li><li><code>grid</code>: the grid on which the convection is performed</li><li><code>boundaries</code>: the <code>MaxwellWalls1D</code> struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)</li><li><code>particles</code>: the <code>ParticleVector</code> of particles to be convected</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instance</li><li><code>species</code>: the index of the species being convected</li><li><code>species_data</code>: the vector of <code>Species</code> data</li><li><code>surf_props</code>: the <code>SurfProps</code> struct where the computed surface properties will be stored</li><li><code>Δt</code>: the convection timestep</li></ul></div></section></article><h2 id="Particle-surface-interactions"><a class="docs-heading-anchor" href="#Particle-surface-interactions">Particle-surface interactions</a><a id="Particle-surface-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-surface-interactions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.MaxwellWallBC" href="#Merzbild.MaxwellWallBC"><code>Merzbild.MaxwellWallBC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaxwellWallBC</code></pre><p>A struct to hold information about a diffuse reflecting wall.</p><p><strong>Fields</strong></p><ul><li><code>T</code>: temperature</li><li><code>v</code>: wall velocity vector</li><li><code>accommodation</code>: accommodation coefficient (a value of 0 corresponds to specular reflection,   a value of 1 corresponds to purely diffuse reflection)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.MaxwellWalls1D" href="#Merzbild.MaxwellWalls1D"><code>Merzbild.MaxwellWalls1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaxwellWalls1D</code></pre><p>A struct to hold information about all diffuse reflecting walls in the simulation.</p><p><strong>Fields</strong></p><ul><li><code>boundaries</code>: a vector of <code>MaxwellWallBC</code> walls</li><li><code>reflection_velocities_sq</code>: array of pre-computed squared thermal reflection velocities (n<em>walls x n</em>species)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.MaxwellWalls1D-Tuple{Any, Vararg{Float64, 6}}" href="#Merzbild.MaxwellWalls1D-Tuple{Any, Vararg{Float64, 6}}"><code>Merzbild.MaxwellWalls1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaxwellWalls1D(species_data, T_l::Float64, T_r::Float64, vy_l::Float64, vy_r::Float64, accomodation_l::Float64, accomodation_r::Float64)</code></pre><p>Create a <code>MaxwellWalls1D</code> struct for a 1-D simulation with 2 walls (&quot;left&quot; and &quot;right&quot;) with a velocity in     the y-direction only.</p><p><strong>Positional arguments</strong></p><ul><li><code>species_data</code>: vector of <code>Species</code> data</li><li><code>T_l</code>: temperature of left wall</li><li><code>T_r</code>: temperature of right wall</li><li><code>vy_l</code>: y-velocity of left wall</li><li><code>vy_r</code>: y-velocity of right wall</li><li><code>accomodation_l</code>: accommodation coefficient of left wall</li><li><code>accomodation_r</code>: accommodation coefficient of right wall</li></ul></div></section></article><h2 id="I/O"><a class="docs-heading-anchor" href="#I/O">I/O</a><a id="I/O-1"></a><a class="docs-heading-anchor-permalink" href="#I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.write_grid" href="#Merzbild.write_grid"><code>Merzbild.write_grid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_grid(nc_filename, grid::Grid1DUniform; global_attributes=Dict{Any,Any}())</code></pre><p>Write grid info to a NetCDF file</p><p><strong>Positional arguments</strong></p><ul><li><code>nc_filename</code>: path to the NetCDF file</li><li><code>grid</code>: the grid to be written out to a file</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>global_attributes</code>: dictionary of additional global attributes to be written to the netCDF file</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipList" href="#Merzbild.IOSkipList"><code>Merzbild.IOSkipList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipList</code></pre><p>Struct that holds track of which variables are not to be written to NetCDF file for physical properties computed on a grid. If the field value is <code>true</code>, the corresponding physical grid property will not be output to the file.</p><p><strong>Fields</strong></p><ul><li><code>skip_length_particle_array</code>: whether the length of the particle array should be skipped</li><li><code>skip_moments</code>: whether the output of the total moments should be skipped</li><li><code>skip_number_of_particles</code>: whether the output of the number of particles should be skipped</li><li><code>skip_number_density</code>: whether the output of the number density/number of physical particles should be skipped</li><li><code>skip_velocity</code>: whether the output of the velocity should be skipped</li><li><code>skip_temperature</code>: whether the output of the temperature should be skipped</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipList-Tuple{Any}" href="#Merzbild.IOSkipList-Tuple{Any}"><code>Merzbild.IOSkipList</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipList(list_of_variables_to_skip)</code></pre><p>Construct an <code>IOSkipList</code> from a list of variable names. The possible names are: <code>length_particle_array</code>, <code>moments</code>, <code>np</code> or <code>nparticles</code>, <code>ndens</code>, <code>v</code>, <code>T</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>list_of_variables_to_skip</code>: list of variable names to skip</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipList-Tuple{}" href="#Merzbild.IOSkipList-Tuple{}"><code>Merzbild.IOSkipList</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipList()</code></pre><p>Construct an empty <code>IOSkipList</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipListSurf" href="#Merzbild.IOSkipListSurf"><code>Merzbild.IOSkipListSurf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipListSurf</code></pre><p>Struct that holds track of which variables are not to be written to NetCDF file for computed surface properties. If the field value is <code>true</code>, the corresponding physical grid property will not be output to the file.</p><p><strong>Fields</strong></p><ul><li><code>skip_number_of_particles</code>: whether the output of the number of particles should be skipped</li><li><code>skip_fluxes</code>: whether the output of the incident/reflected fluxes should be skipped</li><li><code>skip_force</code>: whether the output of the force should be skipped</li><li><code>skip_normal_pressure</code>: whether the output of the normal pressure should be skipped</li><li><code>skip_shear_pressure</code>: whether the output of the shear pressure should be skipped</li><li><code>skip_kinetic_energy_flux</code>: whether the output of the kinetic energy flux should be skipped</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipListSurf-Tuple{Any}" href="#Merzbild.IOSkipListSurf-Tuple{Any}"><code>Merzbild.IOSkipListSurf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipListSurf(list_of_variables_to_skip)</code></pre><p>Construct an <code>IOSkipListSurf</code> from a list of variable names. The possible names are: <code>np</code> or <code>nparticles</code>, <code>fluxes</code>, <code>force</code>, <code>normal_pressure</code>, <code>shear_pressure</code>, &quot;kinetic<em>energy</em>flux&quot;.</p><p><strong>Positional arguments</strong></p><ul><li><code>list_of_variables_to_skip</code>: list of variable names to skip</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.IOSkipListSurf-Tuple{}" href="#Merzbild.IOSkipListSurf-Tuple{}"><code>Merzbild.IOSkipListSurf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IOSkipListSurf()</code></pre><p>Construct an empty <code>IOSkipListSurf</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolder" href="#Merzbild.NCDataHolder"><code>Merzbild.NCDataHolder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolder &lt;: AbstractNCDataHolder</code></pre><p>Struct that holds NetCDF-output related data for physical properties (grid properties) I/O.</p><p><strong>Fields</strong></p><ul><li><code>filehandle</code>: handle to the open NetCDF file</li><li><code>ndens_not_Np</code>: whether the number density or the number of physical particles is being output</li><li><code>timestep_dim</code>: timestep dimension that used to keep track of the number of output steps</li><li><code>v_spn</code>: variable to hold species&#39; names (dimension <code>n_species</code>)</li><li><code>v_timestep</code>: variable to hold the simulation timestep number (dimension <code>time</code>)</li><li><code>v_lpa</code>: variable to hold lengths of particle arrays (dimension <code>n_species x time</code>)</li><li><code>v_mompows</code>: variable to hold list of total moment powers (dimension <code>n_moments</code>)</li><li><code>v_moments</code>: variable to hold total moments (dimension <code>n_moments x n_cells x n_species x time</code>)</li><li><code>v_np</code>:  variable to hold number of particles (dimension <code>n_cells x n_species x time</code>)</li><li><code>v_ndens</code>: variable to hold number density or the number of physical particles (dimension <code>n_cells x n_species x time</code>)</li><li><code>v_v</code>: variable to hold velocity (dimension <code>3 x n_cells x n_species x time</code>)</li><li><code>v_T</code>: variable to hold temperature (dimension <code>n_cells x n_species x time</code>)</li><li><code>n_species_1</code>: constant vector <code>[n_species, 1]</code> (used for offsets during I/O)</li><li><code>n_cells_n_species_1</code>: constant vector <code>[n_cells, n_species, 1]</code> (used for offsets during I/O)</li><li><code>n_v_n_cells_n_species_1</code>: constant vector <code>[3, n_cells, n_species, 1]</code> (used for offsets during I/O)</li><li><code>currtimesteps</code>: vector <code>[n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1</code>: vector <code>[1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1_1</code>: vector <code>[1, 1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1_1_1</code>: vector <code>[1, 1, 1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>timestep</code>: vector storing the current simulation timestep</li><li><code>skip_list</code>: <code>IOSkipList</code> instance of variables to skip during output</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolder-NTuple{4, Any}" href="#Merzbild.NCDataHolder-NTuple{4, Any}"><code>Merzbild.NCDataHolder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolder(nc_filename, names_skip_list, species_data, phys_props; global_attributes=Dict{Any,Any}())</code></pre><p>Construct a <code>NCDataHolder</code> instance with a list of variables to skip.</p><p><strong>Positional arguments</strong></p><ul><li><code>nc_filename</code>: filename to write output to</li><li><code>names_skip_list</code>: list of variable names to skip, see <a href="#Merzbild.IOSkipList"><code>IOSkipList</code></a> for more details</li><li><code>species_data</code>: the vector of <code>Species</code> data for the species in the simulation</li><li><code>phys_props</code>: the <code>PhysProps</code> instance which will be used for the computation and output of physical properties</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>global_attributes</code>: dictionary of any additional attributes to write to the netCDF file as a global attribute</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolder-Tuple{Any, Any, Any}" href="#Merzbild.NCDataHolder-Tuple{Any, Any, Any}"><code>Merzbild.NCDataHolder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolder(nc_filename, species_data, phys_props; global_attributes=Dict{Any,Any}())</code></pre><p>Construct a <code>NCDataHolder</code> instance with an empty list of variable to skip,</p><p><strong>Positional arguments</strong></p><ul><li><code>nc_filename</code>: filename to write output to</li><li><code>species_data</code>: the vector of <code>Species</code> data for the species in the simulation</li><li><code>phys_props</code>: the <code>PhysProps</code> instance which will be used for the computation and output of physical properties</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>global_attributes</code>: dictionary of any additional attributes to write to the netCDF file as a global attribute</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolderSurf" href="#Merzbild.NCDataHolderSurf"><code>Merzbild.NCDataHolderSurf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolderSurf</code></pre><p>Struct that holds NetCDF-output related data for surface properties I/O.</p><p><strong>Fields</strong></p><ul><li><code>filehandle</code>: handle to the open NetCDF file</li><li><code>timestep_dim</code>: timestep dimension that used to keep track of the number of output steps</li><li><code>v_spn</code>: variable to hold species&#39; names (dimension <code>n_species</code>)</li><li><code>v_timestep</code>: variable to hold the simulation timestep number (dimension <code>time</code>)</li><li><code>v_np</code>:  variable to hold number of particles that hit the surface (dimension <code>n_elements x n_species x time</code>)</li><li><code>v_flux_incident</code>: variable to hold incident mass flux (dimension <code>n_elements x n_species x time</code>)</li><li><code>v_flux_reflected</code>: variable to hold reflected mass flux (dimension <code>n_elements x n_species x time</code>)</li><li><code>v_force</code>: variable to hold force (dimension <code>3 x n_elements x n_species x time</code>)</li><li><code>v_normal_pressure</code>: variable to hold normal pressure (dimension <code>n_elements x n_species x time</code>)</li><li><code>v_shear_pressure</code>: variable to hold shear pressure (dimension <code>3 x n_elements x n_species x time</code>)</li><li><code>v_kinetic_energy_flux</code>: variable to hold kinetic energy flux (dimension <code>n_elements x n_species x time</code>)</li><li><code>n_species_1</code>: constant vector <code>[n_species, 1]</code> (used for offsets during I/O)</li><li><code>n_elements_n_species_1</code>: constant vector <code>[n_elements, n_species, 1]</code> (used for offsets during I/O)</li><li><code>n_v_n_elements_n_species_1</code>: constant vector <code>[3, n_elements, n_species, 1]</code> (used for offsets during I/O)</li><li><code>currtimesteps</code>: vector <code>[n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1</code>: vector <code>[1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1_1</code>: vector <code>[1, 1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>currtimesteps_1_1_1</code>: vector <code>[1, 1, 1, n_t_output]</code>, where <code>n_t_output</code> is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)</li><li><code>timestep</code>: vector storing the current simulation timestep</li><li><code>skip_list</code>: <code>IOSkipListSurf</code> instance of variables to skip during output</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolderSurf-NTuple{4, Any}" href="#Merzbild.NCDataHolderSurf-NTuple{4, Any}"><code>Merzbild.NCDataHolderSurf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolderSurf(nc_filename, names_skip_list, species_data, surf_props; global_attributes=Dict{Any,Any}())</code></pre><p>Construct a <code>NCDataHolderSurf</code> instance with a list of variables to skip.</p><p><strong>Positional arguments</strong></p><ul><li><code>nc_filename</code>: filename to write output to</li><li><code>names_skip_list</code>: list of variable names to skip, see <a href="#Merzbild.IOSkipListSurf"><code>IOSkipListSurf</code></a> for more details</li><li><code>species_data</code>: the vector of <code>Species</code> data for the species in the simulation</li><li><code>surf_props</code>: the <code>SurfProps</code> instance which will be used for the computation and output of surface properties</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>global_attributes</code>: dictionary of any additional attributes to write to the netCDF file as a global attribute</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.NCDataHolderSurf-Tuple{Any, Any, Any}" href="#Merzbild.NCDataHolderSurf-Tuple{Any, Any, Any}"><code>Merzbild.NCDataHolderSurf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NCDataHolderSurf(nc_filename, species_data, surf_props; global_attributes=Dict{Any,Any}())</code></pre><p>Construct a <code>NCDataHolderSurf</code> instance with an empty list of variable to skip.</p><p><strong>Positional arguments</strong></p><p><strong>Positional arguments</strong></p><ul><li><code>nc_filename</code>: filename to write output to</li><li><code>species_data</code>: the vector of <code>Species</code> data for the species in the simulation</li><li><code>surf_props</code>: the <code>SurfProps</code> instance which will be used for the computation and output of surface properties</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>global_attributes</code>: dictionary of any additional attributes to write to the netCDF file as a global attribute</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.write_netcdf-Tuple{Any, PhysProps, Any}" href="#Merzbild.write_netcdf-Tuple{Any, PhysProps, Any}"><code>Merzbild.write_netcdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> write_netcdf(ds, phys_props::PhysProps, timestep; sync_freq=0)</code></pre><p>Write computed <code>PhysProps</code> to NetCDF file and synchronize file to disk if necessary.</p><p><strong>Positional arguments</strong></p><ul><li><code>ds</code>: the <code>NCDataHolder</code> for the file to which the output will be written</li><li><code>phys_props</code>: the <code>PhysProps</code> instance containing the computed properties</li><li><code>timestep</code>: the simulation timestep</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sync_freq</code>: if larger than 0 and if the number of timesteps output is proportional to <code>sync_freq</code>,   the data will be synchronized to disk. If set to 1, will sync data to disk at every timestep at which   data is written to the file.</li></ul><p><strong>Throws</strong></p><p><code>ErrorException</code> if the <code>NCDataHolder</code> expects number density and the <code>phys_props</code> holds the number of physical particles, or vice versa.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.write_netcdf-Tuple{Any, SurfProps, Any}" href="#Merzbild.write_netcdf-Tuple{Any, SurfProps, Any}"><code>Merzbild.write_netcdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_netcdf(ds, surf_props::SurfProps, timestep; sync_freq=0)</code></pre><p>Write SurfProps to NetCDF file and synchronize file to disk if necessary.</p><p><strong>Positional arguments</strong></p><ul><li><code>ds</code>: the <code>NCDataHolderSurf</code> for the file to which the output will be written</li><li><code>surf_props</code>: the <code>SurfProps</code> instance containing the computed properties</li><li><code>timestep</code>: the simulation timestep</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sync_freq</code>: if larger than 0 and if the number of timesteps output is proportional to <code>sync_freq</code>,   the data will be synchronized to disk. If set to 1, will sync data to disk at every timestep at which   data is written to the file.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.close_netcdf" href="#Merzbild.close_netcdf"><code>Merzbild.close_netcdf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close_netcdf(ds::AbstractNCDataHolder)</code></pre><p>Close NetCDF file.</p><p><strong>Positional arguments</strong></p><ul><li><code>ds</code>: an <code>AbstractNCDataHolder</code> instance to close.</li></ul></div></section></article><h2 id="Parallel-computations"><a class="docs-heading-anchor" href="#Parallel-computations">Parallel computations</a><a id="Parallel-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-computations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ChunkExchanger" href="#Merzbild.ChunkExchanger"><code>Merzbild.ChunkExchanger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChunkExchanger</code></pre><p>Struct used to organize exchange of particles between independent ParticleVector instances for chunked multi-threaded simulations. It is assumed that the cell indices within each chunk are contiguous, i.e. <code>chunk[i+1] = chunk[i]+1</code>. The <code>n_local</code> field of <code>ParticleIndexer</code> is left unused.</p><p>Group 1 of <code>ParticleIndexer[chunk_id,cell]</code> holds the range of particles that belong to cell <code>cell</code> that came from a particle chunk <code>chunk_id</code> via swapping.</p><p>Group 2 of <code>ParticleIndexer[chunk_id,cell]</code> holds the range of particles that belong to cell <code>cell</code> that came from a particle chunk <code>chunk_id</code> via pushing, i.e. they have been added to the end of the particle array.</p><p><strong>Fields</strong></p><ul><li><code>n_chunks</code>: number of chunks used in the simulation</li><li><code>n_cells</code>: number of grid cells in the simulation</li><li><code>indexer</code>: array of <code>ParticleIndexer</code> instances of shape <code>(n_chunks, n_cells)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.ChunkExchanger-Tuple{Any, Any}" href="#Merzbild.ChunkExchanger-Tuple{Any, Any}"><code>Merzbild.ChunkExchanger</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChunkExchanger(chunks, n_cells)</code></pre><p>Create a <code>ChunkExchanger</code> for <code>length(chunks)</code> chunks and <code>n_cells</code> cell.</p><p><strong>Positional arguments</strong></p><ul><li><code>chunks</code>: list of cell chunks</li><li><code>n_cells</code>: total number of cells in the simulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.exchange_particles!" href="#Merzbild.exchange_particles!"><code>Merzbild.exchange_particles!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exchange_particles!(chunk_exchanger, particles_chunks, pia_chunks, cell_chunks, species)</code></pre><p>Redistribute particles between chunks based on their spatial cell ownership.</p><p>This function ensures each particle resides in the chunk responsible for its current cell. It performs symmetric swaps when possible, and pushes remaining particles if needed. The indexing metadata (<code>chunk_exchanger</code> and <code>pia_chunks</code>) is updated accordingly, and particles pushed to another chunk (not swapped) are added to the buffer for future re-use. The particles before the start of the re-distribution need to be sorted, so that no particles are indexed by the <code>start2:end2</code> part of a <code>ParticleIndexer</code>.  After the operation, the <code>n_total[species]</code> value of <code>pia_chunks[chunk_id]</code> will not include particles that were pushed to another chunk (the appropriate <code>n_group1</code>, <code>start1</code>, <code>end1</code> values will be set to 0, 0, -1). However indexing should not be relied on until particles are re-sorted, see (<code>sort_particles_after_exchange!</code>)[@ref].</p><p><strong>Positional arguments</strong></p><ul><li><code>chunk_exchanger</code>: the <code>ChunkExchanger</code> instance to track post-swap and post-push indices</li><li><code>particles_chunks</code>: Vector of Vector of <code>ParticleVector</code> (per chunk and per species, i.e.   <code>particles_chunks[chunk_id][species]</code> is the correct order of access)</li><li><code>pia_chunks</code>: Vector of <code>ParticleIndexerArray</code> instances for each chunk</li><li><code>cell_chunks</code>: cell ownership list for each chunk, i.e. <code>cell_chunks[chunk_id]</code> is a list   of cells belonging to chunk <code>chunk_id</code>; the cells within <code>cell_chunks[chunk_id]</code> should   be ordered in increasing order and be continuous:   i.e. <code>cell_chunks[chunk_id][i] == cell_chunks[chunk_id][i-1] + 1</code></li><li><code>species</code>: the particle species being redistributed</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.sort_particles_after_exchange!" href="#Merzbild.sort_particles_after_exchange!"><code>Merzbild.sort_particles_after_exchange!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_particles_after_exchange!(chunk_exchanger, gridsort, particles, pia, cell_chunk, species)</code></pre><p>Restore indexing of a <code>ParticleVector</code> and the associated <code>ParticleIndexerArray</code> after particles have been swapped and pushed between chunks.</p><p><strong>Positional arguments</strong></p><ul><li><code>chunk_exchanger</code>: the <code>ChunkExchanger</code> instance used to track post-swap and post-push indices</li><li><code>gridsort</code>: The <code>GridSortInPlace</code> associated with the chunk</li><li><code>particles_chunks</code>: the <code>ParticleVector</code> for which to restore the indexing</li><li><code>pia</code>: the <code>ParticleIndexerArray</code> instances associated with the chunk</li><li><code>cell_chunk</code>: list or range of cells belonging to the chunk</li><li><code>species</code>: the particle species being for which the indexing is being restored</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.reset!" href="#Merzbild.reset!"><code>Merzbild.reset!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(chunk_exchanger, chunk_id)</code></pre><p>Reset all indexing of <code>chunk_exchanger.indexer[chunk_id,:]</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>chunk_exchanger</code>: the <code>ChunkExchanger</code> instance</li><li><code>chunk_id</code>: the chunk for which to reset indexing</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.reduce_surf_props!" href="#Merzbild.reduce_surf_props!"><code>Merzbild.reduce_surf_props!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_surf_props!(surf_props_target, surf_props_chunks)</code></pre><p>Sum up the values of the computed surface properties for all <code>SurfProps</code> instances in  a <code>surf_props_chunks</code> list and store the sums in <code>surf_props_target</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>surf_props_target</code>: the <code>SurfProps</code> instance which will hold the reduced values</li><li><code>surf_props_chunks</code>: the list <code>SurfProps</code> instances to use for the reduction operation</li></ul></div></section></article><h2 id="Particle-in-Cell"><a class="docs-heading-anchor" href="#Particle-in-Cell">Particle-in-Cell</a><a id="Particle-in-Cell-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-in-Cell" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.accelerate_constant_field_x!" href="#Merzbild.accelerate_constant_field_x!"><code>Merzbild.accelerate_constant_field_x!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accelerate_constant_field_x!(particles, pia, cell, species, species_data, E, Δt)</code></pre><p>Accelerate particles with a constant electric field in the X direction</p><p><strong>Positional arguments</strong></p><ul><li><code>particles</code>: vector-like structure of particles to be accelerated</li><li><code>pia</code>: ParticleIndexerArray instance</li><li><code>cell</code>: index of the cell in which particles are being accelerated</li><li><code>species</code>: index of the species of the particles being accelerated</li><li><code>species_data</code>: a <code>Vector{Species}</code> instance with the species&#39; data</li><li><code>E</code>: value of the electric field in V/m</li><li><code>Δt</code>: timestep for which the acceleration is performed</li></ul></div></section></article><h2 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.k_B" href="#Merzbild.k_B"><code>Merzbild.k_B</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Boltzmann constant, J/K</p></div></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Merzbild.DataMissingException" href="#Merzbild.DataMissingException"><code>Merzbild.DataMissingException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataMissingException</code></pre><p>Exception for the case of missing tabulated cross-section data</p><p><strong>Fields</strong></p><ul><li><code>msg</code>: error message</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multithreaded/">« Multithreaded simulations</a><a class="docs-footer-nextpage" href="../reference_internal/">Internal API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 13:01">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
