<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contiguous indexing · Merzbild</title><meta name="title" content="Contiguous indexing · Merzbild"/><meta property="og:title" content="Contiguous indexing · Merzbild"/><meta property="twitter:title" content="Contiguous indexing · Merzbild"/><meta name="description" content="Documentation for Merzbild."/><meta property="og:description" content="Documentation for Merzbild."/><meta property="twitter:description" content="Documentation for Merzbild."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Merzbild</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview_capabilities/">Overview of capabilities</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview_blocks/">Overview of basic building blocks</a></li><li><a class="tocitem" href="../overview_fixedweight/">Fixed-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_varweight/">Variable-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_1d/">1D DSMC simulations</a></li><li><a class="tocitem" href="../overview_fp/">Fokker-Planck simulations</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Contiguous indexing</a><ul class="internal"><li><a class="tocitem" href="#Particle-buffer"><span>Particle buffer</span></a></li><li><a class="tocitem" href="#Contiguous-indexing"><span>Contiguous indexing</span></a></li><li><a class="tocitem" href="#Deleting-particles"><span>Deleting particles</span></a></li><li><a class="tocitem" href="#Debugging"><span>Debugging</span></a></li></ul></li><li><a class="tocitem" href="../modelling_ionization/">Modelling ionization reactions</a></li><li><a class="tocitem" href="../multithreaded/">Multithreaded simulations</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../reference_public/">Public API reference</a></li><li><a class="tocitem" href="../reference_internal/">Internal API reference</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Contiguous indexing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Contiguous indexing</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Particle-buffers-and-contiguous-indexing"><a class="docs-heading-anchor" href="#Particle-buffers-and-contiguous-indexing">Particle buffers and contiguous indexing</a><a id="Particle-buffers-and-contiguous-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-buffers-and-contiguous-indexing" title="Permalink"></a></h1><p>This section discusses some more advanced concepts and associated issues concerning particle indexing in scenarios where particle counts may become lower during the course of a simulation.</p><h2 id="Particle-buffer"><a class="docs-heading-anchor" href="#Particle-buffer">Particle buffer</a><a id="Particle-buffer-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-buffer" title="Permalink"></a></h2><p>As discussed in <a href="../overview_blocks/#Overview-of-basic-building-blocks">the overview of the basic building blocks of Merzbild.jl</a>, a <code>ParticleVector</code> instance has a <code>particles</code> vector, an <code>index</code> array to index the particles, and <code>buffer</code> array to keep track of which particles in the <code>particles</code> vector are unused (as a LIFO queue).</p><p>So to create a new particle in the simulation (assuming the <code>ParticleVector</code> instance <code>pv</code> has enough unused pre-allocated particles, otherwise one needs to call <code>resize!</code> first), one needs to do the following:</p><ol><li>Update the <code>pia</code> structure to keep track for which species in which cell and group the particle is being created</li><li>Grab the index of the appropriate element in the buffer: <code>i = pv.buffer[pv.nbuffer]</code>  and decrease the number of elements in the buffer (<code>pv.nbuffer -= 1</code>)</li><li>Writes this index <code>i</code> to the last position in the <code>index</code> array (the particle count in <code>pia</code> has already been updated):  <code>pv.index[pia.n_total[species]] = i</code>. </li></ol><p>A utility function <a href="../reference_internal/#Merzbild.update_buffer_index_new_particle!"><code>update_buffer_index_new_particle!</code></a> is available which takes care of all of these steps.</p><p><strong>Summary</strong>: one needs to be aware of the buffer when creating new particles, to avoid any issues with over-writing existing particles.</p><h2 id="Contiguous-indexing"><a class="docs-heading-anchor" href="#Contiguous-indexing">Contiguous indexing</a><a id="Contiguous-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Contiguous-indexing" title="Permalink"></a></h2><p>One can iterate through all the particles in a simulation of a specific species by going through all the cells and then going through all the groups of particles:</p><pre><code class="language-julia hljs">for cell in 1:grid.n_cells
    s = pia.indexer[cell, species].start1
    e = pia.indexer[cell, species].end1
    
    for i in s:e
        do_something!(particles[i])
    end

    if pia.indexer[cell, species].n_group2 &gt; 0
        s = pia.indexer[cell, species].start2
        e = pia.indexer[cell, species].end2
    
        for i in s:e
            do_something!(particles[i])
        end
    end
end</code></pre><p>However, it is more efficient to iterate in the following manner:</p><pre><code class="language-julia hljs">for i in 1:pia.n_total[species]
    do_something!(particles[i]) 
end</code></pre><p>This however requires the indexing to be <strong>contiguous</strong>, which means the following should hold:</p><ol><li><code>pia.indexer[cell,species].end1 + 1 == pia.indexer[cell+1,species].start1</code>, <code>cell = 1,...,n_cells - 1</code></li><li><code>pia.indexer[n_cells,species].end1 + 1 == pia.indexer[1,species].start2</code></li><li><code>pia.indexer[cell,species].end2 + 1 == pia.indexer[cell+1,species].start2</code>, <code>cell = 1,...,n_cells - 1</code>.</li></ol><p>So this basically correspond to the indexing as defined by the indexer having no &quot;holes&quot;. For this purposes, <code>pia</code> has the boolean <code>contiguous</code> property, which can be checked to decided how to iterate over particles.</p><p>It is expected that a particle sorting routine restores continuity of indices. There is also a utility function <a href="../reference_public/#Merzbild.squash_pia!"><code>squash_pia!</code></a> which restores continuity of indices by moving around the indices in a <code>ParticleVector</code> instance, as well as the starts and ends of groups in the <code>pia</code> particle indexing structure.</p><p><strong>Summary</strong>: If iterating over particles in more than one cell, one should not assume that the particle indices are contiguous, and the value of <code>pia.contiguous</code> should be checked first. Particle sorting or a call to <code>squash_pia!</code> restore continuity of indices.</p><h2 id="Deleting-particles"><a class="docs-heading-anchor" href="#Deleting-particles">Deleting particles</a><a id="Deleting-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Deleting-particles" title="Permalink"></a></h2><p>So how do these holes in the indexing actually appear?</p><p>Deletion happens at the end of the group, if not, the ordering of the particles is changed by changing around the indices so that the particle to be deleted moves to the end of the group and then is deleted.</p><p>A function <a href="../reference_internal/#Merzbild.delete_particle!"><code>delete_particle!</code></a> is provided which does exactly this. A more specialized function <a href="../reference_internal/#Merzbild.delete_particle_end!"><code>delete_particle_end!</code></a> deletes the last particle in the group.</p><p>So a hole might appear in the indexing if one is doing particle merging. For example, let&#39;s say we have 20 particles in two cells with 10 particles per cell, and the indexing looks like this: <code>pia.indexer[1,1].start1 = 1</code>, <code>pia.indexer[1,1].end1 = 10</code>, <code>pia.indexer[2,1].start1 = 11</code>,  <code>pia.indexer[2,1].end1 = 20</code>. If we merge particles in cell 1 down to 2 particles, the <code>buffer</code> in the <code>ParticleVector</code> instance <code>pv</code> will be updated, and <code>pia.indexer[1,1].end1</code> will be set to 2, but the particles <code>pv[3:10]</code> can&#39;t be really accessed or used, unless we either 1) sort the particles 2) call <a href="../reference_public/#Merzbild.squash_pia!"><code>squash_pia!</code></a>. Some computations currently used the number of particles of a certain species to find where to place a newly created particle (for example, in the variable-weight NTC collision functions); without restoring continuity of the indexing, this will lead to erroneous results, as now the index of the last particle in the simulation <code>pv[20]</code> is no longer the same as the total number of particles in the simulation (which is 12 after the merge).</p><p>So, for a multi-dimensional simulation with variable-weight DSMC, the correct collide-merge procedure might take on the following form:</p><pre><code class="language-julia hljs">
for cell in 1:grid.n_cells
    ntc!(rng, collision_factors[1, 1, cell],
         collision_data, interaction_data, particles[1], pia, cell, 1, Δt, grid.cells[cell].V)

    if pia.indexer[cell,1].n_local &gt; merge_threshold
        # we need to merge
        merge_octree_N2_based!(rng, oc, particles[1], pia, cell, 1, merge_target, grid)
        # restore continuity of pia
        squash_pia!(particles, pia)
    end
end</code></pre><p>So if no merging took place, then no particle deletion happened, and one doesn&#39;t need to call <code>squash_pia!</code>. Of course, <code>squash_pia!</code> checks the value of <code>pia.contiguous</code> and does nothing if that value is set to <code>true</code>.</p><p><strong>Summary</strong>: one needs to restore continuity of particle indexing if particles are deleted and created in a simulation, otherwise this might lead to erroneous results.</p><h2 id="Debugging"><a class="docs-heading-anchor" href="#Debugging">Debugging</a><a id="Debugging-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging" title="Permalink"></a></h2><p>Several utility functions are available to verify/help debug simulations.</p><p><a href="../reference_public/#Merzbild.pretty_print_pia"><code>pretty_print_pia</code></a> prints out the start/end indices for all groups in all cells for particles of a given species. <a href="../reference_public/#Merzbild.check_pia_is_correct"><code>check_pia_is_correct</code></a> verifies that the indexing of groups is consistent. <a href="../reference_public/#Merzbild.check_unique_index"><code>check_unique_index</code></a> checks that no two indices point to the same particle, as well as that no particles in the buffer are pointed to by indices used in the simulation. This function allocates a temporary array and is therefore slow for large numbers of particles.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview_fp/">« Fokker-Planck simulations</a><a class="docs-footer-nextpage" href="../modelling_ionization/">Modelling ionization reactions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 13:01">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
