<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview of basic building blocks · Merzbild</title><meta name="title" content="Overview of basic building blocks · Merzbild"/><meta property="og:title" content="Overview of basic building blocks · Merzbild"/><meta property="twitter:title" content="Overview of basic building blocks · Merzbild"/><meta name="description" content="Documentation for Merzbild."/><meta property="og:description" content="Documentation for Merzbild."/><meta property="twitter:description" content="Documentation for Merzbild."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Merzbild</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview_capabilities/">Overview of capabilities</a></li><li><span class="tocitem">Getting started</span><ul><li class="is-active"><a class="tocitem" href>Overview of basic building blocks</a><ul class="internal"><li><a class="tocitem" href="#Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray"><span>Particle indexing: ParticleIndexer and ParticleIndexerArray</span></a></li><li><a class="tocitem" href="#Particles:-Particle-and-ParticleVector"><span>Particles: Particle and ParticleVector</span></a></li><li><a class="tocitem" href="#Physical-data:-Species"><span>Physical data: Species</span></a></li><li><a class="tocitem" href="#Sampling-particles"><span>Sampling particles</span></a></li><li><a class="tocitem" href="#Computing-macroscopic-physical-properties:-PhysProps"><span>Computing macroscopic physical properties: PhysProps</span></a></li><li><a class="tocitem" href="#Writing-output:-NCDataHolder"><span>Writing output: NCDataHolder</span></a></li><li><a class="tocitem" href="#Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps"><span>Computing surface properties due to particle-surface interactions: SurfProps</span></a></li><li><a class="tocitem" href="#Example:-bringing-it-all-together"><span>Example: bringing it all together</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../overview_fixedweight/">Fixed-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_varweight/">Variable-weight DSMC simulations</a></li><li><a class="tocitem" href="../overview_1d/">1D DSMC simulations</a></li><li><a class="tocitem" href="../overview_fp/">Fokker-Planck simulations</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../contiguous_indexing/">Contiguous indexing</a></li><li><a class="tocitem" href="../modelling_ionization/">Modelling ionization reactions</a></li><li><a class="tocitem" href="../multithreaded/">Multithreaded simulations</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../reference_public/">Public API reference</a></li><li><a class="tocitem" href="../reference_internal/">Internal API reference</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Overview of basic building blocks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview of basic building blocks</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview-of-basic-building-blocks"><a class="docs-heading-anchor" href="#Overview-of-basic-building-blocks">Overview of basic building blocks</a><a id="Overview-of-basic-building-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-basic-building-blocks" title="Permalink"></a></h1><h2 id="Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray"><a class="docs-heading-anchor" href="#Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray">Particle indexing: ParticleIndexer and ParticleIndexerArray</a><a id="Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray" title="Permalink"></a></h2><p>One of the main parts of the code is the <code>ParticleIndexer</code> struct. It contains the starting and ending indices of the particles of a single species in a single cell. During collisions, the number of the particles of a certain species in a cell may increase, either due to inelastic processes, or due to particle splitting in variable-weight collisions. These new particles are &quot;tacked onto&quot; the end of the whole array of particles of the species. Thus, each  <code>ParticleIndexer</code> instance potentially tracks two blocks of particles that are all in a single cell: the ones that were there before collisions were performed, and the new ones that got created during collisions and are at the end of the array.</p><p><img src="../assets/particle_indexer.png" alt="particle_indexer_trim"/></p><p>The figure above shows a graphical representation of the meaning of some of the fields of the <code>ParticleIndexer</code> struct. Assume we have a set of 10 particles in 3 different cells (different cells are colour-coded), with particles <em>1</em>, <em>2</em>, <em>3</em>, <em>7</em>, <em>8</em>, <em>9</em>, <em>10</em> located in cell <strong>1</strong>, particles <em>4</em>, <em>5</em> located in cell <strong>2</strong>, and particle <em>6</em> located in cell <strong>3</strong>. The <code>ParticleIndexer</code> struct corresponding to cell <strong>1</strong> will then have the following values for its fields:</p><pre><code class="language-julia hljs">particle_indexer_cell_1.start1 = 1
particle_indexer_cell_1.end1 = 3
particle_indexer_cell_1.start2 = 7
particle_indexer_cell_1.end2 = 10</code></pre><p>The struct also has additional utility fields:</p><ul><li><code>ParticleIndexer.n_group1 = ParticleIndexer.end1 - ParticleIndexer.start1 + 1</code> stores the number of particles in the first block</li><li><code>ParticleIndexer.n_group2 = ParticleIndexer.end2 - ParticleIndexer.start2 + 1</code> stores the number of particles in the second block</li><li><code>ParticleIndexer.n_local = ParticleIndexer.n_group1 + ParticleIndexer.n_group2</code> stores the total number of particles of this species in this cell.</li></ul><p>The fields of the <code>ParticleIndexer</code> struct are not really intended for manual manipulation unless one is developing new sorting or merging routines, in which case one might have to set the starting and ending fields oneself. Most of the time, the existing sorting/collision/merging routines take care of keeping the particle indexers updated and correct.</p><p>Since we are usually interested in multi-species and/or multi-dimensional simulations, an array of <code>ParticleIndexer</code> instances is needed to keep track of the particles of different species in different cells. For this purpose Merzbild.jl provides the <code>ParticleIndexerArray</code> struct. It has two fields:</p><ul><li><code>ParticleIndexerArray.indexer</code>: a 2-dimensional array of <code>ParticleIndexer</code> instances with dimensions <code>n_cells*n_species</code></li><li><code>ParticleIndexerArray.n_total</code>: a 1-dimensional vector of length <code>n_species</code> with per-species total particle counts </li></ul><p>Thus, to iterate over the particles of a specific species in a specific cell, one uses an instance of the <code>ParticleIndexerArray</code> (called <code>pia</code> in the code by convention):</p><pre><code class="language-julia hljs">for i in pia.indexer[cell,species].start1:pia.indexer[cell,species].end1
    # do something with particles[species][i]
end

if pia.indexer[cell,species].start2 &gt; 0
    for i in pia.indexer[cell,species].start2:pia.indexer[cell,species].end2
        # do something with particles[species][i]
    end
end</code></pre><p>Some utility functions are available for updating particle indexer arrays for developing new functionality: <a href="../reference_internal/#Merzbild.update_particle_indexer_new_lower_count!"><code>Merzbild.update_particle_indexer_new_lower_count!</code></a> and <a href="../reference_internal/#Merzbild.update_particle_indexer_new_particle!"><code>Merzbild.update_particle_indexer_new_particle!</code></a>. It is assumed that if the number of particles in the second block pointed to by a <code>ParticleIndexer</code> instance is 0, then the value of <code>start2</code> is set to a value smaller than 0, so to iterate over the particles in the second block one can either do a check similar to the <code>pia.indexer[cell,species].start2 &gt; 0</code> check seen above, or check if <code>pia.indexer[cell,species].n_group2 &lt;= 0</code>. See also the section on <a href="../contiguous_indexing/#Particle-buffers-and-contiguous-indexing">Particle buffers and contiguous indexing</a>.</p><h2 id="Particles:-Particle-and-ParticleVector"><a class="docs-heading-anchor" href="#Particles:-Particle-and-ParticleVector">Particles: Particle and ParticleVector</a><a id="Particles:-Particle-and-ParticleVector-1"></a><a class="docs-heading-anchor-permalink" href="#Particles:-Particle-and-ParticleVector" title="Permalink"></a></h2><p>Now that we can index particles, we need to create some lists of particles to index. For that, we need to define what a particle is. For this purpose, a <code>Particle</code> struct is available in the code. It has the following fields:</p><ul><li><code>w</code>: the computational weight of the particle (in a fixed-weight DSMC simulation, this is the <span>$F_{num}$</span> parameter)</li><li><code>v</code>: the 3-dimensional velocity vector of the particle</li><li><code>x</code>: the 3-dimensional position vector of the particle</li></ul><p>Each species has its own list of particles associated with it, so a <code>particles</code> variable in the simulation could have the following the type <code>Vector{Vector{Particle}}</code>. Then <code>particles[species_1]</code> would correspond to the list of all particles of chemical species <code>species_1</code>. <code>pia.indexer[cell,species_1]</code> would then be used to index the particles of <code>species_1</code> in a specific cell <code>cell</code>.</p><p>The drawback of using <code>Vector{Vector{Particle}}</code> is that for non-spatially homogeneous simulations, the particles need to be sorted after each convection step, and this would involving constantly re-writing the position and velocity vectors. To reduce the computational cost of sorting, an additional abstraction layer is added via the struct <code>ParticleVector</code> that is intended to be used instead of  a simple <code>Vector{Particle}</code> instance. An instance of <code>ParticleVector</code> has the following fields:</p><ul><li><code>particles</code>: the underlying vector of particles</li><li><code>index</code>: the sorted indices of the particles</li><li><code>cell</code>: used in particle sorting to keep track of new assigned cells</li><li><code>buffer</code>: a LIFO queue used to track which particles from <code>particles</code> are not being used (i.e. allocated in memory but not present in the simulation)</li><li><code>nbuffer</code>: the number of elements in <code>buffer</code></li></ul><p>Given a <code>ParticleVector</code> instance <code>pv</code>, one can still transparently access a particle at index <code>i</code> as <code>pv[i]</code>. This access operation however uses the sorted <code>index</code> list to get the actual index of the particle, so <code>pv[i]</code> is equivalent to <code>pv.particles[pv.index[i]]</code>. During particle sorting, only the indices in <code>index</code> are shuffled around, which is computationally cheaper than sorting the particles directly.</p><p><img src="../assets/particlevector.png" alt="particle_vector_trim"/></p><p>The figure above shows the how the underlying particles (top array) are indexed via the help of the <code>index</code> field of the <code>ParticleVector</code> struct, and finally how the indices of the particles in a specific cell are indexed by the <code>ParticleIndexer</code> instance. In the example above, the different colors correspond to different grid cells. It can be seen that the array of <code>Particle</code> instances (&quot;underlying <code>Particle</code> vector&quot;) is unsorted. The indices (<code>ParticleVector.index</code>) are however sorted. Thus, <code>ParticleVector.index[1]</code> points to the 1-st particle in the underlying <code>Particle</code> array, and <code>ParticleVector.index[2]</code> points to the 4-th particle.  <code>ParticleVector.index[6]</code> points to the 2-nd particle, and so on. It may be that due to creation of new particles during collisions some particles in the same cell are at the very end of the array (as they just got created). In the example above, particles <code>9</code> and <code>10</code> are in the same cell as particles <code>1</code>, <code>4</code>, <code>5</code>, <code>7</code>, <code>8</code>. Therefore the corresponding <code>ParticleIndexer</code> instance for this cell will have <code>start1=1</code>, <code>end1=5</code> (pointing to the first block of indices), and <code>start2=9</code>, <code>end2=9</code> (pointing to the second block of indices).</p><p>For all practical purposes, it should be sufficient to deal with particles in a <code>ParticleVector</code> instance <code>pv</code> by directly accessing them as <code>pv[i]</code>; the <code>index</code> and <code>cell</code> fields need to be changed only when one is writing new sorting routines.</p><p>For a more in-depth overview of particle indexing, especially relevant for multi-dimensional simulations where particles might be frequently deleted due to merging or outflow, the reader is referred to <a href="../contiguous_indexing/#Contiguous-indexing">the documentation on contiguous indexing</a>, which describes additional concepts associated with the indexing approach used in Merzbild.jl and provides some tips on improving performance in the listed scenarios.</p><p>To summarize, for multi-species multi-dimensional simulations, one needs to use a <code>Vector{ParticleVector}</code> instance, each element of which (of type <code>ParticleVector</code>) corresponds to a vector of particles of a specific species. If one does not intend to sort particles (i.e. a 0-D simulation), one can in theory use a simple <code>Vector{Vector{Particle}}</code> instance, however, some of the particle sampling routines assume a <code>ParticleVector</code> instance (as they write the cell index data).</p><h2 id="Physical-data:-Species"><a class="docs-heading-anchor" href="#Physical-data:-Species">Physical data: Species</a><a id="Physical-data:-Species-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-data:-Species" title="Permalink"></a></h2><p>To sample particles, we need to know some properties of the chemical species that they represent. This is done via instances of the <code>Species</code> struct, which have the following fields:</p><ul><li><code>name</code>: the name of the species</li><li><code>mass</code>: the mass of the species</li><li><code>charge</code>: the charge of the species (in terms of elementary charge)</li><li><code>charge_div_mass</code>: the charge of the species (in Coulombs) divided by the mass of the species</li></ul><p>Data about chemical species can be loaded by using the <a href="../reference_public/#Merzbild.load_species_data"><code>load_species_data</code></a> function, which reads a TOML file with the relevant species information.</p><h2 id="Sampling-particles"><a class="docs-heading-anchor" href="#Sampling-particles">Sampling particles</a><a id="Sampling-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-particles" title="Permalink"></a></h2><p>In order to sample particles of a certain species from a specific distribution, Merzbild.jl provides several functions. For fixed-weight DSMC simulations, one can use the <a href="../reference_public/#Merzbild.sample_particles_equal_weight!"><code>sample_particles_equal_weight!</code></a> to sample equal-weight particles from either a Maxwell or a BKW distribution. For variable-weight DSMC simulations, one can of course also use the same function (there is no inherent difference between fixed- and variable-weight DSMC simulations in Merzbild).</p><p>However, in case variable-weight particles are allowed, one can also sample them from a distribution by evaluating that distribution of a discrete velocity grid. This functionality is provided by the <a href="../reference_public/#Merzbild.sample_on_grid!"><code>sample_on_grid!</code></a> function and its more specific version <a href="../reference_public/#Merzbild.sample_maxwellian_on_grid!"><code>sample_maxwellian_on_grid!</code></a> that assumes a Maxwell distribution. Sampling on a grid can lead to very high particle counts (for example, sampling on a 30x30x30 grid will lead to creation of up to 27000 particles in each physical cell), so care must be taken, and particles might need to be merged immediately after having been created.</p><h2 id="Computing-macroscopic-physical-properties:-PhysProps"><a class="docs-heading-anchor" href="#Computing-macroscopic-physical-properties:-PhysProps">Computing macroscopic physical properties: PhysProps</a><a id="Computing-macroscopic-physical-properties:-PhysProps-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-macroscopic-physical-properties:-PhysProps" title="Permalink"></a></h2><p>Now that we have a vector of particles, we can compute some macroscopic properties (density, velocity, etc.). To store and use these properties where they might be needed, the <code>PhysProps</code> struct is provided. An instance of <code>PhysProps</code> has the following fields:</p><ul><li><code>ndens_not_Np</code>: a boolean value used to distinguish between the meanings of the <code>n</code> field (see below) and ensure consistency</li><li><code>n_cells</code>: number of grid cells</li><li><code>n_species</code>: number of species in the simulation</li><li><code>n_moments</code>: number of total moments computed (see below how moments are defined)</li><li><code>lpa</code>: vector of length <code>n_species</code> storing the lengths of the particle arrays (i.e. how many elements have been allocated, actual particle counts may be less)</li><li><code>np</code>: array with dimensions <code>n_cells*n_species</code>, stores the number of particles of each species in each grid cell</li><li><code>n</code>: array with dimensions <code>n_cells*n_species</code>, stores either the number of physical particles of each species in each grid cell or the number density of each species in each grid cell, see below for explanation</li><li><code>v</code>: array with dimensions <code>3*n_cells*n_species</code>, stores the x, y, and z components of the macroscopic velocity of each species in each grid cell </li><li><code>T</code>: array with dimensions <code>n_cells*n_species</code>, stores the temperature of each species in each grid cell</li><li><code>moment_powers</code>: vector of length <code>n_moments</code>, stores which total moments are being computed</li><li><code>moments</code>: array with dimensions <code>n_moments*n_cells*n_species</code>, stores the total moments of each species in each grid cell</li><li><code>Tref</code>: a reference temperature set during initialization of a <code>PhysProps</code> instance used to scale the moments so that for an equilibrium distribution at a temperature of <span>$T_{ref}$</span> all moments are equal to 1.</li></ul><p>One can see that the definition of the <code>n</code> field is somewhat ambiguous - it can either mean the total number of particles in a cell, or the number density in a cell (equal to the number of particles in the cell divided by the cell volume). To distinguish between these two cases, the following convention is assumed, one can provide a value of <code>ndens_not_NP</code> during instantiation (by default it is <code>false</code>, i.e. the number of physical particles is computed and not the number density).</p><p>If we don&#39;t need to compute the total moments, then we can create a <code>PhysProps</code> instance by simply passing a <code>ParticleIndexerArray</code> instance to the constructor, as it already has the required information on the number of grid cells and species. So we can simply do this: <code>props = PhysProps(pia)</code>.</p><p>The <a href="../reference_public/#Merzbild.compute_props!"><code>compute_props!</code></a> function computes the macroscopical physical properties of all species in all cells in the simulation. <strong>Currently this computes only the number of particles in a cell, regardless of the value of the <code>ndens_not_Np</code> field.</strong></p><p>There is an optimized version of this function, which assumes the particles are only indexed by the first group of a <code>ParticleIndexer</code> instance: <a href="../reference_public/#Merzbild.compute_props_sorted!"><code>compute_props_sorted!</code></a>; it also does not computed any moments. This is the case immediately after sorting the particles on a grid. If a grid is passed as a parameter, it will compute either the number of particles in a cell or the number density in a cell depending on the value of <code>ndens_not_NP</code> field of the <code>PhysProps</code> instance passed to the function.</p><p>The <a href="../reference_public/#Merzbild.avg_props!"><code>avg_props!</code></a> function can also be used to time-average physical properties; this requires use of two <code>PhysProps</code> instances, one of which holds the values of the physical properties at the current timestep, and the other one holds the values of the averaged physical properties. Similarly to the previous case, trying to average one <code>PhysProps</code> instance &quot;into&quot; another <code>PhysProps</code> instance with a different value of the <code>ndens_not_NP</code> field will raise an error.</p><p>The total moment of order <span>$N$</span> is defined as</p><p class="math-container">\[M_{N} = \frac{1}{\sum_i w_i}\sum_i w_i \left(v_{x,i}^2+v_{y,i}^2+v_{z,i}^2\right)^{\frac{N}{2}}.\]</p><p>Here the summation is over all particles of a specific species in a particular grid cell. Since computing the moments is expensive, a different function needs to be called to compute all the physical properties <strong>and</strong> the moments: <a href="../reference_public/#Merzbild.compute_props_with_total_moments!"><code>compute_props_with_total_moments!</code></a>. If it is called and a <code>PhysProps</code> instance with <code>n_moments = 0</code> is passed to it, it will fall back to the standard <a href="../reference_public/#Merzbild.compute_props!"><code>compute_props!</code></a> to avoid unnecessary computations.</p><p>Support for computing mixed moments of the form </p><p class="math-container">\[M_{abc} = \frac{1}{\sum_i w_i}\sum_i w_i v_{x,i}^a v_{y,i}^b v_{z,i}^c\]</p><p>is planned in future versions of Merzbild.jl.</p><p><strong>NOTE</strong>: the computation of total moments is planned to be decoupled from <code>PhysProps</code> and moved into a separate structure.</p><h2 id="Writing-output:-NCDataHolder"><a class="docs-heading-anchor" href="#Writing-output:-NCDataHolder">Writing output: NCDataHolder</a><a id="Writing-output:-NCDataHolder-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-output:-NCDataHolder" title="Permalink"></a></h2><p>Finally, once the properties have been computed, we need to output them. Merzbild.jl uses the binary <a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a> format for its output, specifically the NetCDF4 version of the format. The functionality is provided by the <a href="https://github.com/JuliaGeo/NetCDF.jl">NetCDF.jl</a> and <a href="https://github.com/Alexander-Barth/NCDatasets.jl">NCDatasets.jl</a> libraries. The testing code relies on NCDatasets.jl as originally Merzbild.jl used the library throughout the whole code; however, the NetCDF.jl library was found to be significantly faster when used for output, so all the non-testing code has been ported to NetCDF.jl. The NCDatasets.jl dependency will be dropped in a future version once tests are ported to NetCDF.jl.</p><p>In order to write the physical properties to a NetCDF file, one needs to create an <code>NCDataHolder</code> instance. It keeps track of the variables being output, the file handle, and the number of times data has been written to a file. It also keeps track of whether the <code>ndens</code> output variable actually corresponds to the number of particles in a cell or to the number density in a cell, based on the flag in the <code>PhysProps</code> instance used to initialize the <code>NCDataHolder</code> instance. (In a future version of Merzbild.jl, it is planned to change the output variable name based on the <code>ndens_not_Np</code> flag value in the <code>PhysProps</code> instance used in the constructor.)</p><p>We can construct an <code>NCDataHolder</code> instance like this:</p><pre><code class="language-julia hljs">NCDataHolder(&quot;output_filename.nc&quot;, species_data, phys_props)</code></pre><p>Additional global attributes can be written to the file if they are passed as a dictionary using the <code>global_attributes</code> keyword of the constructor. Additionally, it is possible to pass a list of variable names that should be skipped during output (i.e. they won&#39;t be written to the NetCDF file), a more detailed description is given in the <a href="../reference_public/#Merzbild.jl-public-API-reference">public API reference</a>.</p><p>In order to write the physical properties to a file at a certain timestep, we need to call</p><pre><code class="language-julia hljs">write_netcdf(ds, phys_props, timestep)</code></pre><p>Here <code>ds</code> is the <code>NCDataHolder</code> instance, and timestep is the number of the timestep of the simulation (it also gets written to the output). Additionally, the <code>sync_freq</code> keyword parameter can be set to control how often the file is flushed (synchronized) to disk.</p><p>Finally, at the end of the simulation we need to close the file, so we call</p><pre><code class="language-julia hljs">close_netcdf(ds)</code></pre><h2 id="Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps"><a class="docs-heading-anchor" href="#Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps">Computing surface properties due to particle-surface interactions: SurfProps</a><a id="Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps" title="Permalink"></a></h2><p>Details on calculation of surface properties due to particle-surface interactions can be found in the section on <a href="../overview_1d/#1D-DSMC-simulations">1D DSMC simulations</a>. Time-averaging works exactly the same as for <code>PhysProps</code>, via use of the <code>avg_props</code> function. Output is performed similarly, via an <code>NCDataHolderSurf</code> struct and calls to <code>write_netcdf_surf_props</code>.</p><h2 id="Example:-bringing-it-all-together"><a class="docs-heading-anchor" href="#Example:-bringing-it-all-together">Example: bringing it all together</a><a id="Example:-bringing-it-all-together-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-bringing-it-all-together" title="Permalink"></a></h2><p>An example of particle sampling, property computation, and output for a 0-D single-species gas is presented here.</p><pre><code class="language-julia hljs">using Merzbild
using Random

# set our random seed for reproducibility
seed = 1
Random.seed!(seed)
rng = Xoshiro(seed)

# load particle data
particles_data_path = joinpath(&quot;data&quot;, &quot;particles.toml&quot;)
species_data = load_species_data(particles_data_path, &quot;Ar&quot;)

# init particle vector for a 1000 particles
n_particles = 1000
particles = [ParticleVector(n_particles)]

# set number density to 1e23
ndens = 1e23

# and compute the particle weight Fnum
Fnum = ndens / n_particles

# set particle temperature
T = 500.0

# create the particle indexer array for 1 cell and 1 species, assume 0 particles since we haven&#39;t
# sampled any particles yet
pia = ParticleIndexerArray(0)

# sample particles in a [0.0, 1.0]x[0.0, 1.0]x[0.0, 1.0] cell
sample_particles_equal_weight!(rng, particles[1], pia, 1, 1, n_particles, T, species_data[1].mass, Fnum,
                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0; distribution=:Maxwellian)

# create struct for computation of physical properties
phys_props = PhysProps(pia)

# create struct for netCDF output
ds = NCDataHolder(&quot;output.nc&quot;, species_data, phys_props)

# compute physical properties 
compute_props!(particles, pia, species_data, phys_props)

# and output them (t=0)
write_netcdf_phys_props(ds, phys_props, 0)
close_netcdf(ds)</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>Now we have an overview of how to</p><ol><li>Create a structure to hold particles</li><li>Index the vector of particles</li><li>Load species&#39; data</li><li>Sample particles from a distribution</li><li>Compute macroscopic physical properties</li><li>Output these properties to disk</li></ol><p>In the next section, an overview of how to simulate collisions will be given.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview_capabilities/">« Overview of capabilities</a><a class="docs-footer-nextpage" href="../overview_fixedweight/">Fixed-weight DSMC simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 10:08">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
