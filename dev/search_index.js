var documenterSearchIndex = {"docs":
[{"location":"overview_capabilities/#Overview-of-capabilities","page":"Overview of capabilities","title":"Overview of capabilities","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"This page provides an overview of the main capabilities of the code.","category":"page"},{"location":"overview_capabilities/#Grids,-fixed-and-variable-weight-DSMC","page":"Overview of capabilities","title":"Grids, fixed and variable weight DSMC","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":" 0D 1D\nFixed-weight DSMC ✅ ✅\nVariable-weight DSMC ✅ ❌","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Currently, simulations are either 0D (spatially homogeneous) or on a uniform 1D grid. For 1D simulations, specular and diffuse reflection models are available (along with a mixture of the two via an accommodation coefficient).","category":"page"},{"location":"overview_capabilities/#Collisions","page":"Overview of capabilities","title":"Collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The No-Time-Counter (NTC) approach of Bird (1994) is implemented for fixed-weight DSMC. The variable-weight NTC approach of Schmidt and Rutland (2000) is implemented for variable-weight DSMC.","category":"page"},{"location":"overview_capabilities/#Fokker-Planck-collisions","page":"Overview of capabilities","title":"Fokker-Planck collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"As an alternative to DSMC, one can use the stochastic Fokker-Planck algorithm to simulate the particle collisions. Currently, the linear Fokker-Planck model of Gorhi, Torrilhon, and Jenny (2011) is implemented for fixed-weight particles.","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":" Linear Cubic\nFixed-weight Fokker-Planck ✅ ❌\nVariable-weight Fokker-Planck ❌ ❌","category":"page"},{"location":"overview_capabilities/#Particle-merging-algorithms","page":"Overview of capabilities","title":"Particle merging algorithms","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The following particle merging algorithms are available for variable-weight DSMC simulations:","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"A grid-based merging algorithm as described in Oblapenko et al. (2020) (see also TODO?)\nThe octree merging algorithm of Martin and Cambier (2016)\nA Non-Negative Least Squares (NNLS)-based merging approach (see Solving Least Squares Problems for a description of the general NNLS method)","category":"page"},{"location":"overview_capabilities/#Cross-sections","page":"Overview of capabilities","title":"Cross-sections","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The Variable-Hard Sphere (VHS) model is implemented for collisions of neutral particles. For neutral-electron collisions, LXCat data in XML format needs to be provided for the elastic scattering and electron-impact ionization cross-sections. Currently, only isotropic scattering is implemented for neutral-electron collisions.","category":"page"},{"location":"overview_capabilities/#Inelastic-collisions","page":"Overview of capabilities","title":"Inelastic collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"In flows with neutrals, ions, and electrons, electron-impact ionization is supported. Variable weight DSMC simulations also support the Event Splitting (ES) collision algorithm of Oblapenko et al. (2022).","category":"page"},{"location":"overview_capabilities/#External-fields","page":"Overview of capabilities","title":"External fields","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Acceleration of charged particles by a constant electric field is supported.","category":"page"},{"location":"overview_capabilities/#I/O","page":"Overview of capabilities","title":"I/O","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The code assumes the TOML format for the particle and VHS interaction data. XML is used for the LXCat data. Output of the computed macroscopic properties is in NetCDF4 format.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here, some speed comparisons with other codes will be presented for several reference test cases.","category":"page"},{"location":"reference_public/#Merzbild.jl-public-API-reference","page":"Public API reference","title":"Merzbild.jl public API reference","text":"","category":"section"},{"location":"reference_public/#Particles","page":"Public API reference","title":"Particles","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"Particle\nParticleVector","category":"page"},{"location":"reference_public/#Merzbild.Particle","page":"Public API reference","title":"Merzbild.Particle","text":"The Particle struct\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleVector","page":"Public API reference","title":"Merzbild.ParticleVector","text":"The ParticleVector struct\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Particle-indexing","page":"Public API reference","title":"Particle indexing","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"ParticleIndexer\nParticleIndexerArray","category":"page"},{"location":"reference_public/#Merzbild.ParticleIndexer","page":"Public API reference","title":"Merzbild.ParticleIndexer","text":"The ParticleIndexer struct\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleIndexerArray","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"The ParticleIndexerArray struct\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Loading-species-and-interaction-data","page":"Public API reference","title":"Loading species and interaction data","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"Species\nInteraction\nload_species_data\nload_interaction_data\nload_interaction_data_with_dummy\nload_species_and_interaction_data\nload_electron_neutral_interactions","category":"page"},{"location":"reference_public/#Merzbild.Species","page":"Public API reference","title":"Merzbild.Species","text":"The Species struct\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.Interaction","page":"Public API reference","title":"Merzbild.Interaction","text":"Used to store interaction parameters for a 2-species interaction\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.load_species_data","page":"Public API reference","title":"Merzbild.load_species_data","text":"Load a vector of species data\n\n\n\n\n\nLoad a vector of species data for a single species\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_interaction_data","page":"Public API reference","title":"Merzbild.load_interaction_data","text":"Load interaction data\n\n\n\n\n\nLoad interaction data filling with dummy data if needed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_interaction_data_with_dummy","page":"Public API reference","title":"Merzbild.load_interaction_data_with_dummy","text":"Load interaction data filling with dummy data if needed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_species_and_interaction_data","page":"Public API reference","title":"Merzbild.load_species_and_interaction_data","text":"Load species and interaction data filling with dummy data if needed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_electron_neutral_interactions","page":"Public API reference","title":"Merzbild.load_electron_neutral_interactions","text":"Load electron-neutral interaction data from an LXCat-format XML file\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Sampling","page":"Public API reference","title":"Sampling","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"maxwellian\nbkw\nsample_on_grid!\nsample_maxwellian_on_grid!\nsample_particles_equal_weight!","category":"page"},{"location":"reference_public/#Merzbild.maxwellian","page":"Public API reference","title":"Merzbild.maxwellian","text":"Evaluate a Maxwell distribution with temperature T for a species with mass m     at a velocity vx vy vz\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.bkw","page":"Public API reference","title":"Merzbild.bkw","text":"Evaluate the BKW distribution with temperature T for a species with mass m     at a velocity vx vy vz at a scaled time t\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_on_grid!","page":"Public API reference","title":"Merzbild.sample_on_grid!","text":"Sample from an arbitrary distribution on a discrete velocity grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_maxwellian_on_grid!","page":"Public API reference","title":"Merzbild.sample_maxwellian_on_grid!","text":"Sample from a Maxwellian on a discrete velocity grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_particles_equal_weight!","page":"Public API reference","title":"Merzbild.sample_particles_equal_weight!","text":"Sample from a distribution for particles of a specific species in a specific cell\n\n\n\n\n\nSample particles in each cell of 1-D uniform grid given ppc\n\n\n\n\n\nSample particles in each cell of 1-D uniform grid given target number density\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Computing-macroscopic-properties","page":"Public API reference","title":"Computing macroscopic properties","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"PhysProps\nPhysProps(n_cells, n_species, moments_list; Tref=300.0)\nPhysProps(pia, moments_list; Tref=300.0)\nPhysProps(pia)\ncompute_props!\ncompute_props_with_total_moments!\ncompute_props_sorted!\navg_props!\nclear_props!","category":"page"},{"location":"reference_public/#Merzbild.PhysProps","page":"Public API reference","title":"Merzbild.PhysProps","text":"Structure to store computed physical properties in a cell\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any, Any, Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(n_cells, n_species, moments_list; Tref=300.0)\n\nConstruct physical properties given a number of cells and species\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(pia, moments_list; Tref=300.0)\n\nConstruct physical properties given a ParticleIndexerArray instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(pia)\n\nConstruct physical properties given a ParticleIndexerArray instance, no moments computed\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.compute_props!","page":"Public API reference","title":"Merzbild.compute_props!","text":"Compute PhysProps\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.compute_props_with_total_moments!","page":"Public API reference","title":"Merzbild.compute_props_with_total_moments!","text":"Compute PhysProps with total moments\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.compute_props_sorted!","page":"Public API reference","title":"Merzbild.compute_props_sorted!","text":"Compute physical properties of all species in all cells assuming the particles are sorted; moments are not computed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.avg_props!","page":"Public API reference","title":"Merzbild.avg_props!","text":"Average PhysProps\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.clear_props!","page":"Public API reference","title":"Merzbild.clear_props!","text":"Clear all data from PhysProps, for use when physical properties are averaged over timesteps and averaging over a new set of timesteps needs to be started\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Collision-computations","page":"Public API reference","title":"Collision computations","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"CollisionData\nCollisionData()\nCollisionFactors\nCollisionFactors()\nCollisionDataFP\nCollisionDataFP()\ncreate_collision_factors_array(n_species)\ncreate_collision_factors_array(n_species, n_cells)\ncreate_computed_crosssections\nestimate_sigma_g_w_max\nestimate_sigma_g_w_max!\nestimate_sigma_g_w_max_ntc_n_e!\nntc!(rng, collision_factors, collision_data, interaction, particles, pia, cell, species, Δt, V)\nntc!(rng, collision_factors, collision_data, interaction,\n              particles_1, particles_2, pia,\n              cell, species1, species2, Δt, V)\nntc_n_e!\nntc_n_e_es!\nfp!","category":"page"},{"location":"reference_public/#Merzbild.CollisionData","page":"Public API reference","title":"Merzbild.CollisionData","text":"Used to store temporary collision data for a specific collision\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionData-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionData","text":"Create empty CollisionData instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.CollisionFactors","page":"Public API reference","title":"Merzbild.CollisionFactors","text":"Struct to store NTC-related collision factors\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionFactors-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionFactors","text":"Create a CollisionFactors instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.CollisionDataFP","page":"Public API reference","title":"Merzbild.CollisionDataFP","text":"Used to store Fokker-Planck collision data\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionDataFP-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionDataFP","text":"Create empty CollisionDataFP instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"Create collision factors for all interaction pairs for a 0-D case (1 spatial cell)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"Create collision factors for all interaction pairs for a non 0-D case\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_computed_crosssections","page":"Public API reference","title":"Merzbild.create_computed_crosssections","text":"Create a vector of ComputedCrossSections instances\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max","text":"Estimate (sigma g w)_max for a two-species interaction\n\n\n\n\n\nEstimate (sigma g w)_max for a single-species interaction\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max!","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max!","text":"Estimate (sigma g w)_max for all species\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max_ntc_n_e!","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max_ntc_n_e!","text":"Estimate (sigma g w)_max for an electron-neutral interaction by stochastically choosing particle pairs\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.ntc!-NTuple{10, Any}","page":"Public API reference","title":"Merzbild.ntc!","text":"Perform elastic collisions between particles of same species using the NTC algorithm\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ntc!-NTuple{12, Any}","page":"Public API reference","title":"Merzbild.ntc!","text":"Perform elastic collisions between particles of different species using the NTC algorithm\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ntc_n_e!","page":"Public API reference","title":"Merzbild.ntc_n_e!","text":"Perform elastic scattering and ionizing collisions for electron-neutral interactions\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.ntc_n_e_es!","page":"Public API reference","title":"Merzbild.ntc_n_e_es!","text":"Perform elastic scattering and ionizing collisions for electron-neutral interactions     using the event splitting approach of Oblapenko et al. (2022)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.fp!","page":"Public API reference","title":"Merzbild.fp!","text":"Model single-species elastic collisions using a linear Fokker-Planck approximation \n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merging","page":"Public API reference","title":"Merging","text":"","category":"section"},{"location":"reference_public/#Grid-merging","page":"Public API reference","title":"Grid merging","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"GridN2Merge\nGridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::T) where T <: AbstractArray\nGridN2Merge(N::Int, extent_multiplier::T) where T <: AbstractArray\nGridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::Float64)\nGridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier_x::Float64, extent_multiplier_y::Float64, extent_multiplier_z::Float64)\nGridN2Merge(N::Int, extent_multiplier::Float64)\nmerge_grid_based!","category":"page"},{"location":"reference_public/#Merzbild.GridN2Merge","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"Struct for merging on a velocity grid\n\nFields:\n\nNx: number of cells\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, Int64, Int64, T}} where T<:AbstractArray","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::T) where T <: AbstractArray\n\nCreate velocity grid-based merging\n\nPositional arguments:\n\nNx: number of cells in vx direction\nNy: number of cells in vy direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, T}} where T<:AbstractArray","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(N::Int, extent_multiplier::T) where T <: AbstractArray\n\nCreate velocity grid-based merging with equal number of cells in each direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::Float64)\n\nCreate velocity grid-based merging with single multiplier\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64, Float64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int,\n            extent_multiplier_x::Float64,\n            extent_multiplier_y::Float64,\n            extent_multiplier_z::Float64)\n\nCreate velocity grid-based merging\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(N::Int, extent_multiplier::Float64)\n\nCreate velocity grid-based merging with equal number of cells in each direction, single multiplier\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.merge_grid_based!","page":"Public API reference","title":"Merzbild.merge_grid_based!","text":"Merge particles using a velocity grid-based merging approach\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#NNLS-merging","page":"Public API reference","title":"NNLS merging","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"NNLSMerge\nNNLSMerge(multi_index_moments, init_np; rate_preserving=false)\ncompute_multi_index_moments\nmerge_nnls_based!\nmerge_nnls_based_rate_preserving!","category":"page"},{"location":"reference_public/#Merzbild.NNLSMerge","page":"Public API reference","title":"Merzbild.NNLSMerge","text":"Struct for keeping track of merging-related quantities for NNLS merging\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.NNLSMerge-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.NNLSMerge","text":"NNLSMerge(multi_index_moments, init_np; rate_preserving=false)\n\nCreate NNLS-based merging\n\nPositional arguments:\n\nmulti_index_moments: vector of mixed moments to preserve, [(i1, j1, k1), (i2, j2, k2), ...] Mass/momentum/directionalenergy are always conserved! (Added automatically if not in list)\ninit_np: initial number of particles to pre-allocated memory for\n\nKeyword arguments:\n\nrate_preserving: used for rate-preserving merging of electrons, preserves approximate elastic collision and ionization rates\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.compute_multi_index_moments","page":"Public API reference","title":"Merzbild.compute_multi_index_moments","text":"Compute all mixed moments of total order up to n\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.merge_nnls_based!","page":"Public API reference","title":"Merzbild.merge_nnls_based!","text":"Perform NNLS-based merging\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.merge_nnls_based_rate_preserving!","page":"Public API reference","title":"Merzbild.merge_nnls_based_rate_preserving!","text":"Perform NNLS-based merging, rate-preserving version\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Octree-merging","page":"Public API reference","title":"Octree merging","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"Merzbild.OctreeBinSplit\nMerzbild.OctreeInitBin\nMerzbild.OctreeBinBounds\nOctreeN2Merge\nOctreeN2Merge(split::Merzbild.OctreeBinSplit;\n              init_bin_bounds=OctreeInitBinMinMaxVel,\n              bin_bounds_compute=OctreeBinBoundsInherit,\n              max_Nbins=4096, max_depth=10)","category":"page"},{"location":"reference_public/#Merzbild.OctreeBinSplit","page":"Public API reference","title":"Merzbild.OctreeBinSplit","text":"OctreeBinSplit OctreeBinMidSplit=1 OctreeBinMeanSplit=2 OctreeBinMedianSplit=3\n\nEnum for octree bin splitting types\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeInitBin","page":"Public API reference","title":"Merzbild.OctreeInitBin","text":"OctreeInitBin OctreeInitBinMinMaxVel=1 OctreeInitBinMinMaxVelSym=2 OctreeInitBinC=3\n\nEnum for initial bin bounds\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeBinBounds","page":"Public API reference","title":"Merzbild.OctreeBinBounds","text":"OctreeBinBounds OctreeBinBoundsInherit=1 OctreeBinBoundsRecompute=2\n\nComputation of bounds of split bin\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeN2Merge","page":"Public API reference","title":"Merzbild.OctreeN2Merge","text":"Struct for N:2 Octree merging\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeN2Merge-Tuple{Merzbild.OctreeBinSplit}","page":"Public API reference","title":"Merzbild.OctreeN2Merge","text":"OctreeN2Merge(split::OctreeBinSplit; init_bin_bounds=OctreeInitBinMinMaxVel, bin_bounds_compute=OctreeBinBoundsInherit,\n          max_Nbins=4096, max_depth=10)\n\nCreate Octree N:2 merging\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Grids-and-particle-sorting","page":"Public API reference","title":"Grids and particle sorting","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"Grid1DUniform\nGridSortInPlace\nsort_particles!","category":"page"},{"location":"reference_public/#Merzbild.Grid1DUniform","page":"Public API reference","title":"Merzbild.Grid1DUniform","text":"1-D Uniform grid\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.GridSortInPlace","page":"Public API reference","title":"Merzbild.GridSortInPlace","text":"Struct for in-place sorting of particles\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.sort_particles!","page":"Public API reference","title":"Merzbild.sort_particles!","text":"Sort particles on a grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-movement","page":"Public API reference","title":"Particle movement","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"convect_particles!","category":"page"},{"location":"reference_public/#Merzbild.convect_particles!","page":"Public API reference","title":"Merzbild.convect_particles!","text":"Convect particles on 1-D uniform grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-surface-interactions","page":"Public API reference","title":"Particle-surface interactions","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"MaxwellWallBC\nMaxwellWalls1D\nMaxwellWalls1D(species_data, T_l::Float64, T_r::Float64, vy_l::Float64, vy_r::Float64, accomodation_l::Float64,          \n    accomodation_r::Float64)","category":"page"},{"location":"reference_public/#Merzbild.MaxwellWallBC","page":"Public API reference","title":"Merzbild.MaxwellWallBC","text":"A struct to hold information about a diffuse reflecting wall\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.MaxwellWalls1D","page":"Public API reference","title":"Merzbild.MaxwellWalls1D","text":"A struct to hold information about all diffuse reflecting walls in the simulation\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.MaxwellWalls1D-Tuple{Any, Vararg{Float64, 6}}","page":"Public API reference","title":"Merzbild.MaxwellWalls1D","text":"Create a MaxwellWalls struct for a 1-D simulation with 2 walls (\"left\" and \"right)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#I/O","page":"Public API reference","title":"I/O","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"write_grid\nIOSkipList\nIOSkipList(list_of_variables_to_skip)\nIOSkipList()\nNCDataHolder\nNCDataHolder(nc_filename, names_skip_list, species_data, phys_props; global_attributes=Dict{Any,Any}())\nNCDataHolder(nc_filename, species_data, phys_props; global_attributes=Dict{Any,Any}())\nclose_netcdf\nwrite_netcdf_phys_props","category":"page"},{"location":"reference_public/#Merzbild.write_grid","page":"Public API reference","title":"Merzbild.write_grid","text":"Write info to a NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.IOSkipList","page":"Public API reference","title":"Merzbild.IOSkipList","text":"Struct that holds track of which variables are not to be written to NetCDF file\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.IOSkipList-Tuple{Any}","page":"Public API reference","title":"Merzbild.IOSkipList","text":"IOSkipList(list_of_variables_to_skip)\n\nConstruct an IOSkipList from a list of variable names\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.IOSkipList-Tuple{}","page":"Public API reference","title":"Merzbild.IOSkipList","text":"IOSkipList()\n\nConstruct an empty IOSkipList\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolder","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"Struct that holds NetCDF-output related data\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.NCDataHolder-NTuple{4, Any}","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"NCDataHolder(nc_filename, names_skip_list, species_data, phys_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolder instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolder-Tuple{Any, Any, Any}","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"NCDataHolder(nc_filename, species_data, phys_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolder instance with an empty list of variable to skip\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.close_netcdf","page":"Public API reference","title":"Merzbild.close_netcdf","text":"Close NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.write_netcdf_phys_props","page":"Public API reference","title":"Merzbild.write_netcdf_phys_props","text":"Write PhysProps to NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-in-Cell","page":"Public API reference","title":"Particle-in-Cell","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"accelerate_constant_field_x!","category":"page"},{"location":"reference_public/#Merzbild.accelerate_constant_field_x!","page":"Public API reference","title":"Merzbild.accelerate_constant_field_x!","text":"Accelerate particles with a constant electric field in the X direction\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Constants","page":"Public API reference","title":"Constants","text":"","category":"section"},{"location":"reference_public/","page":"Public API reference","title":"Public API reference","text":"k_B","category":"page"},{"location":"reference_public/#Merzbild.k_B","page":"Public API reference","title":"Merzbild.k_B","text":"Boltzmann constant, J/K\n\n\n\n\n\n","category":"constant"},{"location":"overview_fixedweight/#Fixed-weight-DSMC-simulations","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now that we can load species data, sample and index particles and compute macroscopic properties, we now look at performing collisions. Currently, the No Time Counter (NTC) algorithm of Bird is implemented for fixed-weight DSMC simulations.","category":"page"},{"location":"overview_fixedweight/#Loading-interaction-data:-Interaction","page":"Fixed-weight DSMC simulations","title":"Loading interaction data: Interaction","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"First, we need to load interaction data for the species the collisions of which we want to model. This data includes things like the collision-reduced mass and VHS parameters. The VHS parameters are collision species pair-specific. These data are stored in an Interaction instance. These Interaction instances are stored in a n_species x n_species matrix, where the (i,j)-th element contains the interaction data for collisions of particles of species i with  particles of species j.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"We can use the load_interaction_data function to create such a matrix of Interaction instances. It which reads a TOML file with the relevant interaction information, and uses the (already loaded) species data to compute quantities such as the collision-reduced mass. One can also use load_interaction_data_with_dummy function, which will not throw an error in case data for a specific interaction is missing in the TOML file, but will just create an interaction using the passed dummy parameters. This is relevant for electron-neutral interactions, for example, since  VHS collision parameters don't really make sense for such interactions, but are required to fill in the fields.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"An additional utility function load_species_and_interaction_data is also available, which loads both the species' and interaction data for those species at the same time.","category":"page"},{"location":"overview_fixedweight/#Storing-intermediate-collision-data:-CollisionData","page":"Fixed-weight DSMC simulations","title":"Storing intermediate collision data: CollisionData","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"During collisions, multiple vector quantities (such as the center of mass velocity, pre- and post-collision relative velocity) are computed for multiple collision pairs. In order to avoid excessive allocations and keep track of these quantities, the CollisionData structure exists. It does not need to be initialized in any special way; an instance of CollisionData must be created and simply passed to the collision routine, which will use it as required.","category":"page"},{"location":"overview_fixedweight/#NTC-specific-data:-CollisionFactors","page":"Fixed-weight DSMC simulations","title":"NTC-specific data: CollisionFactors","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"The No-Time Counter (NTC) collision algorithm requires an estimate of (sigma g w)_max for each species pair for each cell in the flow. The CollisionFactors data structure stores the values of this factor, as well as  other NTC-related parameters (number of collisions performed, number of collision partners). One needs to initialize a 3-dimensional array of CollisionFactors of shape  n_species x n_species x n_cells in order to store the required factors for each species' pair for all cells in the flow; this is done by calling create_collision_factors_array(n_species, n_cells). Some initial estimate for the values of (sigma g w)_max; the simplest way to do so for a fixed-weight DSMC simulation is to call the estimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0) function.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"This will pre-compute  (sigma g w)_max based on a list of temperatures for each species by computing the average thermal velocities and calculating the value of the VHS collision cross-section:","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"g_thermal1 = sqrt(2 * T1 * k_B / species1.mass)\ng_thermal2 = sqrt(2 * T2 * k_B / species2.mass)\ng_thermal = 0.5 * (g_thermal1 + g_thermal2)\nreturn mult_factor * sigma_vhs(interaction, g_thermal) * g_thermal * Fnum","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Here mult_factor (default value of 1.0) is used to optionally increase or decrease the computed estimate; and the value w is assumed to be constant and is designated by Fnum. This approach computes the same value of (sigma g w)_max for all the cells in the domain; however, unless an initial condition with large gradients is used, this should not be an issue.","category":"page"},{"location":"overview_fixedweight/#NTC-collisions","page":"Fixed-weight DSMC simulations","title":"NTC collisions","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now that the interaction data has been loaded, the CollisionData instance to store intermediate collision-related quantities has been instantiated, the 3-dimensional array of CollisionFactors has been created, and the (sigma g w)_max values precomputed, one can perform collisions.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Single-species elastic VHS collisions can be performed by calling ntc!(rng, collision_factors, collision_data, interaction, particles, pia, cell, species, Δt, V). Here collision_factors is the specific instance of CollisionFactors, i.e. a specific element of the 3-dimensional array of CollisionFactors. Δt is the timestep, and V is the volume of the physical cell (for spatially homogeneous simulations this can be set to 1.0).","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Multi-species elastic VHS collisions are performed in a similar fashion, by calling ntc!(rng, collision_factors, collision_data, interaction, particles_1, particles_2, pia, cell, species1, species2, Δt, V).","category":"page"},{"location":"overview_fixedweight/#Example:-bringing-it-all-together","page":"Fixed-weight DSMC simulations","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"An example of computation of collisions for a two-species mixture is presented here.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\nspecies_data = load_species_data(\"data/particles.toml\", [\"Ar\", \"He\"])\nn_species = length(species_data)\n\n# number of timesteps to run simulation for\nn_t = 5000\n\n# we will have the number density of argon = 1e15, the number density of helium = 5e15\nn_particles_Ar = 2000\nn_particles_He = 10000\nFnum = 5e11\n\n# initial temperatures\nT0_Ar = 300.0\nT0_He = 2000.0\nT0_list = [T0_Ar, T0_He]\n\n# create the 2-element Vector of ParticleVectors for the 2 species\nparticles = [ParticleVector(n_particles_Ar), ParticleVector(n_particles_He)]\n\n# create the 2-species 1-cell particle indexer array filled with zeros\n# as we haven't sampled any particles yet\npia = ParticleIndexerArray([0, 0])\n\n# sample particles from a Maxwellian distribution\nsample_particles_equal_weight!(rng, particles[1], pia, 1, 2, n_particles_Ar,\n                               species_data[1].mass, T0_Ar, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\nsample_particles_equal_weight!(rng, particles[2], pia, 1, 2, n_particles_He,\n                               species_data[2].mass, T0_He, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\n\n\n# create the PhysProps instance to store computed properties\nphys_props = PhysProps(1, 2, [], Tref=T0_Ar)\n\n# create struct for I/O\nds = NCDataHolder(\"2species.nc\", species_data, phys_props)\n\n# compute and write physical properties at t=0\ncompute_props!(particles, pia, species_data, phys_props)\nwrite_netcdf_phys_props(ds, phys_props, 0)\n\n# load interaction data\ninteraction_data = load_interaction_data(\"data/vhs.toml\", species_data)\n\n# create the 3-D array of collision factors\ncollision_factors::Array{CollisionFactors, 3} = create_collision_factors_array(n_species)\n\n# create the structure to store temporary collision data\ncollision_data = CollisionData()\n\n# estimate  (σ(g) * g * w)_max\nestimate_sigma_g_w_max!(collision_factors, interaction_data, species_data, T0_list, Fnum)\n\n# set our timestep\nΔt = 2.5e-3\n\n# set cell volume to 1.0 as we're doing a 0-D simulation\nV = 1.0\n\nfor ts in 1:n_t  # loop over time\n    for s2 in 1:n_species  # loop over first species\n        for s1 in s2:n_species  # loop over second species\n            if (s1 == s2)\n                # collisions between particles of same species\n                ntc!(rng, collision_factors[s1,s1,1], collision_data,\n                     interaction_data, particles[s1], pia, 1, s1, Δt, V)\n            else\n                # collisions between particles of different species\n                ntc!(rng, collision_factors[s1,s2,1], collision_data,\n                     interaction_data, particles[s1], particles[s2],\n                     pia, 1, s1, s2, Δt, V)\n            end\n        end\n    end\n\n    # we don't do convection, so we can take advantage of the fact that the particles stay sorted\n    # and compute the physical properties slightly faster without having to sort the particles\n    compute_props_sorted!(particles, pia, species_data, phys_props)\n\n    # write to output\n    write_netcdf_phys_props(ds, phys_props, ts)\nend\n\n# close output file\nclose_netcdf(ds)","category":"page"},{"location":"overview_fixedweight/#Summary","page":"Fixed-weight DSMC simulations","title":"Summary","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now we have an overview of how to","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Load interaction-related data\nEstimate the factor required for the NTC collision algorithm\nPerform elastic collisions between particles of alike and unalike species","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"In the next section, an overview of simulating collisions with variable-weight particles will be given.","category":"page"},{"location":"overview_fp/#Fokker-Planck-simulations","page":"Fokker-Planck simulations","title":"Fokker-Planck simulations","text":"","category":"section"},{"location":"overview_fp/","page":"Fokker-Planck simulations","title":"Fokker-Planck simulations","text":"Under construction","category":"page"},{"location":"reference_internal/#Merzbild.jl-internal-API-reference","page":"Internal API reference","title":"Merzbild.jl internal API reference","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"The public API functions are exported by the module","category":"page"},{"location":"reference_internal/#Particle-indexing","page":"Internal API reference","title":"Particle indexing","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.map_cont_index\nMerzbild.update_particle_indexer_new_lower_count\nMerzbild.update_particle_indexer_new_particle\nBase.getindex\nBase.setindex!\nBase.length\nBase.resize!\nMerzbild.update_particle_buffer_new_particle(pv::ParticleVector, position)\nMerzbild.update_particle_buffer_new_particle(pv::ParticleVector, pia, species)\nMerzbild.update_particle_buffer_new_particle(pv::Vector{Particle}, pia, species)\nMerzbild.update_particle_buffer_new_particle(pv::Vector{Particle}, position)","category":"page"},{"location":"reference_internal/#Merzbild.map_cont_index","page":"Internal API reference","title":"Merzbild.map_cont_index","text":"map a continuous index in [0, n_local-1] to an index in the particle array given particle_indexer struct describing the split\n\n\n\n\n\nmap a continuous index in [0, n_local-1] to an index in the particle array given particle_indexer struct describing the split\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_indexer_new_lower_count","page":"Internal API reference","title":"Merzbild.update_particle_indexer_new_lower_count","text":"Update particle indexer when we reduced the particle count\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_indexer_new_particle","page":"Internal API reference","title":"Merzbild.update_particle_indexer_new_particle","text":"Update particle indexer when we add a new particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.getindex","page":"Internal API reference","title":"Base.getindex","text":"Get underlying particle in ParticleVector with index i\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.setindex!","page":"Internal API reference","title":"Base.setindex!","text":"Set underlying particle in ParticleVector with index i to a new particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.length","page":"Internal API reference","title":"Base.length","text":"Get length of a ParticleVector` instance\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.resize!","page":"Internal API reference","title":"Base.resize!","text":"Resize a ParticleVector` instance\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle-Tuple{ParticleVector, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle","text":"Update the buffer of unused Particles in a ParticleVector instance\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle-Tuple{ParticleVector, Any, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle","text":"Update the buffer of unused Particles in a ParticleVector instance\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle-Tuple{Vector{Particle}, Any, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle","text":"Dummy function in case Vector{Particle} is used and not a ParticleVector`\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle-Tuple{Vector{Particle}, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle","text":"Dummy function in case Vector{Particle} is used and not a ParticleVector`\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Loading-species-and-interaction-data","page":"Internal API reference","title":"Loading species and interaction data","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.find_species_in_db\nMerzbild.load_elastic_data\nMerzbild.load_ionization_data\nMerzbild.compute_mu_ref","category":"page"},{"location":"reference_internal/#Merzbild.find_species_in_db","page":"Internal API reference","title":"Merzbild.find_species_in_db","text":"Find a chemical species in an LXCat-format XML file\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.load_elastic_data","page":"Internal API reference","title":"Merzbild.load_elastic_data","text":"Load elastic electron-neutral scattering data from an LXCat-format XML file\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.load_ionization_data","page":"Internal API reference","title":"Merzbild.load_ionization_data","text":"Load electron-impact ionization data from an LXCat-format XML file\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_mu_ref","page":"Internal API reference","title":"Merzbild.compute_mu_ref","text":"Compute reference viscosity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Sampling","page":"Internal API reference","title":"Sampling","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.create_unit_dvgrid\nMerzbild.create_noiseless_dvgrid\nMerzbild.create_vdf\nMerzbild.sample_bkw!\nMerzbild.evaluate_distribution_on_grid!\nMerzbild.sample_maxwellian_single!\nMerzbild.sample_maxwellian!","category":"page"},{"location":"reference_internal/#Merzbild.create_unit_dvgrid","page":"Internal API reference","title":"Merzbild.create_unit_dvgrid","text":"generate a grid with extent [-1.0,1.0]x[-1.0,1.0]x[-1.0,1.0]\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.create_noiseless_dvgrid","page":"Internal API reference","title":"Merzbild.create_noiseless_dvgrid","text":"generate a grid [-vxmax, vxmax]x[-vymax, vymax]x[-vzmax, vzmax]\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.create_vdf","page":"Internal API reference","title":"Merzbild.create_vdf","text":"create an empty VDF of size nx * ny * nz\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sample_bkw!","page":"Internal API reference","title":"Merzbild.sample_bkw!","text":"Sample from the BKW distribution with temperature T for a species with mass m     at t=0 and add a velocity offset\n\n\n\n\n\nSample from the BKW distribution with temperature T for a species with mass m     at t=0 and add a velocity offset\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.evaluate_distribution_on_grid!","page":"Internal API reference","title":"Merzbild.evaluate_distribution_on_grid!","text":"Evaluate a distribution on a discrete velocity grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sample_maxwellian_single!","page":"Internal API reference","title":"Merzbild.sample_maxwellian_single!","text":"Sample a single particle from a Maxwell distribution with temperature T for a species with mass m     and add a velocity offset\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sample_maxwellian!","page":"Internal API reference","title":"Merzbild.sample_maxwellian!","text":"Sample nparticles particles from a Maxwell distribution with temperature T for a species with mass m     and add a velocity offset\n\n\n\n\n\nSample nparticles particles from a Maxwell distribution with temperature T for a species with mass m     and add a velocity offset\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Collision-computations","page":"Internal API reference","title":"Collision computations","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.compute_n_coll_single_species\nMerzbild.compute_n_coll_two_species\nMerzbild.compute_vhs_factor\nMerzbild.compute_com!\nMerzbild.compute_g!\nMerzbild.compute_g_new_ionization!\nMerzbild.scatter_vhs!\nMerzbild.scatter_electron_vhs!\nMerzbild.scatter_ionization_electrons!\nMerzbild.sigma_vhs\nMerzbild.compute_tabulated_cs_constant_continuation\nMerzbild.compute_tabulated_cs_zero_continuation\nMerzbild.compute_cross_sections_only!\nMerzbild.compute_cross_sections!\nMerzbild.get_cs_total\nMerzbild.get_cs_elastic\nMerzbild.get_cs_ionization\nMerzbild.get_ionization_threshold\nMerzbild.get_electron_energy_split","category":"page"},{"location":"reference_internal/#Merzbild.compute_n_coll_single_species","page":"Internal API reference","title":"Merzbild.compute_n_coll_single_species","text":"Compute number of collisions, collisions between particles of same species\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_n_coll_two_species","page":"Internal API reference","title":"Merzbild.compute_n_coll_two_species","text":"Compute number of collisions, collisions between particles of different species\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_vhs_factor","page":"Internal API reference","title":"Merzbild.compute_vhs_factor","text":"Compute interaction-specific factor pi D_VHS^2 (2 T_refVHSm_r)^(omega_VHS - 05) frac1Gamma(25 - omega_VHS)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_com!","page":"Internal API reference","title":"Merzbild.compute_com!","text":"Compute center of mass velocity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_g!","page":"Internal API reference","title":"Merzbild.compute_g!","text":"Compute relative velocity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_g_new_ionization!","page":"Internal API reference","title":"Merzbild.compute_g_new_ionization!","text":"Compute post-ionization relative velocity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_vhs!","page":"Internal API reference","title":"Merzbild.scatter_vhs!","text":"Scatter two particles using VHS scattering\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_electron_vhs!","page":"Internal API reference","title":"Merzbild.scatter_electron_vhs!","text":"Scatter an electron off of a neutral particle using VHS scattering\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_ionization_electrons!","page":"Internal API reference","title":"Merzbild.scatter_ionization_electrons!","text":"Scatter two electrons\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sigma_vhs","page":"Internal API reference","title":"Merzbild.sigma_vhs","text":"Compute the VHS cross-section for a given interaction\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_tabulated_cs_constant_continuation","page":"Internal API reference","title":"Merzbild.compute_tabulated_cs_constant_continuation","text":"Compute a cross-section from tabulated data, continuing with first and last values if outside of range\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_tabulated_cs_zero_continuation","page":"Internal API reference","title":"Merzbild.compute_tabulated_cs_zero_continuation","text":"Compute a cross-section from tabulated data, continuing with 0.0 if outside of range\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_cross_sections_only!","page":"Internal API reference","title":"Merzbild.compute_cross_sections_only!","text":"Compute electron-impact ionization and excitation cross-sections, and electron-neutral elastic scattering Return collision energy in eV\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_cross_sections!","page":"Internal API reference","title":"Merzbild.compute_cross_sections!","text":"Compute electron-impact ionization and excitation cross-sections, and electron-neutral elastic scattering Plus compute total cross-section and probabilites of different processes\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_total","page":"Internal API reference","title":"Merzbild.get_cs_total","text":"Get the value of the total collision cross-section for electron-neutral interactions\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_elastic","page":"Internal API reference","title":"Merzbild.get_cs_elastic","text":"Get the value of the elastic scattering electron-neutral cross-section\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_ionization","page":"Internal API reference","title":"Merzbild.get_cs_ionization","text":"Get the value of the electron-impact ionization cross-section\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_ionization_threshold","page":"Internal API reference","title":"Merzbild.get_ionization_threshold","text":"Get the ionization threshold\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_electron_energy_split","page":"Internal API reference","title":"Merzbild.get_electron_energy_split","text":"Get the way electron energy is split during ionization\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merging","page":"Internal API reference","title":"Merging","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.GridCell\nMerzbild.compute_velocity_extent!\nMerzbild.compute_grid_index\nMerzbild.clear_merging_grid!\nMerzbild.compute_grid!\nMerzbild.compute_new_particles!\nMerzbild.vx_sign\nMerzbild.vy_sign\nMerzbild.vz_sign\nMerzbild.check_speed_bound\nMerzbild.base_multi_index_moments\nMerzbild.compute_w_total_v0!\nMerzbild.ccm\nMerzbild.compute_lhs_and_rhs!\nMerzbild.compute_lhs_and_rhs_rate_preserving!\nMerzbild.compute_lhs_particles_additional!\nMerzbild.compute_lhs_particles_additional_rate_preserving!\nMerzbild.scale_lhs_rhs!\nMerzbild.scale_lhs_rhs_rate_preserving!\nMerzbild.compute_post_merge_particles_nnls!\nMerzbild.OctreeCell\nMerzbild.OctreeFullCell\nMerzbild.fill_bins\nMerzbild.fill_full_bins\nMerzbild.clear_octree!\nMerzbild.resize_octree_buffers!\nMerzbild.compute_octant\nMerzbild.bin_bounds_inherit!\nMerzbild.bin_bounds_recompute!\nMerzbild.compute_v_mean!\nMerzbild.compute_v_median!\nMerzbild.get_new_bin_id\nMerzbild.split_bin!\nMerzbild.compute_bin_props!\nMerzbild.get_bin_post_merge_np\nMerzbild.init_octree!\nMerzbild.merge_octree_N2_based!","category":"page"},{"location":"reference_internal/#Merzbild.GridCell","page":"Internal API reference","title":"Merzbild.GridCell","text":"Struct for keeping track of merging-related quantities in a velocity grid cell\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.compute_velocity_extent!","page":"Internal API reference","title":"Merzbild.compute_velocity_extent!","text":"Compute extent of velocity grid based on temperature in the cell\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_grid_index","page":"Internal API reference","title":"Merzbild.compute_grid_index","text":"Compute index of particle on the merging grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.clear_merging_grid!","page":"Internal API reference","title":"Merzbild.clear_merging_grid!","text":"Reset merging grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_grid!","page":"Internal API reference","title":"Merzbild.compute_grid!","text":"Compute properties for all cells on the merging grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_new_particles!","page":"Internal API reference","title":"Merzbild.compute_new_particles!","text":"Compute new particles based on the grid cell properties without checking particle locations\n\n\n\n\n\nCompute post-merge particles\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vx_sign","page":"Internal API reference","title":"Merzbild.vx_sign","text":"Return sign of velocity vx of an octant in velocity space\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vy_sign","page":"Internal API reference","title":"Merzbild.vy_sign","text":"Return sign of velocity vy of an octant in velocity space\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vz_sign","page":"Internal API reference","title":"Merzbild.vz_sign","text":"Return sign of velocity vz of an octant in velocity space\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.check_speed_bound","page":"Internal API reference","title":"Merzbild.check_speed_bound","text":"Check speed bound\n\n\n\n\n\nCheck speed bound with multiplier\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.base_multi_index_moments","page":"Internal API reference","title":"Merzbild.base_multi_index_moments","text":"Base multi indices corresponding to conservation of mass momentum and energy components\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_w_total_v0!","page":"Internal API reference","title":"Merzbild.compute_w_total_v0!","text":"Compute total computational weight of particles and mean velocity, as well as velocity bounds\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.ccm","page":"Internal API reference","title":"Merzbild.ccm","text":"Compute unweighted centered moment\n\n\n\n\n\nCompute unweighted centered moment\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_and_rhs!","page":"Internal API reference","title":"Merzbild.compute_lhs_and_rhs!","text":"Compute LHS matrix and RHS vector for NNLS merging\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_and_rhs_rate_preserving!","page":"Internal API reference","title":"Merzbild.compute_lhs_and_rhs_rate_preserving!","text":"Compute LHS matrix and RHS vector for NNLS merging, rate-preserving version\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_particles_additional!","page":"Internal API reference","title":"Merzbild.compute_lhs_particles_additional!","text":"Compute additional LHS columns for additional particles\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_particles_additional_rate_preserving!","page":"Internal API reference","title":"Merzbild.compute_lhs_particles_additional_rate_preserving!","text":"Compute additional LHS columns for additional particles, rate preserving\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs!","text":"Scale LHS and RHS\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs_rate_preserving!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs_rate_preserving!","text":"Scale LHS and RHS, rate-preserving version\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_post_merge_particles_nnls!","page":"Internal API reference","title":"Merzbild.compute_post_merge_particles_nnls!","text":"Compute post-merge particles\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.OctreeCell","page":"Internal API reference","title":"Merzbild.OctreeCell","text":"Struct holding data needed for refinement of an octree bin\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.OctreeFullCell","page":"Internal API reference","title":"Merzbild.OctreeFullCell","text":"Octree bin properties required to merge the particles in a bin\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.fill_bins","page":"Internal API reference","title":"Merzbild.fill_bins","text":"Fill the octree bins struct with zero data\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.fill_full_bins","page":"Internal API reference","title":"Merzbild.fill_full_bins","text":"Fill the octree full bins struct with zero data\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.clear_octree!","page":"Internal API reference","title":"Merzbild.clear_octree!","text":"Reset octree\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.resize_octree_buffers!","page":"Internal API reference","title":"Merzbild.resize_octree_buffers!","text":"Resize octree buffers\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_octant","page":"Internal API reference","title":"Merzbild.compute_octant","text":"Compute octant of particle velocity relative to a v_middle`\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.bin_bounds_inherit!","page":"Internal API reference","title":"Merzbild.bin_bounds_inherit!","text":"Compute new bin bounds of sub-bin inheriting bounds of parent bin\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.bin_bounds_recompute!","page":"Internal API reference","title":"Merzbild.bin_bounds_recompute!","text":"Recompute bin bounds based on particle velocities\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_v_mean!","page":"Internal API reference","title":"Merzbild.compute_v_mean!","text":"Compute mean velocity of bin\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_v_median!","page":"Internal API reference","title":"Merzbild.compute_v_median!","text":"Compute median velocity of bin\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_new_bin_id","page":"Internal API reference","title":"Merzbild.get_new_bin_id","text":"Get index of a newly created bin\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.split_bin!","page":"Internal API reference","title":"Merzbild.split_bin!","text":"Sort particles into sub-bins, split bin, keeping track of which sub-bins particles end up in\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_bin_props!","page":"Internal API reference","title":"Merzbild.compute_bin_props!","text":"Compute properties in a bin required for merging\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_bin_post_merge_np","page":"Internal API reference","title":"Merzbild.get_bin_post_merge_np","text":"Get number of post-merge particles in a bin\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.init_octree!","page":"Internal API reference","title":"Merzbild.init_octree!","text":"Initialize the top bin in an octree\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.merge_octree_N2_based!","page":"Internal API reference","title":"Merzbild.merge_octree_N2_based!","text":"Perform N:2 merging\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Grids","page":"Internal API reference","title":"Grids","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.Cell1D\nMerzbild.get_cell","category":"page"},{"location":"reference_internal/#Merzbild.Cell1D","page":"Internal API reference","title":"Merzbild.Cell1D","text":"Cell element of a 1-D grid\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.get_cell","page":"Internal API reference","title":"Merzbild.get_cell","text":"Find cell in 1-D uniform grid given coordinates of a particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Particle-surface-interactions","page":"Internal API reference","title":"Particle-surface interactions","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.specular_reflection_x!\nMerzbild.diffuse_reflection_x!\nMerzbild.reflect_particle_x!","category":"page"},{"location":"reference_internal/#Merzbild.specular_reflection_x!","page":"Internal API reference","title":"Merzbild.specular_reflection_x!","text":"Perform specular reflection of a particle in the x direction\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.diffuse_reflection_x!","page":"Internal API reference","title":"Merzbild.diffuse_reflection_x!","text":"Perform diffuse reflection of a particle in the x direction\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.reflect_particle_x!","page":"Internal API reference","title":"Merzbild.reflect_particle_x!","text":"Reflect particle in the x direction \n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Constants","page":"Internal API reference","title":"Constants","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.c_light\nMerzbild.eV\nMerzbild.eV_J\nMerzbild.eV_J_inv\nMerzbild.twopi\nMerzbild.e_mass_div_electron_volt\nMerzbild.direction_signs\nMerzbild.q_e","category":"page"},{"location":"reference_internal/#Merzbild.c_light","page":"Internal API reference","title":"Merzbild.c_light","text":"Speed of light, m/s\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV","page":"Internal API reference","title":"Merzbild.eV","text":"Electron-Volt, K\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV_J","page":"Internal API reference","title":"Merzbild.eV_J","text":"Electron-Volt, J\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV_J_inv","page":"Internal API reference","title":"Merzbild.eV_J_inv","text":"1.0/eV[J], 1/J (or equivalent to how much 1 J is equal to expressed in eV)\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.twopi","page":"Internal API reference","title":"Merzbild.twopi","text":"2 pi\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.e_mass_div_electron_volt","page":"Internal API reference","title":"Merzbild.e_mass_div_electron_volt","text":"Electron mass divided by 1 eV, kg/J\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.direction_signs","page":"Internal API reference","title":"Merzbild.direction_signs","text":"Positive and negative direction signs\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.q_e","page":"Internal API reference","title":"Merzbild.q_e","text":"Elementary charge, C\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Misc","page":"Internal API reference","title":"Misc","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.compute_thermal_velocity\nMerzbild.binary_search\nMerzbild.linear_interpolation\nMerzbild.compute_mixed_moment","category":"page"},{"location":"reference_internal/#Merzbild.compute_thermal_velocity","page":"Internal API reference","title":"Merzbild.compute_thermal_velocity","text":"compute thermal velocity: sqrt(2kTm)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.binary_search","page":"Internal API reference","title":"Merzbild.binary_search","text":"Binary search for value val in array x\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.linear_interpolation","page":"Internal API reference","title":"Merzbild.linear_interpolation","text":"Perform linear interpolation between two neighbouring values in y\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_mixed_moment","page":"Internal API reference","title":"Merzbild.compute_mixed_moment","text":"Compute mixed moment of particles in a cell\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#NNLS","page":"Internal API reference","title":"NNLS","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"Merzbild.solve!\nMerzbild.construct_householder!\nMerzbild.fastview\nMerzbild.solve_triangular_system!\nMerzbild.UnsafeVectorView\nMerzbild.orthogonal_rotmat\nMerzbild.apply_householder!","category":"page"},{"location":"reference_internal/#Merzbild.solve!","page":"Internal API reference","title":"Merzbild.solve!","text":"Algorithm NNLS: NONNEGATIVE LEAST SQUARES\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nGIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B,  COMPUTE AN N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM                  A * X = B  SUBJECT TO X .GE. 0\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.construct_householder!","page":"Internal API reference","title":"Merzbild.construct_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.fastview","page":"Internal API reference","title":"Merzbild.fastview","text":"UnsafeVectorView only works for isbitstype types. For other types, we're already allocating lots of memory elsewhere, so creating a new View is fine.\n\nThis function looks type-unstable, but the isbitstype(T) test can be evaluated by the compiler, so the result is actually type-stable.\n\n\n\n\n\nFallback for non-contiguous arrays, for which UnsafeVectorView does not make sense.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.solve_triangular_system!","page":"Internal API reference","title":"Merzbild.solve_triangular_system!","text":"The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.UnsafeVectorView","page":"Internal API reference","title":"Merzbild.UnsafeVectorView","text":"Views in Julia still allocate some memory (since they need to keep a reference to the original array). This type allocates no memory and does no bounds checking. Use it with caution.\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.orthogonal_rotmat","page":"Internal API reference","title":"Merzbild.orthogonal_rotmat","text":"COMPUTE ORTHOGONAL ROTATION MATRIX.. The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nCOMPUTE.. MATRIX   (C, S) SO THAT (C, S)(A) = (SQRT(A2+B2))                       (-S,C)         (-S,C)(B)   (   0          )    COMPUTE SIG = SQRT(A2+B2)       SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT       SIG MAY BE IN THE SAME LOCATION AS A OR B .\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.apply_householder!","page":"Internal API reference","title":"Merzbild.apply_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"overview_varweight/#Variable-weight-DSMC-simulations","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"For variable-weight DSMC simulation not much is different compared to fixed-weight DSMC simulations. Existing routines for computation of macroscopic properties, I/O, and even collisions can be re-used, since they all do not explicitly assume fixed particle weights.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"Two additional things are required, however: a way to sample particles with variable weights, and an algorithm to merge particles to avoid a blow-up of the number of particles due to collisions.","category":"page"},{"location":"overview_varweight/#Sampling-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Sampling variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"In order to obtain variable-weight particles, one can either use the sample_particles_equal_weight! multiple times with different Fnum values, or one can use the  sample_on_grid! function and its more specific version sample_maxwellian_on_grid!, as mentioned in the Overview of basic building blocks section.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"These approaches compute the values of a VDF function on a discrete velocity grid and then re-interpret the grid points and associated VDF values as particles. Thus one can get a good resolution of high-velocity tails (with the particles there having small weights). The function constructs the velocity grid via a Cartesian product of discrete grids for each velocity direction. In each direction, the interval -v_msqrt2kTmv_msqrt2kTm is discretized into nv subintervals. Here the multiplier v_m is specified by the v_mult parameter; so the discrete velocity grid spans several mean thermal velocities. In addition, only particles with a speed less than c_m sqrt2kTm are actually created, where c_m is specified by the cutoff_mult parameter. Finally, numerical noise may be added to the velocity via the noise parameter, and a velocity offset via the v_offset parameter; the spatial distribution of the particles is randomized in the cell. The function returns the total number of particles sampled (which may be less than nv^3 depending on the choice of the value of cutoff_mult).","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"An example of such sampling is shown below:","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# our number density\nndens = 1e23 \n\n# our temperature\nT0 = 300.0  \n\n# load species and interaction data\nspecies_data = load_species_data(\"data/particles.toml\", \"Ar\")\ninteraction_data = load_interaction_data(\"data/pseudo_maxwell.toml\", species_data)\n\n# number of velocity grid points in each velocity direction\nnv = 20  \n\n# some initial guess on # of particles in simulation\nnp_base = 40^3  \n\nparticles = [ParticleVector(np_base)]\n\n# sample from a BKW distribution at t=0\nvdf0 = (vx, vy, vz) -> bkw(vx, vy, vz, species_data[1].mass, T0, 0.0)\n\n# returns number of particles sampled\nn_sampled = sample_on_grid!(rng, vdf0, particles[1], nv, species_data[1].mass, T0, ndens,\n                            0.0, 1.0, 0.0, 1.0, 0.0, 1.0;\n                            v_mult=3.5, cutoff_mult=3.5, noise=0.0, v_offset=[0.0, 0.0, 0.0])\n\n# create the ParticleIndexerArray\npia = ParticleIndexerArray(n_sampled)","category":"page"},{"location":"overview_varweight/#Colliding-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Colliding variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"As mentioned above, the existing DSMC routines take care of the required particle splitting, so no specific adaptation is required for the variable-weight case. However, one needs to estimate (sigma g w)_max. The simplest approach is to use estimate_sigma_g_w_max function, but it requires a (fixed) value of Fnum - so one can simply compute it as ndens/n_sampled (i.e. the number density divided by the total number of sampled particles).","category":"page"},{"location":"overview_varweight/#Merging-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Merging variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"In order to merge variable-weight particles, one needs to set up a merging algorithm and the associated data structures and parameters. A more detailed overview of merging algorithms will appear later in a Tutorials section; here, the Octree merging approach of Martin and Cambier (2016) is used. The algorithm groups particles into bins in velocity space, recursively refining the bins until the number of post-merge particles reaches the prescribed value. It then performs an N2 merge in each bin, replacing all particles in a bin with 2 particles.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"To set up this merging algorithm, one needs to create a OctreeN2Merge instance, specifying","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"The extent of the first (root) bin - whether it accounts for the extent of the particles or whether it is just taken to be very large\nHow bins are split (along the middle velocity, the mean velocity, or the median velocity)\nWhether the velocity bounds of each sub-bin are recomputed based on the particles in the bin or are based purely on the bounds of the parent bin and the splitting velocity\nMaximum number of bins\nMaximum refinement depth","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"For example, we can create an octree merging instance that splits velocity bins across the middle, sets the root bin bounds to the bounding box of the particle velocities, and inherits the bin bounds of the parent bin when splitting a bin. We also immediately merge our particles, setting a target particle number of 100.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"# set up the merging algorithm\noc = OctreeN2Merge(OctreeBinMidSplit; init_bin_bounds=OctreeInitBinMinMaxVel,\n                   bin_bounds_compute=OctreeBinBoundsInherit, max_Nbins=6000)\n\n# set Ntarget\nNtarget = 100\n\n# perform merging\nmerge_octree_N2_based!(rng, oc, particles[1], pia, 1, 1, Ntarget)","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"We can check the number of particles after the merging procedure by looking at pia.indexer[1,1].n_local (the number of particles of species 1 in cell 1), which should be equal to 100.","category":"page"},{"location":"overview_varweight/#Example:-bringing-it-all-together","page":"Variable-weight DSMC simulations","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"Now we can put the variable-weight collisions and merging into a timestep loop, performing merging by when pia.indexer[1,1].n_local > Nthreshold, where Nthreshold is the threshold number of particles. Alternatively, one can check phys_props.np[1,1] > Nthreshold, in case the physical properties are computed frequently enough. The following simulation computes the BKW relaxation problem.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# our number density\nndens = 1e23 \n\n# our temperature\nT0 = 300.0  \n\n# load species and interaction data\nspecies_data = load_species_data(\"data/particles.toml\", \"Ar\")\ninteraction_data = load_interaction_data(\"data/pseudo_maxwell.toml\", species_data)\n\n# number of velocity grid points in each velocity direction\nnv = 20  \n\n# some initial guess on # of particles in simulation\nnp_base = 40^3  \n\nparticles = [ParticleVector(np_base)]\n\n# sample from a BKW distribution at t=0\nvdf0 = (vx, vy, vz) -> bkw(vx, vy, vz, species_data[1].mass, T0, 0.0)\n\n# returns number of particles sampled\nn_sampled = sample_on_grid!(rng, vdf0, particles[1], nv, species_data[1].mass, T0, ndens,\n                            0.0, 1.0, 0.0, 1.0, 0.0, 1.0;\n                            v_mult=3.5, cutoff_mult=3.5, noise=0.0, v_offset=[0.0, 0.0, 0.0])\n\n# create the ParticleIndexerArray\npia = ParticleIndexerArray(n_sampled)\n\n# set up the merging algorithm\noc = OctreeN2Merge(OctreeBinMidSplit; init_bin_bounds=OctreeInitBinMinMaxVel,\n                   bin_bounds_compute=OctreeBinBoundsInherit, max_Nbins=6000)\n\n# set Ntarget for merging\nNtarget = 100\n\n# set Nthreshold for merging\nNthreshold = 120\n\n# perform initial merge\nmerge_octree_N2_based!(rng, oc, particles[1], pia, 1, 1, Ntarget)\n\n# set some reference values\nsigma_ref = π * (interaction_data[1,1].vhs_d^2)\nvref = sqrt(2 * k_B * T0 / species_data[1].mass)\nLref = 1.0 / (ndens * sigma_ref)\ntref = Lref / vref\n\n# set up computation of physical properties\nphys_props = PhysProps(1, 1, [], Tref=T0)\ncompute_props!(particles, pia, species_data, phys_props)\n\nds = NCDataHolder(\"output_bkw_octree.nc\", species_data, phys_props)\nwrite_netcdf_phys_props(ds, phys_props, 0)\n\ncollision_factors = create_collision_factors_array(1)  # 1-species, 0-D\ncollision_data = CollisionData()\n\n# estimate average Fnum\nFnum = ndens/n_sampled\n\n# estimate (sigma_g_w)_max\nestimate_sigma_g_w_max!(collision_factors, interaction_data, species_data, [T0], Fnum)\n\n\n# set number of timesteps and scaled timestep\nn_t = 100\ndt_scaled = 0.025\n\n# set timestep and cell volume (0D so V=1)\nΔt = dt_scaled * tref\nV = 1.0\n\n# start time loop\nfor ts in 1:n_t\n\n    # collide\n    ntc!(rng, collision_factors[1,1,1], collision_data, interaction_data, particles[1], pia, 1, 1, Δt, V)\n\n    # check if we need to merge\n    if pia.indexer[1,1].n_local > Nthreshold\n        merge_octree_N2_based!(oc, particles[1], pia, 1, 1, Ntarget)\n    end\n    if ts % 10 == 0\n        println(\"t=$ts, np=$(pia.indexer[1,1].n_local)\")\n    end\n    \n    compute_props!(particles, pia, species_data, phys_props)\n    write_netcdf_phys_props(ds, phys_props, ts)\nend\nclose_netcdf(ds)","category":"page"},{"location":"#Merzbild.jl","page":"Home","title":"Merzbild.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Merzbild.jl is a Direct Simulation Monte Carlo (DSMC) code written purely in Julia. It provides all the necessary building blocks for building a DSMC simulation, i.e. particle indexing, collisions, file I/O. Combining these blocks together is left up to the user; examples can be found in the simulations directory. It supports variable-weight DSMC simulations and ionized flow simulations, PIC and Stochastic Fokker-Planck capabilities are in development.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goals are to provide a modular, thoroughly tested, easy-to-read and easy-to-extend code for quick implementation and testing of new ideas.","category":"page"},{"location":"#Brief-overview-of-capabilities","page":"Home","title":"Brief overview of capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently the code supports spatially homogeneous (0D) and 1D uniform grid simulations. The table below lists support for the fixed- and variable-weight versions of the code, with different supported particle merging algorithms listed for the different simulation types.","category":"page"},{"location":"","page":"Home","title":"Home","text":" 0D 1D\nFixed-weight DSMC ✅ ✅\nVariable-weight DSMC ✅ ❌\nFixed-weight Fokker-Planck Linear Linear","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more detailed overview of the capabilities is given on the Overview of capabilities page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output format is NetCDF4.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For now, Merzbild.jl needs to be cloned to be run. Once cloned, navigate to the directory, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"and in the Julia interpreter run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.resolve(); Pkg.instantiate();","category":"page"},{"location":"","page":"Home","title":"Home","text":"to install the required packages. Running Pkg.test() afterwards will install the test environment dependencies and run the tests.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the way to use the code is to","category":"page"},{"location":"","page":"Home","title":"Home","text":"clone it\ncreate a new file in the simulations directory\nadd include(\"path/to/src/merzbild.jl\") and using ..Merzbild to the file.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation assumes a certain level of pre-existing knowledge of the DSMC approach. Basic building blocks and operations (particle indexing, sampling, collisions, I/O) are covered in the Getting Started section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More specific examples (ionizing collisions, specific merging algorithms) will be published later in a Tutorials section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, a full API reference is present, split into the Merzbild.jl public API reference and Merzbild.jl internal API reference.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can for now cite the repository as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{oblapenko2024merzbild,\n  title={{M}erzbild.jl: A {J}ulia {DSMC} code},\n  author={Oblapenko, Georgii},\n  year={2024},\n  month={12},\n  howpublished={\\url{https://github.com/merzbild/Merzbild.jl}},\n  doi={10/zenodo.0}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depending on the functionality used, other citations may be warranted, please look at the Overview of capabilities page to see which algorithms and models have been implemented in Merzbild.","category":"page"},{"location":"overview_1d/#1D-DSMC-simulations","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"In this section, setting up DSMC simulations on a uniform 1D grid will be discussed. Some of the concepts and algorithms used here are also applicable to other grids (upcoming), but some things are specific to the uniform 1D grids.","category":"page"},{"location":"overview_1d/#Creating-a-grid","page":"1D DSMC simulations","title":"Creating a grid","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Creating a 1D uniform grid is very easy, as one needs to specify only the domain length L and the number of cells nx:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"grid = Grid1DUniform(L, nx)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"The Grid1DUniform structure stores additional properties such as cell volume, required for collisions.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We can also immediately create the ParticleIndexerArray instance (assuming we have a single-species flow):","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"pia = ParticleIndexerArray(grid.n_cells, 1)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"The grid information can be written to a NetCDF file by calling write_grid:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"write_grid(\"grid_info.nc\", grid)","category":"page"},{"location":"overview_1d/#Sampling-particles-in-each-cell","page":"1D DSMC simulations","title":"Sampling particles in each cell","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"To sample equal-weight particles in each cell, we need to compute the required Fnum. If we want to have ppc particles and a number density of ndens, then we can compute Fnum as (since the grid is uniform, we can use the volume of any cell for the computation)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Fnum = grid.cells[1].V * ndens / ppc","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We then initialize an array of Vector{ParticleVector} to store out particles:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"particles = [ParticleVector(n_particles)]","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"and perform the sampling:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"sample_particles_equal_weight!(rng, grid, particles[1], pia, 1,\n                               species_data, ndens, T, Fnum)","category":"page"},{"location":"overview_1d/#Particle-sorting","page":"1D DSMC simulations","title":"Particle sorting","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We will need to sort particles on the grid in case we will be convecting them; therefore a structure for particle sorting needs to be created as well. An in-place bin sorting algorithm is used, it requires an estimate of the number of particles in the simulation to pre-allocate arrays. For a fixed-weight simulation where ppc (particles per cell) are sampled in each cell at the start and no particles are created during the course of the simulation, we can compute the estimate as n_particles = ppc * nx. So we can initialize the GridSortInPlace instance like this:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"n_particles = ppc * nx\n\ngridsorter = GridSortInPlace(grid, n_particles)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"If we want to sort our particles (held in a ParticleVector instance), we can simply call","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"species_id = 1\n\n# we assume that particles has type Vector{ParticleVector} (a ParticleVector per species)\nsort_particles!(gridsorter, grid, particles[species_id], pia, species_id)","category":"page"},{"location":"overview_1d/#Creating-boundary-conditions","page":"1D DSMC simulations","title":"Creating boundary conditions","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Next, we need to create boundary conditions for the left and right walls. Currently, a diffusely reflecting wall is implemented with a user-defined accommodation coefficient (if it is equal to 0, the reflection is fully specular; if it is equal to 1, the reflection is fully diffuse).","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"This type of boundary condition (which stores the wall temperature, wall velocity, and accommodation coefficient) is described by the MaxwellWallBC structure, which should be defined for each wall.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"However, it is not intended to be defined or used directly; instead, for a 1-D simulation, a higher-level MaxwellWalls1D structure is used, which holds not only the two MaxwellWallBC instances (for the left and right walls), but also some species-wise precomputed quantities for the diffuse reflection. The MaxwellWalls1D struct assumes that the wall velocity in the x and z directions is 0, but a non-zero y velocity may be specified.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"A MaxwellWalls1D instance can be initialized like this (this will create two walls with equal temperatures and y velocities in opposite directions):","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"\nboundaries = MaxwellWalls1D(species_data, T_wall, T_wall, -v_wall, v_wall, 1.0, 1.0)","category":"page"},{"location":"overview_1d/#Performing-convection","page":"1D DSMC simulations","title":"Performing convection","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Having set up the grid and boundary conditions, we can convect particles. This is done by calling the convect_particles! function. The convection should be followed by particle sorting before any computations of physical properties are done.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"convect_particles!(rng, grid, boundaries, particles[species_id], pia, species_id, species_data, Δt)","category":"page"},{"location":"overview_1d/#Bringing-it-all-together","page":"1D DSMC simulations","title":"Bringing it all together","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Now we can combine all the pieces to set up a simulation of a single-species Couette flow in a channel with a width of 0.5 mm, discretized with 50 cells. The y-velocity of the left wall is assumed to be -500 m/s, and that of the right wall 500 m/s; the temperature of both walls is 300 K. The solution is initialized with 100 particles per cell and a number density of 5e22 1/m^3. A timestep of 2.59 ns is used. The simulation runs for 50K steps and the solution time-averaged is averaged after the first 14K steps.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"using Merzbild\nusing Random\n\n# set our random seed for reproducibility\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# set physical and discretization parameters\nT_wall = 300.0\nv_wall = 500.0\nL = 5e-4\nndens = 5e22\nnx = 50\nppc = 100\nΔt = 2.59e-9\nn_timesteps = 50000\navg_start = 14000\n\n# load particle and interaction data\nparticles_data_path = joinpath(\"data\", \"particles.toml\")\nspecies_data = load_species_data(particles_data_path, \"Ar\")\ninteraction_data_path = joinpath(\"data\", \"vhs.toml\")\ninteraction_data::Array{Interaction, 2} = load_interaction_data(interaction_data_path, species_data)\n\n# create our grid and BCs\ngrid = Grid1DUniform(L, nx)\nboundaries = MaxwellWalls1D(species_data, T_wall, T_wall, -v_wall, v_wall, 1.0, 1.0)\n\n# init particle vector, particle indexer, grid particle sorter\n# we will not be creating or destroying any particles, so we can compute the exact number\n# of particles we will have in the simulation\nn_particles = ppc * nx\nparticles = [ParticleVector(n_particles)]\npia = ParticleIndexerArray(grid.n_cells, 1)\ngridsorter = GridSortInPlace(grid, n_particles)\n\n# sample particles\n# Fnum * ppc = Np in cell = ndens * V_cell\nFnum = grid.cells[1].V * ndens / ppc\nsample_particles_equal_weight!(rng, grid, particles[1], pia, 1,\n                                species_data, ndens, T_wall, Fnum)\n\n# create collision structs\ncollision_factors = create_collision_factors_array(1, grid.n_cells)\ncollision_data = CollisionData()\n\n# create struct for computation of physical properties\nphys_props = PhysProps(pia)\n\n# create second struct for averaging of physical properties\nphys_props_avg = PhysProps(pia)\n\n# create struct for time-averaged output netCDF\nds_avg = NCDataHolder(\"couette_example.nc\",\n                        species_data, phys_props)\n\n# init collision structs\nfor cell in 1:grid.n_cells\n    collision_factors[1, 1, cell].sigma_g_w_max = estimate_sigma_g_w_max(interaction_data[1,1],\n                                                                            species_data[1], T_wall, Fnum)\nend\n\n# write out grid data\nwrite_grid(\"scratch/data/couette_$(L)_$(nx)_grid.nc\", grid)\n\n# number of timesteps we are averaging for\nn_avg = n_timesteps - avg_start + 1\n\nfor t in 1:n_timesteps\n\n    # output timestep every 1000 timesteps\n    if t % 1000 == 0\n        println(t)\n    end\n\n    # collide particles\n    for cell in 1:grid.n_cells\n        ntc!(rng, collision_factors[1, 1, cell],\n                collision_data, interaction_data, particles[1], pia, cell, 1, Δt, grid.cells[cell].V)\n    end\n\n    # convect particles\n    convect_particles!(rng, grid, boundaries, particles[1], pia, 1, species_data, Δt)\n\n    # sort particles\n    sort_particles!(gridsorter, grid, particles[1], pia, 1)\n\n    # compute props and do averaging\n    if (t >= avg_start)\n        compute_props_sorted!(particles, pia, species_data, phys_props)\n        avg_props!(phys_props_avg, phys_props, n_avg)\n    end\nend\n\nwrite_netcdf_phys_props(ds_avg, phys_props_avg, n_timesteps)\n\nclose_netcdf(ds_avg)","category":"page"},{"location":"overview_blocks/#Overview-of-basic-building-blocks","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"","category":"section"},{"location":"overview_blocks/#Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray","page":"Overview of basic building blocks","title":"Particle indexing: ParticleIndexer and ParticleIndexerArray","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"One of the main parts of the code is the ParticleIndexer struct. It contains the starting and ending indices of the particles of a single species in a single cell. During collisions, the number of the particles of a certain species in a cell may increase, either due to inelastic processes, or due to particle splitting in variable-weight collisions. These new particles are \"tacked onto\" the end of the whole array of particles of the species. Thus, each  ParticleIndexer instance potentially tracks two blocks of particles that are all in a single cell: the ones that were there before collisions were performed, and the new ones that got created during collisions and are at the end of the array.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"(Image: particle_indexer_trim)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The figure above shows a graphical representation of the meaning of some of the fields of the ParticleIndexer struct. Assume we have a set of 10 particles in 3 different cells (different cells are colour-coded), with particles 1, 2, 3, 7, 8, 9, 10 located in cell 1, particles 4, 5 located in cell 2, and particle 6 located in cell 3. The ParticleIndexer struct corresponding to cell 1 will then have the following values for its fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"particle_indexer_cell_1.start1 = 1\nparticle_indexer_cell_1.end1 = 3\nparticle_indexer_cell_1.start2 = 7\nparticle_indexer_cell_1.end2 = 10","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The struct also has additional utility fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ParticleIndexer.n_group1 = ParticleIndexer.end1 - ParticleIndexer.start1 + 1 stores the number of particles in the first block\nParticleIndexer.n_group2 = ParticleIndexer.end2 - ParticleIndexer.start2 + 1 stores the number of particles in the second block\nParticleIndexer.n_local = ParticleIndexer.n_group1 + ParticleIndexer.n_group2 stores the total number of particles of this species in this cell.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The fields of the ParticleIndexer struct are not really intended for manual manipulation unless one is developing new sorting or merging routines, in which case one might have to set the starting and ending fields oneself. Most of the time, the existing sorting/collision/merging routines take care of keeping the particle indexers updated and correct.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Since we are usually interested in multi-species and/or multi-dimensional simulations, an array of ParticleIndexer instances is needed to keep track of the particles of different species in different cells. For this purpose Merzbild.jl provides the ParticleIndexerArray struct. It has two fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ParticleIndexerArray.indexer: a 2-dimensional array of ParticleIndexer instances with dimensions n_cells*n_species\nParticleIndexerArray.n_total: a 1-dimensional vector of length n_species with per-species total particle counts ","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Thus, to iterate over the particles of a specific species in a specific cell, one uses an instance of the ParticleIndexerArray (called pia in the code by convention):","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"for i in pia.indexer[cell,species].start1:pia.indexer[cell,species].end1\n    # do something with particles[species][i]\nend\n\nif pia.indexer[cell,species].start2 > 0\n    for i in pia.indexer[cell,species].start2:pia.indexer[cell,species].end2\n        # do something with particles[species][i]\n    end\nend","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Some utility functions are available for updating particle indexer arrays for developing new functionality: Merzbild.update_particle_indexer_new_lower_count and Merzbild.update_particle_indexer_new_particle. It is assumed that if the number of particles in the second block pointed to by a ParticleIndexer instance is 0, then the value of start2 is set to a value smaller than 0, so to iterate over the particles in the second block one can either do a check similar to the pia.indexer[cell,species].start2 > 0 check seen above, or check if pia.indexer[cell,species].n_group2 <= 0.","category":"page"},{"location":"overview_blocks/#Particles:-Particle-and-ParticleVector","page":"Overview of basic building blocks","title":"Particles: Particle and ParticleVector","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now that we can index particles, we need to create some lists of particles to index. For that, we need to define what a particle is. For this purpose, a Particle struct is available in the code. It has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"w: the computational weight of the particle (in a fixed-weight DSMC simulation, this is the F_num parameter)\nv: the 3-dimensional velocity vector of the particle\nx: the 3-dimensional position vector of the particle","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Each species has its own list of particles associated with it, so a particles variable in the simulation could have the following the type Vector{Vector{Particle}}. Then particles[species_1] would correspond to the list of all particles of chemical species species_1. pia.indexer[cell,species_1] would then be used to index the particles of species_1 in a specific cell cell.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The drawback of using Vector{Vector{Particle}} is that for non-spatially homogeneous simulations, the particles need to be sorted after each convection step, and this would involving constantly re-writing the position and velocity vectors. To reduce the computational cost of sorting, an additional abstraction layer is added via the struct ParticleVector that is intended to be used instead of  a simple Vector{Particle} instance. An instance of ParticleVector has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"particles: the underlying vector of particles\nindex: the sorted indices of the particles\ncell: used in particle sorting to keep track of new assigned cells\nbuffer: a LIFO queue used to track which particles from particles are not being used (i.e. allocated in memory but not present in the simulation)\nnbuffer: the number of elements in buffer","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Given a ParticleVector instance pv, one can still transparently access a particle at index i as pv[i]. This access operation however uses the sorted index list to get the actual index of the particle, so pv[i] is equivalent to pv.particles[pv.index[i]]. During particle sorting, only the indices in index are shuffled around, which is computationally cheaper than sorting the particles directly.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"(Image: particle_vector_trim)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The figure above shows the how the underlying particles (top array) are indexed via the help of the index field of the ParticleVector struct, and finally how the indices of the particles in a specific cell are indexed by the ParticleIndexer instance. In the example above, the different colors correspond to different grid cells. It can be seen that the array of Particle instances (\"underlying Particle vector\") is unsorted. The indices (ParticleVector.index) are however sorted. Thus, ParticleVector.index[1] points to the 1-st particle in the underlying Particle array, and ParticleVector.index[2] points to the 4-th particle.  ParticleVector.index[6] points to the 2-nd particle, and so on. It may be that due to creation of new particles during collisions some particles in the same cell are at the very end of the array (as they just got created). In the example above, particles 9 and 10 are in the same cell as particles 1, 4, 5, 7, 8. Therefore the corresponding ParticleIndexer instance for this cell will have start1=1, end1=5 (pointing to the first block of indices), and start2=9, end2=9 (pointing to the second block of indices).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"For all practical purposes, it should be sufficient to deal with particles in a ParticleVector instance pv by directly accessing them as pv[i]; the index and cell fields need to be changed only when one is writing new sorting routines.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"To summarize, for multi-species multi-dimensional simulations, one needs to use a Vector{ParticleVector} instance, each element of which (of type ParticleVector) corresponds to a vector of particles of a specific species. If one does not intend to sort particles (i.e. a 0-D simulation), one can in theory use a simple Vector{Vector{Particle}} instance, however, some of the particle sampling routines assume a ParticleVector instance (as they write the cell index data).","category":"page"},{"location":"overview_blocks/#Physical-data:-Species","page":"Overview of basic building blocks","title":"Physical data: Species","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"To sample particles, we need to know some properties of the chemical species that they represent. This is done via instances of the Species struct, which have the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"name: the name of the species\nmass: the mass of the species\ncharge: the charge of the species (in terms of elementary charge)\ncharge_div_mass: the charge of the species (in Coulombs) divided by the mass of the species","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Data about chemical species can be loaded by using the load_species_data function, which reads a TOML file with the relevant species information.","category":"page"},{"location":"overview_blocks/#Sampling-particles","page":"Overview of basic building blocks","title":"Sampling particles","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to sample particles of a certain species from a specific distribution, Merzbild.jl provides several functions. For fixed-weight DSMC simulations, one can use the sample_particles_equal_weight! to sample equal-weight particles from either a Maxwell or a BKW distribution. For variable-weight DSMC simulations, one can of course also use the same function (there is no inherent difference between fixed- and variable-weight DSMC simulations in Merzbild).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"However, in case variable-weight particles are allowed, one can also sample them from a distribution by evaluating that distribution of a discrete velocity grid. This functionality is provided by the sample_on_grid! function and its more specific version sample_maxwellian_on_grid! that assumes a Maxwell distribution. Sampling on a grid can lead to very high particle counts (for example, sampling on a 30x30x30 grid will lead to creation of up to 27000 particles in each physical cell), so care must be taken, and particles might need to be merged immediately after having been created.","category":"page"},{"location":"overview_blocks/#Computing-macroscopic-physical-properties:-PhysProps","page":"Overview of basic building blocks","title":"Computing macroscopic physical properties: PhysProps","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now that we have a vector of particles, we can compute some macroscopic properties (density, velocity, etc.). To store and use these properties where they might be needed, the PhysProps struct is provided. An instance of PhysProps has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ndens_not_Np: a boolean value used to distinguish between the meanings of the n field (see below) and ensure consistency\nn_cells: number of grid cells\nn_species: number of species in the simulation\nn_moments: number of total moments computed (see below how moments are defined)\nlpa: vector of length n_species storing the lengths of the particle arrays (i.e. how many elements have been allocated, actual particle counts may be less)\nnp: array with dimensions n_cells*n_species, stores the number of particles of each species in each grid cell\nn: array with dimensions n_cells*n_species, stores either the number of physical particles of each species in each grid cell or the number density of each species in each grid cell, see below for explanation\nv: array with dimensions 3*n_cells*n_species, stores the x, y, and z components of the macroscopic velocity of each species in each grid cell \nT: array with dimensions n_cells*n_species, stores the temperature of each species in each grid cell\nmoment_powers: vector of length n_moments, stores which total moments are being computed\nmoments: array with dimensions n_moments*n_cells*n_species, stores the total moments of each species in each grid cell\nTref: a reference temperature set during initialization of a PhysProps instance used to scale the moments so that for an equilibrium distribution at a temperature of T_ref all moments are equal to 1.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"One can see that the definition of the n field is somewhat ambiguous - it can either mean the total number of particles in a cell, or the number density in a cell (equal to the number of particles in the cell divided by the cell volume). To distinguish between these two cases, the following convention is assumed: if a PhysProps instance is initialized with a constructor that has the physical grid amongst its arguments, then n will mean the number density in a cell, and ndens_not_NP will be equal to true. If a constructor is called without passing the physical grid, then n will mean the number of physical particles in a cell, and ndens_not_NP will be equal to false.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The compute_props! function computes the macroscopical physical properties of all species in all cells in the simulation. Depending on whether the grid is passed as a parameter, it will compute either the number of particles in a cell or the number density in a cell (as the cell volume is needed to compute the latter). If there is an inconsistency between the value of the ndens_not_NP field of the PhysProps instance passed to the compute_props! function and the meaning of the computed value of n (i.e., the PhysProps instance has ndens_not_NP equal to false, but a grid is passed to compute_props!), the code will raise an error.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"If we don't need to compute the total moments, then we can create a PhysProps instance by simply passing a ParticleIndexerArray instance to the constructor, as it already has the required information on the number of grid cells and species. So we can simply do this: props = PhysProps(pia).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The avg_props! function can also be used to time-average physical properties; this requires use of two PhysProps instances, one of which holds the values of the physical properties at the current timestep, and the other one holds the values of the averaged physical properties. Similarly to the previous case, trying to average one PhysProps instance \"into\" another PhysProps instance with a different value of the ndens_not_NP field will raise an error.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The total moment of order N is defined as","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"M_N = frac1sum_i w_isum_i w_i left(v_xi^2+v_yi^2+v_zi^2right)^fracN2","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Here the summation is over all particles of a specific species in a particular grid cell. Since computing the moments is expensive, a different function needs to be called to compute all the physical properties and the moments: compute_props_with_total_moments!. If it is called and a PhysProps instance with n_moments = 0 is passed to it, it will fall back to the standard compute_props! to avoid unnecessary computations.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Support for computing mixed moments of the form ","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"M_abc = frac1sum_i w_isum_i w_i v_xi^a v_yi^b v_zi^c","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"is planned in future versions of Merzbild.jl.","category":"page"},{"location":"overview_blocks/#Writing-output:-NCDataHolder","page":"Overview of basic building blocks","title":"Writing output: NCDataHolder","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Finally, once the properties have been computed, we need to output them. Merzbild.jl uses the binary NetCDF format for its output, specifically the NetCDF4 version of the format. The functionality is provided by the NetCDF.jl and NCDatasets.jl libraries. The testing code relies on NCDatasets.jl as originally Merzbild.jl used the library throughout the whole code; however, the NetCDF.jl library was found to be significantly faster when used for output, so all the non-testing code has been ported to NetCDF.jl. The NCDatasets.jl dependency will be dropped in a future version once tests are ported to NetCDF.jl.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to write the physical properties to a NetCDF file, one needs to create an NCDataHolder instance. It keeps track of the variables being output, the file handle, and the number of times data has been written to a file. It also keeps track of whether the ndens output variable actually corresponds to the number of particles in a cell or to the number density in a cell, based on the flag in the PhysProps instance used to initialize the NCDataHolder instance. (In a future version of Merzbild.jl, it is planned to change the output variable name based on the ndens_not_Np flag value in the PhysProps instance used in the constructor.)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"We can construct an NCDataHolder instance like this:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"NCDataHolder(\"output_filename.nc\", species_data, phys_props)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Additional global attributes can be written to the file if they are passed as a dictionary using the global_attributes keyword of the constructor. Additionally, it is possible to pass a list of variable names that should be skipped during output (i.e. they won't be written to the NetCDF file), a more detailed description is given in the public API reference.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to write the physical properties to a file at a certain timestep, we need to call","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"write_netcdf_phys_props(ds, phys_props, timestep)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Here ds is the NCDataHolder instance, and timestep is the number of the timestep of the simulation (it also gets written to the output). Additionally, the sync_freq keyword parameter can be set to control how often the file is flushed (synchronized) to disk.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Finally, at the end of the simulation we need to close the file, so we call","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"close_netcdf(ds)","category":"page"},{"location":"overview_blocks/#Example:-bringing-it-all-together","page":"Overview of basic building blocks","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"An example of particle sampling, property computation, and output for a 0-D single-species gas is presented here.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"using Merzbild\nusing Random\n\n# set our random seed for reproducibility\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# load particle data\nparticles_data_path = joinpath(\"data\", \"particles.toml\")\nspecies_data = load_species_data(particles_data_path, \"Ar\")\n\n# init particle vector for a 1000 particles\nn_particles = 1000\nparticles = [ParticleVector(n_particles)]\n\n# set number density to 1e23\nndens = 1e23\n\n# and compute the particle weight Fnum\nFnum = ndens / n_particles\n\n# set particle temperature\nT = 500.0\n\n# create the particle indexer array for 1 cell and 1 species, assume 0 particles since we haven't\n# sampled any particles yet\npia = ParticleIndexerArray(0)\n\n# sample particles in a [0.0, 1.0]x[0.0, 1.0]x[0.0, 1.0] cell\nsample_particles_equal_weight!(rng, particles[1], pia, 1, 1, n_particles, T, species_data[1].mass, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0; distribution=:Maxwellian)\n\n# create struct for computation of physical properties\nphys_props = PhysProps(pia)\n\n# create struct for netCDF output\nds = NCDataHolder(\"output.nc\", species_data, phys_props)\n\n# compute physical properties \ncompute_props!(particles, pia, species_data, phys_props)\n\n# and output them (t=0)\nwrite_netcdf_phys_props(ds, phys_props, 0)\nclose_netcdf(ds)","category":"page"},{"location":"overview_blocks/#Summary","page":"Overview of basic building blocks","title":"Summary","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now we have an overview of how to","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Create a structure to hold particles\nIndex the vector of particles\nLoad species' data\nSample particles from a distribution\nCompute macroscopic physical properties\nOutput these properties to disk","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In the next section, an overview of how to simulate collisions will be given.","category":"page"}]
}
