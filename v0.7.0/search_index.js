var documenterSearchIndex = {"docs":
[{"location":"multithreaded/#Multithreaded-simulations","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"","category":"section"},{"location":"multithreaded/#Overview","page":"Multithreaded simulations","title":"Overview","text":"","category":"section"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"Multithreaded simulations are possible via use of standard Julia threads. The approach is relatively straightforward:","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"The domain is decomposed into n_chunks \"cell chunks\", which are lists of cells.  Within each chunk the cell indices should be continuous.  For example, a 4-cell domain may be decomposed into [[1,2],[3,4]] (2 chunks),  [[1], [2,3], [4] (3 chunks), [[1], [2], [3], [4]] (4 chunks), etc.\nSeveral variables are instantiated for each chunk:\nn_chunks arrays of ParticleVectors (each hold n_species ParticleVectors)\nn_chunks RNGs\nn_chunks ParticleIndexerArray instances\nn_chunks GridSortInPlace instances\nn_chunks+1 SurfProps instances (one additional instance is required for the reduce operation)\nCollisions, convection, sorting are all performed per-chunk, completely independently,  so multithreading can be used\nAfter particles have been sorted, some might need to be moved between chunks,  if they ended up in cells assigned to another chunk.  This is done in two steps: first, one calls exchange_particles! to move the particle  data between chunks. This is done in serial mode to avoid race conditions.  Then, sort_particles_after_exchange! is called to reset indexing without having to  completely resort all the new particles. This can be done using multithreading.\nPhysical grid properties are computed using multithreading, as they can easily be computed  only for cells assigned to the chunk, thus avoiding any race conditions.  In case surface properties were computed during particle movement, a  reduce operation is needed to sum the per-chunk values. This is done by  a serial call to reduce_surf_props!.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"The trade-off of the approach is that even in case no new particles are created in the simulation, particle data will be moved around, as when after a movement step a particle ends up in a cell corresponding to a different chunk, it needs to be moved to the ParticleVector for that chunk. In addition, some duplication of data structures (i.e. multiple GridSortInPlace instances) is required. A special struct ChunkExchanger is used to facilitate exchange of particles between chunks.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"However, the code logic is more straightforward, as most of the data is independent and no race conditions can occur. Some of this functionality will be re-used to make MPI simulations possible.","category":"page"},{"location":"multithreaded/#Example:-multithreaded-Couette-flow-simulation","page":"Multithreaded simulations","title":"Example: multithreaded Couette flow simulation","text":"","category":"section"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"Below is an example of a multithreaded Couette flow simulation. To run in multithreaded mode, one should start julia specifying the number of threads: julia --threads NTHREADS. The file can also be found under simulations/1D/couette_multithreaded.jl.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"The ChunkSplitters.jl library is used to perform domain decomposition, by splitting the range of cell indices 1:nx into independent chunks. By default, the number of chunks is set equal to the number of threads; it can be set to a multiple of the number of threads by setting a value of the chunk_count_multiplier parameter. preallocation_margin_multiplier allocates additional unused particles in the per-chunk ParticleVector instances, since otherwise the transfer of particles might lead to frequent calls to resize! at the start of the simulation as the solution approaches steady state and the average number of particles in a chunk changes significantly. A value of 1.0 means no additional particle storage is allocated.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"The surface properties are collected into surf_props_reduced via a call to reduce_surf_props. Before the start of the time loop, the sampling procedure is multithreaded via the @threads macro. The physical properties are also computed in multithreaded mode.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"Inside the time loop, collisions, convection, and sorting are performed inside a @threads block. The chunk_exchanger data is also cleared in this multithreaded loop to prepare it for the movement of particles between chunks. Once the block finishes, the particles are moved between chunks via a serial call to sort_particles_after_exchange!. Finally, the indexing is reset, and physical grid properties are computed, again inside a @threads block. The reduction operation for the surface properties, as well as averaging of grid and surface properties, is performed serially at the end of the timestep.","category":"page"},{"location":"multithreaded/","page":"Multithreaded simulations","title":"Multithreaded simulations","text":"using Merzbild\nusing Random\nusing TimerOutputs\nusing Base.Threads\nusing ChunkSplitters\n\nfunction run(seed, T_wall, v_wall, L, ndens, nx, ppc, Δt, n_timesteps, avg_start; chunk_count_multiplier=1,\n             preallocation_margin_multiplier=1.0)\n    reset_timer!()\n\n    n_threads = Threads.nthreads()\n    n_chunks = n_threads * chunk_count_multiplier\n    println(\"Running on $n_threads threads, will split cells into $n_chunks chunks\")\n\n    rng_chunks = [Xoshiro(seed + i) for i in 0:n_chunks-1]\n\n    # load particle and interaction data\n    particles_data_path = joinpath(\"data\", \"particles.toml\")\n    species_data = load_species_data(particles_data_path, \"Ar\")\n    interaction_data_path = joinpath(\"data\", \"vhs.toml\")\n    interaction_data::Array{Interaction, 2} = load_interaction_data(interaction_data_path, species_data)\n\n    # create our grid and BCs\n    grid = Grid1DUniform(L, nx)\n    boundaries = MaxwellWalls1D(species_data, T_wall, T_wall, -v_wall, v_wall, 1.0, 1.0)\n\n    # split cell indices into chunks\n    cell_indices = Vector(1:nx)\n    cell_chunks = chunks(cell_indices; n=n_chunks)\n\n    # init per-chunk particle vectors, particle indexers, grid particle sorters\n    n_particles_chunks = [floor(Int64, ppc * length(cell_chunk) * preallocation_margin_multiplier) for cell_chunk in cell_chunks]\n    particles_chunks = [[ParticleVector(n_particles)] for n_particles in n_particles_chunks]\n    pia_chunks = [ParticleIndexerArray(grid.n_cells, 1) for cell_chunk in cell_chunks]\n    gridsorter_chunks = [GridSortInPlace(grid, n_particles) for n_particles in n_particles_chunks]\n\n    # this is used for moving particles between chunks after they have been sorted into grid cells\n    chunk_exchanger = ChunkExchanger(cell_chunks, nx)\n\n    # sample particles\n    # Fnum * ppc = Np in cell = ndens * V_cell\n    Fnum = grid.cells[1].V * ndens / ppc\n\n    # sample particles per-chunk\n    @timeit \"sampling\" @threads for (chunk_id, cell_chunk) in enumerate(cell_chunks)\n        @inbounds sample_particles_equal_weight!(rng_chunks[chunk_id], grid, particles_chunks[chunk_id][1],\n                                                    pia_chunks[chunk_id],\n                                                    1, species_data, ndens, T_wall, Fnum, cell_chunk)\n    end\n     \n    # create collision structs\n    collision_data = [CollisionData() for cell_chunk in cell_chunks]\n    \n    # create struct for computation of physical properties, sizes of pia are the same\n    phys_props = PhysProps(pia_chunks[1])\n\n    # create second struct for averaging of physical properties, sizes of pia are the same\n    phys_props_avg = PhysProps(pia_chunks[1])\n\n    # create struct for computation of surface properties, need a SurfProps instance per chunk\n    surf_props_chunks = [SurfProps(pia_chunks[1], grid) for cell_chunk in cell_chunks]\n\n    # we sum up all the surf props here\n    surf_props_reduced = SurfProps(pia_chunks[1], grid)\n\n    # create second struct for averaging of physical properties\n    surf_props_avg = SurfProps(pia_chunks[1], grid)\n\n    # create struct for netCDF for time-averaged physical properties I/O\n    ds_avg = NCDataHolder(\"scratch/data/avg_mt_couette_$(L)_$(nx)_$(v_wall)_$(T_wall)_$(ppc)_after$(avg_start).nc\",\n                          species_data, phys_props)\n\n    # create struct for netCDF for time-averaged surface properties I/O\n    ds_surf_avg = NCDataHolderSurf(\"scratch/data/avg_mt_couette_$(L)_$(nx)_$(v_wall)_$(T_wall)_$(ppc)_surf_after$(avg_start).nc\",\n                                   species_data, surf_props_avg)\n\n    # create and estimate collision factors\n    collision_factors = [create_collision_factors_array(pia, interaction_data, species_data, T_wall, Fnum)\n                         for pia in pia_chunks]\n\n    # compute data at t=0\n    @timeit \"props compute\" @threads for (chunk_id, cell_chunk) in enumerate(cell_chunks)\n        compute_props_sorted!(particles_chunks[chunk_id], pia_chunks[chunk_id], species_data, phys_props, cell_chunk)\n    end\n\n    n_avg = n_timesteps - avg_start + 1\n\n    for t in 1:n_timesteps\n\n        if t % 500 == 0\n            println(t)\n        end\n        \n        # collide, convect, sort particles\n        @timeit \"collide+convect+sort\" @threads for chunk_id in 1:n_chunks\n            for cell in cell_chunks[chunk_id]\n                @inbounds ntc!(rng_chunks[chunk_id], collision_factors[chunk_id][1, 1, cell],\n                               collision_data[chunk_id], interaction_data, particles_chunks[chunk_id][1],\n                               pia_chunks[chunk_id], cell, 1, Δt, grid.cells[cell].V)\n            end\n\n            if (t >= avg_start)\n                @inbounds convect_particles!(rng_chunks[chunk_id], grid, boundaries,\n                                    particles_chunks[chunk_id][1], pia_chunks[chunk_id],\n                                    1, species_data, surf_props_chunks[chunk_id], Δt)\n            else\n                # we don't need to compute surface properties before we start averaging\n                @inbounds convect_particles!(rng_chunks[chunk_id], grid, boundaries,\n                                    particles_chunks[chunk_id][1], pia_chunks[chunk_id],\n                                    1, species_data, Δt)\n            end\n\n            # need to clear the data in the chunk exchanger\n            @inbounds reset!(chunk_exchanger, chunk_id)\n\n            # sort particles\n            @inbounds sort_particles!(gridsorter_chunks[chunk_id], grid, particles_chunks[chunk_id][1], pia_chunks[chunk_id], 1)\n        end\n\n        # move particles between chunks\n        @timeit \"exchange\" exchange_particles!(chunk_exchanger, particles_chunks, pia_chunks, cell_chunks, 1)\n\n        # reset indexing, compute physical properties if needed\n        @timeit \"re-sort + compute props\" @threads for chunk_id in 1:n_chunks\n            sort_particles_after_exchange!(chunk_exchanger, gridsorter_chunks[chunk_id],\n                                           particles_chunks[chunk_id][1], pia_chunks[chunk_id],\n                                           cell_chunks[chunk_id], 1)\n            if (t >= avg_start)\n                @inbounds compute_props_sorted!(particles_chunks[chunk_id], pia_chunks[chunk_id],\n                                                species_data, phys_props, cell_chunks[chunk_id])\n            end\n        end\n\n        # reduce surface properties, average grid and surface properties\n        if (t >= avg_start)\n            @timeit \"avg physprops\" avg_props!(phys_props_avg, phys_props, n_avg)\n            @timeit \"reduce surf props\" reduce_surf_props!(surf_props_reduced, surf_props_chunks)\n            @timeit \"avg surfprops\" avg_props!(surf_props_avg, surf_props_reduced, n_avg)\n        end\n    end\n\n    @timeit \"I/O\" write_netcdf(ds_avg, phys_props_avg, n_timesteps)\n    @timeit \"I/O\" write_netcdf(ds_surf_avg, surf_props_avg, n_timesteps)\n\n    close_netcdf(ds_avg)\n    close_netcdf(ds_surf_avg)\n\n    print_timer()\nend\n\nrun(1234, 300.0, 500.0, 5e-4, 5e22, 500, 500, 2.59e-9, 50000, 14000; chunk_count_multiplier=1, preallocation_margin_multiplier=1.5)","category":"page"},{"location":"overview_fp/#Fokker-Planck-simulations","page":"Fokker-Planck simulations","title":"Fokker-Planck simulations","text":"","category":"section"},{"location":"overview_fp/","page":"Fokker-Planck simulations","title":"Fokker-Planck simulations","text":"Under construction","category":"page"},{"location":"reference_internal/#Merzbild.jl-internal-API-reference","page":"Internal API reference","title":"Merzbild.jl internal API reference","text":"","category":"section"},{"location":"reference_internal/","page":"Internal API reference","title":"Internal API reference","text":"The public API functions are exported by the module","category":"page"},{"location":"reference_internal/#Particle-indexing","page":"Internal API reference","title":"Particle indexing","text":"","category":"section"},{"location":"reference_internal/#Merzbild.map_cont_index","page":"Internal API reference","title":"Merzbild.map_cont_index","text":"map_cont_index(particle_indexer, i)\n\nMaps a continuous index in the range [0, n_local-1] to an index in the particle array given a ParticleIndexer instance describing how particle indices are split across 2 groups.\n\nPositional arguments\n\nparticle_indexer: the ParticleIndexer instance\ni: the index to map\n\n\n\n\n\nmap_cont_index(pia, cell, species, i)\n\nMaps a continuous index in the range [0, n_local-1] to an index in the particle array for particles of a specific species in a specific cell.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particles are located\nspecies: the index of the particles' species\ni: the index to map\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_indexer_new_lower_count!","page":"Internal API reference","title":"Merzbild.update_particle_indexer_new_lower_count!","text":"update_particle_indexer_new_lower_count!(pia, cell, species, new_lower_count)\n\nUpdate a ParticleIndexerArray instance when the particle count of a given species in a given cell is reduced.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particles are located\nspecies: the index of the particles' species\nnew_lower_count: the new number of particles of the given species in the given cell\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_indexer_new_particle!","page":"Internal API reference","title":"Merzbild.update_particle_indexer_new_particle!","text":"update_particle_indexer_new_particle!(pia, cell, species)\n\nUpdate a ParticleIndexerArray instance when a particle of a given species in a given cell is created. This places the particle index in the 2-nd group of particle indices in the ParticleIndexer instance.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is created\nspecies: the index of the species of which the particle is created\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.getindex","page":"Internal API reference","title":"Base.getindex","text":"Base.getindex(pv::ParticleVector, i)\n\nReturns the underlying particle in a ParticleVector instance with index i.\n\nIs usually called as ParticleVector[i].\n\nPositional arguments\n\npv: ParticleVector instance\ni: the index of the particle to be selected\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.setindex!","page":"Internal API reference","title":"Base.setindex!","text":"Base.setindex!(pv::ParticleVector, p::Particle, i::Integer)\n\nSet the underlying particle in a ParticleVector instance with index i to a new particle.\n\nIs usually called as ParticleVector[i] = p.\n\nPositional arguments\n\npv: ParticleVector instance\np: the Particle instance to write\ni: the index of the particle to be written to\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.length","page":"Internal API reference","title":"Base.length","text":"Base.length(pv::ParticleVector)\n\nReturns the length of a ParticleVector instance.\n\nIs usually called as length(ParticleVector).\n\nPositional arguments\n\npv: ParticleVector instance\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Base.resize!","page":"Internal API reference","title":"Base.resize!","text":"Base.resize!(pv::ParticleVector, n::Integer)\n\nResize a ParticleVector instance.\n\nIs usually called as resize!(ParticleVector, n).\n\nPositional arguments\n\npv: ParticleVector instance\nn: the new length of the ParticleVector instance (i.e. the length of all the vector fields of the instance)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.add_particle!","page":"Internal API reference","title":"Merzbild.add_particle!","text":"add_particle!(pv, position, w, v, x)\n\nCreate a new particle in a ParticleVector instance at position position. The ParticleIndexer/ParticleIndexerArray instances should be updated independently. See update_particle_buffer_new_particle! for more information regarding how the buffer of the ParticleVector is updated. This should not be used to update an existing particle. Particles at positions before position should exist in the ParticleVector array.\n\nPositional arguments\n\npv: ParticleVector instance\nposition: the position in the index vector to which to write the index of the new particle\nw: the computational weight of the particle to create\nv: the velocity of the particle to create\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle!-Tuple{ParticleVector, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle!","text":"update_particle_buffer_new_particle!(pv::ParticleVector, position)\n\nUpdate the buffer in a ParticleVector instance when a new particle is created. This writes the index of the new particle (the last index stored in the active part of the buffer) to the index vector at position position, and reduces the length of the active part of the buffer by 1.\n\nPositional arguments\n\npv: ParticleVector instance\nposition: the position in the index vector to which to write the index of the new particle\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle!-Tuple{ParticleVector, Any, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle!","text":"update_particle_buffer_new_particle!(pv::ParticleVector, pia, species)\n\nUpdate the buffer in a ParticleVector instance when a new particle is created at the end of the particle array, and reduces the length of the active part of the buffer by 1. This assumes that the pia structure has already an updated particle count (that accounts for the newly created particle), as the index of the new particle taken from the buffer is written to pv.index.[pia.n_total[species]].\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\nspecies: the index of the species of which a new particle is created\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle!-Tuple{Vector{Particle}, Any, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle!","text":"update_particle_buffer_new_particle!(pv::Vector{Particle}, pia, species)\n\nDummy function in case Vector{Particle} is used and not a ParticleVector, just to make the simplest 0-D examples work.\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_particle_buffer_new_particle!-Tuple{Vector{Particle}, Any}","page":"Internal API reference","title":"Merzbild.update_particle_buffer_new_particle!","text":"update_particle_buffer_new_particle!(pv::Vector{Particle}, position)\n\nDummy function in case Vector{Particle} is used and not a ParticleVector, just to make the simplest 0-D examples work.\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.update_buffer_index_new_particle!","page":"Internal API reference","title":"Merzbild.update_buffer_index_new_particle!","text":"update_buffer_index_new_particle!(pv, pia, cell, species)\n\nUpdate a ParticleIndexerArray and the buffer in a ParticleVector instance when a particle of a given species in a given cell is created. The particle index is added to the second group of particles pointed to by the ParticleIndexer. See the documentation of update_particle_indexer_new_particle! and update_particle_buffer_new_particle!\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is created\nspecies: the index of the species of which the particle is created\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.delete_particle!","page":"Internal API reference","title":"Merzbild.delete_particle!","text":"delete_particle!(pv::ParticleVector, pia, cell, species, i)\n\nDelete particle with index i of species species in cell cell and update the particle indexers and buffers accordingly. This changes the ordering of the non-deleted particles in the cell.\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is deleted\nspecies: the index of the species of which the particle is deleted\ni: the index of the particle to delete\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.delete_particle_end!","page":"Internal API reference","title":"Merzbild.delete_particle_end!","text":"delete_particle_end!(pv::ParticleVector, pia, cell, species)\n\nDelete the last particle of species species in cell cell: if particles are present in the 2nd group of the indices stored in the ParticleIndexer instance, it will delete the last particle in that group; otherwise it will delete the last particle in the 1st group of particles pointed to by the ParticleIndexer instance. If no particles are present in the cell, the function does nothing. This does not set the value of the contiguous field of pia to false even if pia becomes discontinuous; this has to be done outside of this function.\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is deleted\nspecies: the index of the species of which the particle is deleted\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.delete_particle_end_group1!","page":"Internal API reference","title":"Merzbild.delete_particle_end_group1!","text":"delete_particle_end_group1!(pv::ParticleVector, pia, cell, species)\n\nDelete particle with index pia.indexer[cell, species].end1of speciesspeciesin cellcelland update the particle indexers and buffers accordingly (i.e. delete the last particle in the 1st group of particles of a given species in a given cell). This also sets the weight of the deleted particle to 0. If no particles are present in the 1st group of particles, the function does nothing. This does not set the value of thecontiguousfield ofpiatofalseeven ifpia` becomes discontinuous; this has to be done outside of this function.\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is deleted\nspecies: the index of the species of which the particle is deleted\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.delete_particle_end_group2!","page":"Internal API reference","title":"Merzbild.delete_particle_end_group2!","text":"delete_particle_end_group2!(pv::ParticleVector, pia, cell, species)\n\nDelete particle with index pia.indexer[cell, species].end2of speciesspeciesin cellcelland update the particle indexers and buffers accordingly (i.e. delete the last particle in the 2nd group of the particles of a given species in a given cell). This also sets the weight of the deleted particle to 0. If no particles are present in the 2nd group of particles, the function does nothing. This does not set the value of thecontiguousfield ofpiatofalseeven ifpia` becomes discontinuous; this has to be done outside of this function.\n\nPositional arguments\n\npv: ParticleVector instance\npia: the ParticleIndexerArray instance\ncell: the index of the cell in which the particle is deleted\nspecies: the index of the species of which the particle is deleted\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Loading-species-and-interaction-data","page":"Internal API reference","title":"Loading species and interaction data","text":"","category":"section"},{"location":"reference_internal/#Merzbild.compute_mu_ref","page":"Internal API reference","title":"Merzbild.compute_mu_ref","text":"compute_mu_ref(m_r, vhs_o, vhs_Tref, vhs_d)\n\nCompute reference viscosity for the VHS model.\n\nPositional arguments\n\nm_r: collision-reduced mass\nvhs_o: exponent for the VHS potential\nvhs_Tref: reference temperature for the VHS potential\nvhs_d: diameter for the VHS potential\n\nReturns\n\nreference viscosity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Sampling","page":"Internal API reference","title":"Sampling","text":"","category":"section"},{"location":"reference_internal/#Merzbild.UnitDVGrid","page":"Internal API reference","title":"Merzbild.UnitDVGrid","text":"UnitDVGrid\n\nStores information about a uniform discrete 3-dimensional velocity grid with extent -1010times-1010times-1010.\n\nFields\n\nnx: number of cells in x direction\nny: number of cells in y direction\nnz: number of cells in z direction\ndx: grid spacing in x direction\ndy: grid spacing in y direction\ndz: grid spacing in z direction\nvx_grid: Vector of grid nodes in x direction\nvy_grid: Vector of grid nodes in y direction\nvz_grid: Vector of grid nodes in z direction\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.DVGrid","page":"Internal API reference","title":"Merzbild.DVGrid","text":"DVGrid\n\nStores information about a uniform discrete 3-dimensional symmetric velocity grid with extent -v_xmaxv_xmaxtimes-v_ymaxv_ymaxtimes-v_zmaxv_zmax.\n\nFields\n\nbase_grid: the underlying unit (non-scaled) UnitDVGrid uniform grid \nvx_max: extent of the grid in the x direction\nvy_max: extent of the grid in the y direction\nvz_max: extent of the grid in the z direction\ndy: grid spacing in x direction\ndy: grid spacing in y direction\ndz: grid spacing in z direction\nvx_grid: Vector of grid nodes in x direction\nvy_grid: Vector of grid nodes in y direction\nvz_grid: Vector of grid nodes in z direction\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.VDF","page":"Internal API reference","title":"Merzbild.VDF","text":"VDF\n\nStores the values of a function evaluated on 3-dimensional velocity grid.\n\nFields\n\nnx: the number of grid elements in the x direction\nny: the number of grid elements in the y direction\nnz: the number of grid elements in the z direction\nw: the 3-dimensional array of values\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.sample_bkw!","page":"Internal API reference","title":"Merzbild.sample_bkw!","text":"sample_bkw!(rng, particles, nparticles, offset, m, T, v0)\n\nSample particle velocities from the BKW distribution with temperature T for a species with mass m at t=0 and add a velocity offset. Note: This does not update the particle weights, positions, or any indexing structures.\n\nPositional arguments\n\nrng: the random number generator\nparticles: the Vector-like structure holding the particles\nnparticles: the number of particles to sample\noffset: offset the starting position for writing the sampled particles to the particles array \nm: species' mass\nT: temperature\nv0: the 3-dimensional velocity to add to the sampled velocities\n\n\n\n\n\nsample_bkw!(rng, particles, nparticles, m, T, v0)\n\nSample particles' velocities from the BKW distribution with temperature T for a species with mass m     at t=0 and add a velocity offset. This does not update the particle weights, positions, or any indexing structures.     The sampled particles are written to the start of the particles array.\n\nPositional arguments\n\nrng: the random number generator\nparticles: the Vector-like structure holding the particles\nnparticles: the number of particles to sample\nm: species' mass\nT: temperature\nv0: the 3-dimensional velocity to add to the sampled velocities\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.evaluate_distribution_on_grid!","page":"Internal API reference","title":"Merzbild.evaluate_distribution_on_grid!","text":"evaluate_distribution_on_grid!(vdf, distribution_function, grid, w_total, cutoff_v; normalize=true)\n\nEvaluate a distribution on a discrete velocity grid, considering only points inside a sphere of a given radius (the value of the VDF at points outside of the sphere will be 0.0). The values can be re-normalized so that the distribution has the prescribed computational weight/density.\n\nPositional arguments\n\nvdf: The VDF instance where the evaluated values will be stored\ndistribution_function: the distribution function to be evaluated which takes the x, y, and z velocities as parameters\ngrid: the DVGrid on which the distribution function is evaluated\nw_total: the total weight used in the re-normalization\ncutoff_v: the radius of the sphere used to cut off high velocities: on grid points outside the sphere   the VDF will be 0\n\nKeyword arguments\n\nnormalize: if true, the resulting values of the VDF will be renormalized so that their sum is equal to   w_total\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sample_maxwellian!","page":"Internal API reference","title":"Merzbild.sample_maxwellian!","text":"sample_maxwellian!(rng, particles, nparticles, offset, m, T, v0)\n\nSample nparticles particles from a Maxwellian with temperature T for a species with mass m and add a velocity offset. Note: This does not update the particle weights, positions, or any indexing structures.\n\nPositional arguments\n\nrng: the random number generator\nparticles: the Vector-like structure holding the particles\nnparticles: the number of particles to sample\noffset: offset the starting position for writing the sampled particles to the particles array \nm: species' mass\nT: temperature\nv0: the 3-dimensional velocity to add to the sampled velocities\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Collision-computations","page":"Internal API reference","title":"Collision computations","text":"","category":"section"},{"location":"reference_internal/#Merzbild.compute_n_coll_single_species","page":"Internal API reference","title":"Merzbild.compute_n_coll_single_species","text":"compute_n_coll_single_species(rng, collision_factors, np, Δt, V)\n\nCompute the non-integer number of collisions between particles of same species.\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors holding the estimate of (sigma g w)_max   for the species in question in the cell\nnp: number of particles in the cell\nΔt: timestep\nV: cell volume\n\nReturns\n\nThe non-integer number of collisions.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_n_coll_two_species","page":"Internal API reference","title":"Merzbild.compute_n_coll_two_species","text":"compute_n_coll_two_species(rng, collision_factors, np1, np2, Δt, V)\n\nCompute number of collisions between particles of different species\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors holding the estimate of (sigma g w)_max   for the species in question in the cell\nnp1: number of particles of the first species in the cell\nnp2: number of particles of the second species in the cell\nΔt: timestep\nV: cell volume\n\nReturns\n\nThe non-integer number of collisions.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_vhs_factor","page":"Internal API reference","title":"Merzbild.compute_vhs_factor","text":"compute_vhs_factor(vhs_Tref, vhs_d, vhs_o, m_r)\n\nCompute interaction-specific factor pi D_VHS^2 (2 T_refVHSm_r)^(omega_VHS - 05) frac1Gamma(25 - omega_VHS).\n\nPositional arguments\n\nvhs_Tref: reference temperature for the VHS potential\nvhs_d: diameter for the VHS potential\nvhs_o: exponent for the VHS potential\nm_r: collision-reduced mass\n\nReturns\n\ncomputed VHS cross-section factor\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_com!","page":"Internal API reference","title":"Merzbild.compute_com!","text":"compute_com!(collision_data::CollisionData, interaction::Interaction, p1, p2)\n\nCompute center of mass velocity of two particles.\n\nPositional arguments\n\ncollision_data: the CollisionData instance where the computed velocity will be stored\ninteraction: the Interaction instance for the species of the colliding particles\np1: the first particle\np2: the second particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_g!","page":"Internal API reference","title":"Merzbild.compute_g!","text":"compute_g!(collision_data::CollisionData, p1, p2)\n\nCompute relative velocity (vector and its magnitude) of two particles.\n\nPositional arguments\n\ncollision_data: the CollisionData instance where the computed velocity will be stored\np1: the first particle\np2: the second particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_g_new_ionization!","page":"Internal API reference","title":"Merzbild.compute_g_new_ionization!","text":"compute_g_new_ionization!(collision_data, interaction, E_i, energy_splitting)\n\nCompute post-ionization magnitudes of the relative velocities of the impacting and newly created electrons.\n\nPositional arguments\n\ncollision_data: the CollisionData instance where the computed velocity will be stored\ninteraction: the Interaction instance for the electron-neutral interaction which produced the ion\nE_i: ionization energy of the neutral species in electron-volt\nenergy_splitting: how the energy is divided among the electrons: if ElectronEnergySplitEqual, the energy is split equally,   if ElectronEnergySplitZeroE, one electron takes all of the energy\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_vhs!","page":"Internal API reference","title":"Merzbild.scatter_vhs!","text":"scatter_vhs!(rng, collision_data, interaction, p1, p2)\n\nScatter two particles using VHS (isotropic) scattering.\n\nPositional arguments\n\nrng: the random number generator\ncollision_data: the CollisionData instance to which stores the   center-of-mass velocity, the magnitude of the pre-collisional relative velocity of the particles and to which   the new post-collisional velocity will be written\ninteraction: the Interaction instance for the colliding particles\np1: the first colliding particle\np2: the second colliding particle\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_electron_vhs!","page":"Internal API reference","title":"Merzbild.scatter_electron_vhs!","text":"scatter_electron_vhs!(rng, collision_data, particles_electron, g_new)\n\nScatter an electron off of a neutral particle using VHS (isotropic) scattering and re-scale its relative velocity to g_new.\n\nPositional arguments\n\nrng: the random number generator\ncollision_data: the CollisionData instance to which stores the   center-of-mass velocity and the magnitude of the pre-collisional relative velocity   of the electron and the neutral\nparticles_electron: the electron particle to scatter off of the neutral particle\ng_new: the magnitude of the post-collisional relative velocity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scatter_ionization_electrons!","page":"Internal API reference","title":"Merzbild.scatter_ionization_electrons!","text":"scatter_ionization_electrons!(rng, collision_data, particles_electron, i1, i2)\n\nScatter two electrons off of a neutral using VHS (isotropic) scattering.\n\nPositional arguments\n\nrng: the random number generator\ncollision_data: the CollisionData instance to which stores the   center-of-mass velocity the magnitude of the pre-collisional relative velocity   of the electron and the neutral, and the post-collisional magnitudes of the velocities   of the electrons\nparticles_electron: the vector of electron particles to scatter off of the neutral particle\ni1: the index of the first electron particle to scatter off of the neutral\ni2: the index of the second electron particle to scatter off of the neutral\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.sigma_vhs","page":"Internal API reference","title":"Merzbild.sigma_vhs","text":"sigma_vhs(interaction, g)\n\nComputes the VHS cross-section.\n\nPositional arguments\n\ninteraction: the Interaction instance\ng: the relative velocity of the collision\n\nReturns\n\nThe value of the computed cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_tabulated_cs_constant_continuation","page":"Internal API reference","title":"Merzbild.compute_tabulated_cs_constant_continuation","text":"compute_tabulated_cs_constant_continuation(tabulated_cs_data, E_coll)\n\nCompute an energy-dependent cross-section from tabulated data using linear interpolation. If the energy is smaller than the minimum energy used for the tabulation, return first element of the table; if energy is larger than the maximum energy used for the tabulation, return last element of the table.\n\nPositional arguments\n\ntabulated_cs_data: a TabulatedCSData instance with the tabulated energies and cross-section values\nE_coll: the collision energy for which to compute the cross-section\n\nReturns\n\nThe value of the cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_tabulated_cs_zero_continuation","page":"Internal API reference","title":"Merzbild.compute_tabulated_cs_zero_continuation","text":"compute_tabulated_cs_zero_continuation(tabulated_cs_data, E_coll)\n\nCompute an energy-dependent cross-section from tabulated data using linear interpolation. If the energy is outside of the range of energies used for the tabulation, returns 0.0.\n\nPositional arguments\n\ntabulated_cs_data: a TabulatedCSData instance with the tabulated energies and cross-section values\nE_coll: the collision energy for which to compute the cross-section\n\nReturns\n\nThe value of the cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_cross_sections_only!","page":"Internal API reference","title":"Merzbild.compute_cross_sections_only!","text":"compute_cross_sections_only!(computed_cs, interaction, g, electron_neutral_interactions, neutral_species_index)\n\nCompute electron-impact ionization and excitation cross-sections, and electron-neutral elastic scattering crosss-sections, and return collision energy in eV. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\ncomputed_cs: the vector of ComputedCrossSection instances in which the computed values will be stored\ninteraction: the Interaction instance describing the electron-neutral interaction being considered\ng: the magnitude of the relative collision velocity\nelectron_neutral_interactions: the ElectronNeutralInteractions instance storing the tabulated cross-section   data\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe electron-neutral collision energy in eV.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_cross_sections!","page":"Internal API reference","title":"Merzbild.compute_cross_sections!","text":"compute_cross_sections!(computed_cs, interaction, g, electron_neutral_interactions, neutral_species_index)\n\nCompute electron-impact ionization and excitation cross-sections, electron-neutral elastic scattering cross-sections, total collision cross-section, probabilities of the different processes, and return collision energy in eV. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\ncomputed_cs: the vector of ComputedCrossSection instances in which the computed values will be stored\ninteraction: the Interaction instance describing the electron-neutral interaction being considered\ng: the magnitude of the relative collision velocity\nelectron_neutral_interactions: the ElectronNeutralInteractions instance storing the tabulated cross-section   data\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe electron-neutral collision energy in eV.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_total","page":"Internal API reference","title":"Merzbild.get_cs_total","text":"get_cs_total(electron_neutral_interactions, computed_cs, neutral_species_index)\n\nGet the value of a computed total collision cross-section for electron-neutral interactions. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\nelectron_neutral_interactions: the ElectronNeutralInteractions instance storing the tabulated cross-section   data\ncomputed_cs: the vector of ComputedCrossSection instances holding the computed cross-section values\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe value of the total collision cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_elastic","page":"Internal API reference","title":"Merzbild.get_cs_elastic","text":"get_cs_elastic(electron_neutral_interactions, computed_cs, neutral_species_index)\n\nGet the value of a computed electron-neutral elastic scattering cross-section. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\nelectron_neutral_interactions: the ElectronNeutralInteractions instance storing the tabulated cross-section   data\ncomputed_cs: the vector of ComputedCrossSection instances holding the computed cross-section values\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe value of the elastic scattering cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_cs_ionization","page":"Internal API reference","title":"Merzbild.get_cs_ionization","text":"get_cs_ionization(electron_neutral_interactions, computed_cs, neutral_species_index)\n\nGet the value of a computed electron-impact ionization cross-section. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\nelectron_neutral_interactions: the ElectronNeutralInteractions instance storing the tabulated cross-section   data\ncomputed_cs: the vector of ComputedCrossSection instances holding the computed cross-section values\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe value of the electron-impact ionization scattering cross-section.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_ionization_threshold","page":"Internal API reference","title":"Merzbild.get_ionization_threshold","text":"get_ionization_threshold(electron_neutral_interactions, neutral_species_index)\n\nGet the ionization threshold energy. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\nelectron_neutral_interactions the ElectronNeutralInteractions instance storing the tabulated cross-section   data\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe ionization threshold energy of a specific neutral species.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_electron_energy_split","page":"Internal API reference","title":"Merzbild.get_electron_energy_split","text":"get_electron_energy_split(electron_neutral_interactions, neutral_species_index)\n\nGet the way electron energy is split during ionization for a specific electron-neutral interaction. Here neutral_species_index is the index of the neutral species being considered in the overall array of the Species instances that includes all species in the simulation and was used to construct the ElectronNeutralInteractions instance.\n\nPositional arguments\n\nelectron_neutral_interactions the ElectronNeutralInteractions instance storing the tabulated cross-section   data\nneutral_species_index: the index of the neutral species being considered\n\nReturns\n\nThe ElectronEnergySplit value for the specific electron-neutral interaction.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Fokker-Planck-computations","page":"Internal API reference","title":"Fokker-Planck computations","text":"","category":"section"},{"location":"reference_internal/#Merzbild.sample_normal_rands!","page":"Internal API reference","title":"Merzbild.sample_normal_rands!","text":"sample_normal_rands!(rng, collision_data_fp, n_local)\n\nSample 3*n_local normally distributed random numbers (with mean 0 and variance 1), one for each velocity component, and write them to a CollisionDataFP instance.\n\nPositional arguments\n\nrng: the random number generator\ncollision_data_fp: CollisionDataFP instance used for storing collisional quantities\nn_local: the number of particles to sample the numbers for\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_norm_rands!","page":"Internal API reference","title":"Merzbild.scale_norm_rands!","text":"scale_norm_rands!(collision_data_fp, n_local)\n\nScale sampled normally distributed random numbers velocity component-wise, so that their means for each component are exactly 0, and their variances are exactly 1.\n\nPositional arguments\n\ncollision_data_fp: CollisionDataFP instance used for storing collisional quantities\nn_local: the number of particles for which the numbers were sampled for\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_relaxation_time","page":"Internal API reference","title":"Merzbild.compute_relaxation_time","text":"compute_relaxation_time(interaction, species_data, species, V, es_old, local_w)\n\nCompute the relaxation time for a single-species flow, as given by tau = 2mu  p.\n\nPositional arguments\n\ninteraction: the Interaction instance for the self-interaction of the species in question\nspecies_data: the vector of SpeciesData\nspecies: the index of the species for which collisions are performed\nV: cell volume\nes_old: the total kinetic energy of the particles in the cell, divided by the species' molecular mass\nlocal_w: the total computational weight of the particles in the cell\n\nReturns\n\nThe elastic collision relaxation time.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Electron-neutral-interactions","page":"Internal API reference","title":"Electron-neutral interactions","text":"","category":"section"},{"location":"reference_internal/#Merzbild.TabulatedCSData","page":"Internal API reference","title":"Merzbild.TabulatedCSData","text":"TabulatedCSData\n\nStructure for storing tabulated cross-section data as a function of relative collision energy\n\nFields\n\nn_vals: number of values stored\nE: array of relative collision energies\nsigma: array of cross-section values at these energies\nΔE: how much energy is lost (gained) in the collision in case it is inelastic\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.ElasticScattering","page":"Internal API reference","title":"Merzbild.ElasticScattering","text":"ElasticScattering\n\nStructure to hold data on an elastic scattering cross-section.\n\nFields\n\ndata: a TabulatedCSData instance holding the cross-section values\nscattering: the ScatteringLaw model for the scattering of the particles\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.ExcitationSink","page":"Internal API reference","title":"Merzbild.ExcitationSink","text":"Ionization\n\nStructure to hold data on electron-impact electronic excitation cross-sections for a specific species.\n\nFields\n\nn_reactions: number of electron-impact electronic excitation reactions\ndata: an array of TabulatedCSData instances (of length n_reactions) holding the cross-section values for each reaction\nscattering: the ScatteringLaw model for the scattering of the particles\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.Ionization","page":"Internal API reference","title":"Merzbild.Ionization","text":"Ionization\n\nStructure to hold data on an electron-impact ionization cross-section.\n\nFields\n\ndata: a TabulatedCSData instance holding the cross-section values\nscattering: the ScatteringLaw model for the scattering of the electrons\nsplit: the ElectronEnergySplit model for energy splitting across the primary and secondary electrons\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.find_species_in_db","page":"Internal API reference","title":"Merzbild.find_species_in_db","text":"Find a chemical species in an LXCat-format XML; returns the first instance of the species found and the id of the \"Groups\" element in which the species was found. The following conditions need to be satisfied for a tuple (i,j) for it to be returned: tag(xml_data[i]) == \"Groups\" and attributes(xml_data[i][j])[\"id\"] == species_name.\n\nPositional arguments\n\nxml_data: the LXCat-format XML data to be searched\nspecies_name: the name of the species to search for\n\nReturns\n\nTuple (i,j) denoting the index of the group and group element in which the species is located\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.load_elastic_data","page":"Internal API reference","title":"Merzbild.load_elastic_data","text":"load_elastic_data(xml_data)\n\nLoad electron-neutral elastic scattering data from the part of an LXCat-format XML file for a specific species. The following should hold for the data to be loaded: tag(xml_data[i]) == \"Processes\", attributes(xml_data[i][j])[\"type\"] == \"Ionization\". This will load the first set of data found for the ionization process.\n\nPositional arguments\n\nxml_data: the LXCat-format XML data to be searched\n\nReturns\n\nTabulatedCSData structure containing the electron-neutral elastic scattering cross-section data.\n\nThrows\n\nDataMissingException if data not found or not all required data present.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.load_ionization_data","page":"Internal API reference","title":"Merzbild.load_ionization_data","text":"load_ionization_data(xml_data)\n\nLoad electron-impact ionization data from the part of an LXCat-format XML file for a specific species. The following should hold for the data to be loaded: tag(xml_data[i]) == \"Processes\", attributes(xml_data[i][j])[\"type\"] == \"Ionization\". This will load the first set of data found for the ionization process.\n\nPositional arguments\n\nxml_data: the LXCat-format XML data to be searched\n\nReturns\n\nTabulatedCSData structure containing the electron-impact ionization cross-section data.\n\nThrows\n\nDataMissingException if data not found or not all required data present.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merging","page":"Internal API reference","title":"Merging","text":"","category":"section"},{"location":"reference_internal/#Merzbild.GridCell","page":"Internal API reference","title":"Merzbild.GridCell","text":"GridCell\n\nStruct for keeping track of merging-related quantities in a velocity grid cell.\n\nFields\n\nnp: number of particles in cell\nw: total computational weight of particles  in cell\nv_mean: mean velocity of particles in cell\nv_std_sq: variance of velocity of particles in cell\nx_mean: mean position of particles in cell\nx_std_sq: variance of position of particles in cell\nparticle_index1: index of first particle in the cell (first as in the first particle that is found to   belong to the cell)\nparticle_index1: index of second particle in the cell (second as in the second particle that is found to   belong to the cell)\nw1: the post-merge weight to assign to the first particle in the cell\nw2: the post-merge weight to assign to the second particle in the cell\nv1: the post-merge velocity to assign to the first particle in the cell\nv2: the post-merge velocity to assign to the second particle in the cell\nx1: the post-merge position to assign to the first particle in the cell\nx2: the post-merge position to assign to the second particle in the cell\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.compute_velocity_extent!","page":"Internal API reference","title":"Merzbild.compute_velocity_extent!","text":"compute_velocity_extent!(merging_grid, cell, species, species_data, phys_props)\n\nCompute extent of velocity grid based on temperature in the cell.\n\nPositional arguments:\n\nmerging_grid: the grid merging (GridN2Merge) instance for which to compute the extent\ncell: the index of the cell in which the temperature was computed\nspecies: the index of the species for which the temperature was computed\nspecies_data: the array of Species data\nphys_props: the PhysProps instance containing the computed temperature\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_grid_index","page":"Internal API reference","title":"Merzbild.compute_grid_index","text":"compute_grid_index(merging_grid, v)\n\nCompute index of cell on the merging grid in which a velocity is located (the last 8 indices correspond to the velocity octants outside the grid).\n\nPositional arguments:\n\nmerging_grid: the grid merging (GridN2Merge) instance defining the velocity space grid\nv: the velocity vector\n\nReturns:\n\nIndex of cell on the merging grid.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.clear_merging_grid!","page":"Internal API reference","title":"Merzbild.clear_merging_grid!","text":"clear_merging_grid!(merging_grid)\n\nResets all data for a merging grid instance.\n\nPositional arguments:\n\nmerging_grid: the grid merging (GridN2Merge) instance defining the velocity space grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_grid!","page":"Internal API reference","title":"Merzbild.compute_grid!","text":"compute_grid!(merging_grid::GridN2Merge, particles, pia, cell, species)\n\nCompute all the required cell properties for a grid-based merge.\n\nPositional arguments:\n\nmerging_grid: the grid merging (GridN2Merge) instance defining the velocity space grid\nparticles: the ParticleVector instance of the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the cell index\nspecies: the species index\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_new_particles!","page":"Internal API reference","title":"Merzbild.compute_new_particles!","text":"compute_new_particles!(rng, merging_grid::GridN2Merge, particles, pia, cell, species)\n\nCompute new particles based on the grid cell properties without checking particle locations. So particles may end up outside of the domain.\n\nPositional arguments:\n\nrng: the random number generator instance\nmerging_grid: the grid merging (GridN2Merge) instance defining the velocity space grid\nparticles: the ParticleVector instance of the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the cell index\nspecies: the species index\n\n\n\n\n\ncompute_new_particles!(rng, octree::OctreeN2Merge, particles, pia, cell, species)\n\nCompute post-merge particles particles based on octree bin properties without checking particle locations. So particles may end up outside of the domain.\n\nPositional arguments:\n\nrng: the random number generator instance\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance of the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the cell index\nspecies: the species index\n\n\n\n\n\ncompute_new_particles!(rng, octree::OctreeN2Merge, particles, pia, cell, species, grid)\n\nCompute post-merge particles particles based on octree bin properties; placing out-of-domain particles back into the domain.\n\nPositional arguments:\n\nrng: the random number generator instance\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance of the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the cell index\nspecies: the species index\ngrid: the Grid1DUniform grid\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vx_sign","page":"Internal API reference","title":"Merzbild.vx_sign","text":"vx_sign(octant)\n\nReturn sign of velocity vx of an octant in velocity space.\n\nPositional arguments\n\noctant: index of the octant in velocity space\n\nReturns\n\nSign of the x-velocity corresponding to the octant.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vy_sign","page":"Internal API reference","title":"Merzbild.vy_sign","text":"vy_sign(octant)\n\nReturn sign of velocity vy of an octant in velocity space.\n\nPositional arguments\n\noctant: index of the octant in velocity space\n\nReturns\n\nSign of the y-velocity corresponding to the octant.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.vz_sign","page":"Internal API reference","title":"Merzbild.vz_sign","text":"vz_sign(octant)\n\nReturn sign of velocity vz of an octant in velocity space.\n\nPositional arguments\n\noctant: index of the octant in velocity space\n\nReturns\n\nSign of the z-velocity corresponding to the octant\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.check_speed_bound","page":"Internal API reference","title":"Merzbild.check_speed_bound","text":"check_speed_bound(speed_val, minval, maxval)\n\nCompare speed_val to the bounds and return either the value if its within bounds or the appropriate closest bound.\n\nPositional arguments\n\nspeed_val: value to check\nminval: lower bound\nmaxval: upper bound\n\nReturns\n\nEither original value or value of closest bound.\n\n\n\n\n\ncheck_speed_bound(speed_val, minval, maxval, multiplier)\n\nCompare speed_val time a multiplier to the bounds and return either the value times the multiplier if its within bounds or the appropriate closest bound times the multiplier.\n\nPositional arguments\n\nspeed_val: value to check\nminval: lower bound\nmaxval: upper bound\nmultiplier: the multiplier\n\nReturns\n\nEither original value times the multiplier or value of closest bound times the multiplier.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.base_multi_index_moments","page":"Internal API reference","title":"Merzbild.base_multi_index_moments","text":"base_multi_index_moments()\n\nBase multi indices corresponding to conservation of mass, momentum, and energy components.\n\nPositional arguments\n\nNone\n\nReturns\n\nA vector of multi-indices (3-tuples) which corresponding to mass, momentum, and directional energy.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_w_total_v0!","page":"Internal API reference","title":"Merzbild.compute_w_total_v0!","text":"compute_w_total_v0!(nnls_merging, particles, pia, cell, species)\n\nCompute total computational weight of particles and mean velocity, as well as velocity bounds of the set of particles in each velocity direction.\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance where the computed values will be stored\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.ccm","page":"Internal API reference","title":"Merzbild.ccm","text":"ccm(v, v0, mim)\n\nCompute unweighted central moment.\n\nPositional arguments\n\nv: the 3-dimensional velocity vector\nv0: the 3-dimensional mean velocity vector\nmim: the 3-dimensional multi-index\n\nReturns\n\nComputed unweighted central moment.\n\n\n\n\n\nccm(vx, vy, vz, vx0, vy0, vz0, mim)\n\nCompute unweighted central moment.\n\nPositional arguments\n\nvx: the x component of the velocity\nvy: the y component of the velocity\nvz: the z component of the velocity\nvx0: the x component of the mean velocity\nvy0: the y component of the mean velocity\nvz0: the z component of the mean velocity\nmim: the 3-dimensional multi-index\n\nReturns\n\nComputed unweighted central moment.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_and_rhs!","page":"Internal API reference","title":"Merzbild.compute_lhs_and_rhs!","text":"compute_lhs_and_rhs!(nnls_merging, lhs_matrix, particles, pia, cell, species)\n\nCompute LHS matrix and RHS vector for NNLS merging. Returns the pre-merge number of particles.\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance where the RHS vector will be stored\nlhs_matrix: the matrix of size n_total_conserved x n_particles, where   n_total_conserved is the number of conserved moments and n_particles is the pre-merge number of particles\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\n\nReturns\n\nThe pre-merge number of particles.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_and_rhs_rate_preserving!","page":"Internal API reference","title":"Merzbild.compute_lhs_and_rhs_rate_preserving!","text":"compute_lhs_and_rhs_rate_preserving!(nnls_merging, lhs_matrix, particles, pia, cell, species)\n\nCompute LHS matrix and RHS vector for the rate-preserving NNLS merging (for electrons). Approximate     elastic scattering and electron-impact ionization rates are conserved.\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance where the RHS vector will be stored\nlhs_matrix: the matrix of size n_total_conserved x n_particles, where   n_total_conserved is the number of conserved moments and n_particles is the pre-merge number of particles\ninteraction: the Interaction instance describing the electron-neutral interaction being considered\nelectron_neutral_interactions:  the ElectronNeutralInteractions instance storing the tabulated cross-section   data used to compute the rates\ncomputed_cs: the vector of ComputedCrossSection instances in which the computed values will be stored\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\nneutral_species_index: the index of the neutral species which is the collision partner in the electron-neutral   collisions for which approximate rates are being preserved.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_particles_additional!","page":"Internal API reference","title":"Merzbild.compute_lhs_particles_additional!","text":"compute_lhs_particles_additional!(rng, col_index, nnls_merging, lhs_matrix,\n                                  particles, pia, cell, species,\n                                  n_rand_pairs, centered_at_mean, v_multipliers)\n\nCompute additional LHS columns for additional particles. One particle is added at the local zero velocity ( i.e. mean velocity of the whole system of particles), 8 particles are added (1 per velocity space octant) using the standard deviation of the velocities of the whole particle system in each direction to determine their velocities (+ bounded via use of the check_speed_bound function). A second set of 8 particles is added using a similar scheme, but the velocities are multiplied by 0.5. Finally, n_rand_pairs particle pairs are chosen and their mean velocities are used to compute these additional particles.\n\nPositional arguments\n\nrng: the random number generator instance\ncol_index: the index of the first column where to start writing the additionally computed values\nnnls_merging: the NNLSMerge instance where the RHS vector will be stored\nlhs_matrix: the matrix of size n_total_conserved x n_particles, where   n_total_conserved is the number of conserved moments and n_particles is the pre-merge number of particles\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\nn_rand_pairs: the number of random particle pairs to choose\ncentered_at_mean: whether to add a particle centered at the mean velocity of the system of particles\nv_multipliers: \n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_lhs_particles_additional_rate_preserving!","page":"Internal API reference","title":"Merzbild.compute_lhs_particles_additional_rate_preserving!","text":"compute_lhs_particles_additional_rate_preserving!(rng, col_index, nnls_merging, lhs_matrix,\n                                       interaction, electron_neutral_interactions, computed_cs, \n                                       particles, pia, cell, species, neutral_species_index,\n                                       n_rand_pairs, centered_at_mean, v_multipliers)\n\nCompute additional LHS columns for additional particles for the rate-preserving NNLS merging (for electrons). One particle is added at the local zero velocity (i.e. mean velocity of the whole system of particles), 8 particles are added (1 per velocity space octant) using the standard deviation of the velocities of the whole particle system in each direction to determine their velocities (+ bounded via use of the check_speed_bound function). A second set of 8 particles is added using a similar scheme, but the velocities are multiplied by 0.5. Finally, n_rand_pairs particle pairs are chosen and their mean velocities are used to compute these additional particles.\n\nPositional arguments\n\nrng: the random number generator instance\ncol_index: the index of the first column where to start writing the additionally computed values\nnnls_merging: the NNLSMerge instance where the RHS vector will be stored\nlhs_matrix: the matrix of size n_total_conserved x n_particles, where   n_total_conserved is the number of conserved moments and n_particles is the pre-merge number of particles\ninteraction: the Interaction instance describing the electron-neutral interaction being considered\nelectron_neutral_interactions:  the ElectronNeutralInteractions instance storing the tabulated cross-section   data used to compute the rates\ncomputed_cs: the vector of ComputedCrossSection instances in which the computed values will be stored\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\nneutral_species_index: the index of the neutral species which is the collision partner in the electron-neutral   collisions for which approximate rates are being preserved.\nn_rand_pairs: the number of random particle pairs to choose\ncentered_at_mean: whether to add a particle centered at the mean velocity of the system of particles\nv_multipliers: \n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs_variance!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs_variance!","text":"scale_lhs_rhs_variance!(nnls_merging, lhs_matrix)\n\nScale the LHS and RHS of the NNLS system using the computed variances of the particles velocities in the x, y, z directions. If any of the variances is smaller than 1e-6, then v_ref is used. Each moment with multi-index (i,j,k) is scaled by (1Ex)^i(1Ey)^j(1Ez)^k.\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance\nlhs_matrix: the matrix of the LHS\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs_vref!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs_vref!","text":"scale_lhs_rhs_vref!(nnls_merging, lhs_matrix)\n\nScale the LHS and RHS of the NNLS system using the reference velocity v_ref. Each moment is scaled by (1v_ref)^n_tot, where n_tot is the total order of the moment (i.e. for a moment with multi-index (i,j,k) the total order is i+j+k).\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance\nlhs_matrix: the matrix of the LHS\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs!","text":"scale_lhs_rhs!(nnls_merging, lhs_matrix, scaling)\n\nScale the LHS and RHS of the NNLS system using either the reference velocity or the computed variances of the velocity in each direction.\n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance\nlhs_matrix: the matrix of the LHS\nscaling: how to scale entries (:vref or :variance)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.scale_lhs_rhs_rate_preserving!","page":"Internal API reference","title":"Merzbild.scale_lhs_rhs_rate_preserving!","text":"scale_lhs_rhs_rate_preserving!(nnls_merging, lhs_matrix, ref_cs_elastic, ref_cs_ion)\n\nScale the LHS and RHS of the NNLS system for the rate-preserving electron merging using the reference velocity v_ref and reference elastic scattering and ionization cross-sections. Each moment is scaled by (1v_ref)^n_tot, where n_tot is the total order of the moment (i.e. for a moment with multi-index (i,j,k) the total order is i+j+k). The entries in the LHS and RHS corresponding to the rates are scaled by 1(v_ref * sigma_p), where sigma_p is the cross-section of process p. \n\nPositional arguments\n\nnnls_merging: the NNLSMerge instance\nlhs_matrix: the matrix of the LHS\nref_cs_elastic: the reference elastic scattering cross-section\nref_cs_ion: the reference ionization cross-section\nscaling: how to scale entries (:vref or :variance)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_post_merge_particles_nnls!","page":"Internal API reference","title":"Merzbild.compute_post_merge_particles_nnls!","text":"compute_post_merge_particles_nnls!(lhs_ncols, lhs_matrix,\n                                        nnls_merging, particles, pia, cell, species)\n\nCompute post-merge particles based on the solution of the NNLS problem. This will replace the particles with the post-merge ones and delete any extraneous particles.\n\nPositional arguments\n\nlhs_ncols: the number of columns in the LHS matrix\nlhs_matrix: the LHS matrix of the NNLS system\nnnls_merging: the NNLSMerge instance\nparticles: the ParticleVector instance containing the particles that are being merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.OctreeCell","page":"Internal API reference","title":"Merzbild.OctreeCell","text":"OctreeCell\n\nStruct holding computed bin properties needed for refinement of an octree bin.\n\nFields\n\nnp: number of particles in cell\nw: total computational weight of particles in cell\nv_min: vector of the per-component lower bounds of the velocities in the cell\nv_max: vector of the per-component upper bounds of the velocities in the cell\ndepth: level of refinement the cell is at\ncan_be_refined: whether the cell can be refined further\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.OctreeFullCell","page":"Internal API reference","title":"Merzbild.OctreeFullCell","text":"OctreeFullCell\n\nStruct holding computed bin properties required to merge the particles in a bin.\n\nFields\n\nv_mean: mean velocity of particles in cell\nv_std_sq: variance of velocity of particles in cell\nx_mean: mean position of particles in cell\nx_std_sq: variance of position of particles in cell\nparticle_index1: index of first particle in the cell (first as in the first particle that is found to   belong to the cell)\nparticle_index1: index of second particle in the cell (second as in the second particle that is found to   belong to the cell)\nw1: the post-merge weight to assign to the first particle in the cell\nw2: the post-merge weight to assign to the second particle in the cell\nv1: the post-merge velocity to assign to the first particle in the cell\nv2: the post-merge velocity to assign to the second particle in the cell\nx1: the post-merge position to assign to the first particle in the cell\nx2: the post-merge position to assign to the second particle in the cell\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.fill_bins","page":"Internal API reference","title":"Merzbild.fill_bins","text":"fill_bins(Nbins)\n\nFill the octree bins structs with zero data, used as a utility function for initialization.\n\nPositional arguments:\n\nNbins: number of OctreeCell bins to create\n\nReturns: An array of Nbins OctreeCell instances filled with zeros.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.fill_full_bins","page":"Internal API reference","title":"Merzbild.fill_full_bins","text":"fill_full_bins(Nbins)\n\nFill the octree bins full structs with zero data, used as a utility function for initialization.\n\nPositional arguments:\n\nNbins: number of OctreeFullCell bins to create\n\nReturns: An array of Nbins OctreeFullCell instances filled with zeros.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.clear_octree!","page":"Internal API reference","title":"Merzbild.clear_octree!","text":"clear_octree!(octree)\n\nReset octree before doing a new merge.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.resize_octree_buffers!","page":"Internal API reference","title":"Merzbild.resize_octree_buffers!","text":"resize_octree_buffers!(octree, n_particles)\n\nCheck and resize octree buffers if needed to accommodate a larger number of particles. The size of the buffers is set to n_particles + DELTA_PARTICLES if the their sizes are smaller than n_particles.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nn_particles: the current number of particles being merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_octant","page":"Internal API reference","title":"Merzbild.compute_octant","text":"compute_octant(particle_v, v_middle)\n\nCompute octant of particle velocity relative to a v_middle` The order of the octants is:\n\n1. - - -\n2. + - -\n3. - + -\n4. + + -\n5. - - +\n6. + - +\n7. - + +\n8. + + +\n\nPositional arguments:\n\nparticle_v: the velocity of the particle\nv_middle: the velocity relative to which the octant is computed\n\nReturns:\n\nThe octant number\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.bin_bounds_inherit!","page":"Internal API reference","title":"Merzbild.bin_bounds_inherit!","text":"bin_bounds_inherit!(octree, bin_id, v_min_parent, v_max_parent, v_middle, octant)\n\nCompute new bin bounds of one of the 8 octant sub-bins inheriting bounds of parent bin.  The order of the octants is\n\n1. - - -\n2. + - -\n3. - + -\n4. + + -\n5. - - +\n6. + - +\n7. - + +\n8. + + +\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbin_id: the index of the bin for which the velocity bounds are being recomputed\nv_min_parent: the velocity vector of the lower bound of the velocities of the parent bin\nv_max_parent: the velocity vector of the upper bound of the velocities of the parent bin\nv_middle: the velocity across which the split is being performed\noctant: the octant of the parent bin to which this bin corresponds\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.bin_bounds_recompute!","page":"Internal API reference","title":"Merzbild.bin_bounds_recompute!","text":"bin_bounds_recompute!(octree, bin_id, bs, be, particles)\n\nRecompute bin bounds based on particle velocities by setting them to the smallest and largest velocities of the particles in each velocity direction.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbin_id: the index of the bin for which the velocity bounds are being recomputed\nbs: index of the first particle in bin\nbe: index of the last particle in bin\nparticles: the ParticleVector instance of the particles to be merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_v_mean!","page":"Internal API reference","title":"Merzbild.compute_v_mean!","text":"compute_v_mean!(octree, bs, be, particles)\n\nCompute mean velocity of particles in a bin.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbs: index of the first particle in bin\nbe: index of the last particle in bin\nparticles: the ParticleVector instance of the particles to be merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_v_median!","page":"Internal API reference","title":"Merzbild.compute_v_median!","text":"compute_v_median!(octree, bs, be, particles)\n\nCompute median velocity of particles in a bin. NOTE: allocates memory and is probably not fully correct!\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbs: index of the first particle in bin\nbe: index of the last particle in bin\nparticles: the ParticleVector instance of the particles to be merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_new_bin_id","page":"Internal API reference","title":"Merzbild.get_new_bin_id","text":"get_new_bin_id(i, bin_id, Nbins)\n\nGet index of a newly created bin once a bin with index bin_id is split into 8 sub-bins. The bin_id index is re-used for the 1-st sub-bin, and the other 7 sub-bins are tacked onto the end of the list of bins (so they have indices Nbins + 1, Nbins + 2, ..., where Nbins was the total number of octree bins before the split).\n\nPositional arguments\n\ni: index of sub-octant (ranging from 1 to 8) of the split bin for which to return a new bin index\nbin_id: index of bin being split\nNbins: total number of octree bins before the split\n\nReturns\n\nIndex of a newly created bin corresponding to a bin created from sub-octant i of bin bin_id.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.split_bin!","page":"Internal API reference","title":"Merzbild.split_bin!","text":"split_bin!(octree, bin_id, particles)\n\nSort particles into sub-bins of a bin with index bin_id (by splitting it into octants), keeping track of which sub-bins particles end up in. Also sets the velocity bounds of the new bins.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbin_id: octree bin index\nparticles: the ParticleVector instance of the particles to be merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_bin_props!","page":"Internal API reference","title":"Merzbild.compute_bin_props!","text":"compute_bin_props!(octree, bin_id, particles)\n\nCompute properties in a bin required for merging: total computational weight, mean velocity and position, standard deviation of particle velocities and positions.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbin_id: octree bin index\nparticles: the ParticleVector instance of the particles to be merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.get_bin_post_merge_np","page":"Internal API reference","title":"Merzbild.get_bin_post_merge_np","text":"get_bin_post_merge_np(octree, bin_id)\n\nGet number of post-merge particles in a bin: 2 if the number of particles in the bin is >= 2, otherwise the number of particles in the bin (0 or 1) is returned.\n\nPositional arguments:\n\noctree: the OctreeN2Merge instance\nbin_id: octree bin index\n\nReturns\n\nThe number of post-merge particles in a single octree bin (0, 1, or 2).\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.init_octree!","page":"Internal API reference","title":"Merzbild.init_octree!","text":"init_octree!(octree, particles, pia, cell, species)\n\nInitialize the top bin in an octree by copying particle indices and setting bin bounds.\n\nPositional arguments\n\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance containing the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_octree!","page":"Internal API reference","title":"Merzbild.compute_octree!","text":"compute_octree!(octree, particles, target_np)\n\nPerform refinement of an octree for N:2 merging until target number of particles reached or nothing left to refine.\n\nPositional arguments\n\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance containing the particles to be merged\ntarget_np: the target post-merge number of particles; the post-merge number of particles will not exceed this value   but may be not exactly equal to it \n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Grids","page":"Internal API reference","title":"Grids","text":"","category":"section"},{"location":"reference_internal/#Merzbild.Cell1D","page":"Internal API reference","title":"Merzbild.Cell1D","text":"Cell1D\n\nCell element of a 1-D grid\n\nFields\n\nxlo: coordinate of the left end of the element\nxhi: coordinate of the right end of the element \nV: cell volume\ninv_V: inverse of cell volume\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.Cell1D-Tuple{Any, Any, Any}","page":"Internal API reference","title":"Merzbild.Cell1D","text":"Cell1D(xlo, xhi, V)\n\nCreate cell of 1-D uniform grid\n\nPositional arguments\n\nxlo: coordinate of the left end of the element\nxhi: coordinate of the right end of the element \nV: cell volume\n\n\n\n\n\n","category":"method"},{"location":"reference_internal/#Merzbild.get_cell","page":"Internal API reference","title":"Merzbild.get_cell","text":"get_cell(grid1duniform::Grid1DUniform, x_pos)\n\nFind in which cell of a 1-D uniform grid the coordinate is located\n\nPositional arguments\n\ngrid1duniform: the 1-D uniform grid\nx_pos: the 3-D coordinate vector for the which the cell index is to be determined (only the first component is used)\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Particle-movement","page":"Internal API reference","title":"Particle movement","text":"","category":"section"},{"location":"reference_internal/#Merzbild.convect_single_particle!","page":"Internal API reference","title":"Merzbild.convect_single_particle!","text":"convect_single_particle!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, particle, species, Δt)\n\nConvect a singe particle on a 1-D uniform grid.\n\nPositional arguments\n\nrng: the random number generator\ngrid: the grid on which the convection is performed\nboundaries: the MaxwellWalls1D struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)\nparticles: the particle to be convected\nspecies: the index of the species being convected\nΔt: the convection timestep\n\n\n\n\n\nconvect_single_particle!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, particle, species, surf_props::SurfProps, mass, Δt)\n\nConvect a singe particle on a 1-D uniform grid, updating surface properties if it collides with a wall.\n\nPositional arguments\n\nrng: the random number generator\ngrid: the grid on which the convection is performed\nboundaries: the MaxwellWalls1D struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)\nparticles: the particle to be convected\nspecies: the index of the species being convected\nsurf_props: the SurfProps struct where the computed surface properties will be stored\nmass: the molecular mass of the species\nΔt: the convection timestep\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Particle-surface-interactions","page":"Internal API reference","title":"Particle-surface interactions","text":"","category":"section"},{"location":"reference_internal/#Merzbild.specular_reflection_x!","page":"Internal API reference","title":"Merzbild.specular_reflection_x!","text":"specular_reflection_x!(particle)\n\nPerform specular reflection of a particle in the x direction.\n\nPositional arguments\n\nparticle: the Particle instance for which the velocity is reflected\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.diffuse_reflection_x!","page":"Internal API reference","title":"Merzbild.diffuse_reflection_x!","text":"specular_reflection_x!(particle)\n\nPerform diffuse reflection of a particle, assuming the wall is orthogonal to the x axis.\n\nPositional arguments\n\nrng: the random number generator\nparticle: the Particle instance for which the velocity is reflected\nwall_reflection_v_sq: the squared thermal velocity of the species reflected at the wall temperature\nwall_normal_sign: sign of the wall normal\nwall_v: wall velocity vector\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.reflect_particle_x!","page":"Internal API reference","title":"Merzbild.reflect_particle_x!","text":"reflect_particle_x!(rng, particle, wall_reflection_v_sq, wall_normal_sign, wall_v, wall_accommodation)\n\nReflect particle from a Maxwell wall orthogonal to the x axis.\n\nPositional arguments\n\nrng: the random number generator\nparticle: the Particle instance for which the velocity is reflected\nwall_reflection_v_sq: the squared thermal velocity of the species reflected at the wall temperature\nwall_normal_sign: sign of the wall normal\nwall_v: wall velocity vector\nwall_accommodation: wall accommodation coefficient\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_surface_incident!","page":"Internal API reference","title":"Merzbild.update_surface_incident!","text":"update_surface_incident!(particle, species, surf_props, surface_element_id)\n\nUpdate surface properties for surface element surface_element_id for an incident particle.\n\nPositional arguments\n\nparticle: the particle hitting the surface before its velocity is updated\nspecies: the species of the particle\nsurf_props: the SurfProps instance\nsurface_element_id: id of the surface element which the particle has impacted\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_surface_reflected!","page":"Internal API reference","title":"Merzbild.update_surface_reflected!","text":"update_surface_incident!(particle, species, surf_props, surface_element_id)\n\nUpdate surface properties for surface element surface_element_id for a reflected particle.\n\nPositional arguments\n\nparticle: the particle hitting the surface after its velocity is updated\nspecies: the species of the particle\nsurf_props: the SurfProps instance\nsurface_element_id: id of the surface element which the particle has impacted\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.surface_props_scale!","page":"Internal API reference","title":"Merzbild.surface_props_scale!","text":"surface_props_scale!(species, surf_props, species_data, Δt)\n\nScale computed surface properties using the molecular mass of species, the inverse of the timestep, and the inverse surface area.\n\nPositional arguments\n\nspecies: the species of the particle\nsurf_props: the SurfProps instance\nspecies_data: the vector of SpeciesData of the chemical species in the flow\nΔt: the timestep over which the surface properties were computed\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#I/O","page":"Internal API reference","title":"I/O","text":"","category":"section"},{"location":"reference_internal/#Merzbild.AbstractNCDataHolder","page":"Internal API reference","title":"Merzbild.AbstractNCDataHolder","text":"AbstractNCDataHolder\n\nAbstract type that holds NetCDF-output related data for I/O\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Parallel-computations","page":"Internal API reference","title":"Parallel computations","text":"","category":"section"},{"location":"reference_internal/#Merzbild.swap_particles!","page":"Internal API reference","title":"Merzbild.swap_particles!","text":"swap_particles!(pv1, pv2, i, j)\n\nSwap particles pv1[i] and pv2[j] in two ParticleVector instances. This does not update any associated indices or buffers.\n\nPositional arguments\n\npv1: the first ParticleVector\npv2: the second ParticleVector\ni: index of the particle in pv1\nj: index of the particle in pv2\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.update_swap_indexing!","page":"Internal API reference","title":"Merzbild.update_swap_indexing!","text":"update_swap_indexing!(chunk_exchanger, pia_chunks, species, i, j, s_ci_ij, e_ci_ij, s_ji, n_swap)\n\nUpdates index bookkeeping in chunk_exchanger for particles that were swapped from chunk i to chunk j.\n\nAfter particles are swapped, this function records where in chunk j those particles from chunk i were placed, cell by cell. It does not perform the actual swapping. For correct bookkeeping it thus needs to be called twice, with all arguments dependent on i and j symmetrically swapped.\n\nPositional arguments\n\nchunk_exchanger: the ChunkExchanger instance to track post-swap and post-push indices\npia_chunks: Vector of ParticleIndexerArray instances for each chunk\nspecies: the particle species being redistributed\ni: source chunk index\nj: destination chunk index\ns_ci_ij: start cell index in chunk i for the swap\ne_ci_ij: end cell index in chunk i for the swap\ns_ji: starting index in chunk j's particle array where swapped particles from chunk i were placed\nn_swap: total number of particles that were successfully swapped\n\nReturns\n\ns_ci_ij2: the last cell index in the iteration (i.e., where the last particle was swapped)\noffset_ij: number of particles swapped from s_ci_ij2, useful if the swap was interrupted mid-cell\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.push_particles!","page":"Internal API reference","title":"Merzbild.push_particles!","text":"push_particles!(chunk_exchanger, particles_chunks, pia_chunks, species, i, j, offset_ij, s_ci_ij2, e_ci_ij)\n\nPushes particles of the specified species from chunk i to the end of chunk j, handling partial (unfinished) swaps.\n\nThis function finalizes a particle redistribution process between two spatial chunks in a parallel or chunked particle simulation. It ensures all remaining particles from chunk i that need to be moved to chunk j are properly transferred and indexed, even if the previous transfer process via swapping particles was interrupted mid-cell. This also updates the buffer of the source ParticleVector as particles are removed from it.\n\nPositional arguments\n\nchunk_exchanger: the ChunkExchanger instance to track post-swap and post-push indices\nparticles_chunks: Vector of Vector of ParticleVector (per chunk and per species, i.e.   particles_chunks[chunk_id][species] is the correct order of access)\npia_chunks: Vector of ParticleIndexerArray instances for each chunk\nspecies: the particle species being redistributed\ni: Source chunk index\nj: Destination chunk index\noffset_ij: number of particles already transferred from a cell where swapping   was performed but incomplete (0 if no incomplete swapping)\ns_ci_ij2: cell index in chunk i where the swapping was interrupted, or where the push   should start in case no swapping was performed\ne_ci_ij: final cell index to transfer from chunk i to chunk j\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Constants","page":"Internal API reference","title":"Constants","text":"","category":"section"},{"location":"reference_internal/#Merzbild.c_light","page":"Internal API reference","title":"Merzbild.c_light","text":"Speed of light, m/s\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV","page":"Internal API reference","title":"Merzbild.eV","text":"Electron-Volt, K\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV_J","page":"Internal API reference","title":"Merzbild.eV_J","text":"Electron-Volt, J\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.eV_J_inv","page":"Internal API reference","title":"Merzbild.eV_J_inv","text":"1.0/eV[J], 1/J (or equivalent to how much 1 J is equal to expressed in eV)\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.twopi","page":"Internal API reference","title":"Merzbild.twopi","text":"2 pi\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.e_mass_div_electron_volt","page":"Internal API reference","title":"Merzbild.e_mass_div_electron_volt","text":"Electron mass divided by 1 eV, kg/J\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.direction_signs","page":"Internal API reference","title":"Merzbild.direction_signs","text":"Positive and negative direction signs\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Merzbild.q_e","page":"Internal API reference","title":"Merzbild.q_e","text":"Elementary charge, C\n\n\n\n\n\n","category":"constant"},{"location":"reference_internal/#Misc","page":"Internal API reference","title":"Misc","text":"","category":"section"},{"location":"reference_internal/#Merzbild.compute_thermal_velocity","page":"Internal API reference","title":"Merzbild.compute_thermal_velocity","text":"compute_thermal_velocity(m, T)\n\nCompute the thermal velocity sqrt(2kTm).\n\nPositional arguments\n\nm: the molecular mass of the species\nT: the temperature\n\nReturns\n\nThe thermal velocity\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.binary_search","page":"Internal API reference","title":"Merzbild.binary_search","text":"binary_search(x, val)\n\nBinary search for value val in a sorted array x. Finds the position mid such that x[mid] < val < x[mid+1].\n\nPositional arguments\n\nx: the sorted array to be searched\nval: the value to search for\n\nReturns\n\n-1 if val < x[1]\n0 if val > x[end]\nOtherwise, returns the index mid satisfying x[mid] < val < x[mid+1]\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.linear_interpolation","page":"Internal API reference","title":"Merzbild.linear_interpolation","text":"linear_interpolation(x, y, val, pos, lower_limit, upper_limit)\n\nPerform linear interpolation of a tabulated function y(x), given a parameter value val, a sorted array of values of x and corresponding values of y, as well as the index of the closest values of x to val. In case val is outside of the limits of x, return placeholder values. That is, given that x[pos] < val < x[pos+1], we want to interpolate y(val) given that y[x[pos]] = y[pos], y[x[pos+1]] = y[pos+1].\n\nPositional arguments\n\nx: the vector of values of the parameter of the function to be interpolated\ny: the vector of the corresponding function values\nval: the value of the parameter at which the function is to be interpolated\npos: the index of the element in x such that x[pos] < val < x[pos+1],    or -1 if val < x[1], 0 if val > x[end]\nlower_limit: the value to return if val < x[1]\nupper_limit: the value to return if val > x[end]\n\nReturns\n\nThe linearly interpolated value of y(val) if x[1] <= val <= x[end]\nlower_limit, if val < x[1]\nupper_limit, if val > x[end]\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.compute_mixed_moment","page":"Internal API reference","title":"Merzbild.compute_mixed_moment","text":"compute_mixed_moment(particles, pia, cell, species, powers; sum_scaler=1.0, res_scaler=1.0)\n\nCompute mixed velocity moment of particles in a cell: sum_i w_i v_xi^p_x v_yi^p_y v_zi^p_z.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\ncell: the cell in which the moment is being computed\nspecies: the species for which the mixed moment is being computed\npowers: a Vector of the powers to which the x-, y-, and z-components of the velocity are to be raised\n\nKeyword arguments\n\nsum_scaler: during the summation over the particles, scale each summand by this factor   potentially reduce round-off issues\nres_scaler: scaling factor by which to multiply the result at the end\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#NNLS","page":"Internal API reference","title":"NNLS","text":"","category":"section"},{"location":"reference_internal/#Merzbild.solve!","page":"Internal API reference","title":"Merzbild.solve!","text":"Algorithm NNLS: NONNEGATIVE LEAST SQUARES\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nGIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B,  COMPUTE AN N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM                  A * X = B  SUBJECT TO X .GE. 0\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.construct_householder!","page":"Internal API reference","title":"Merzbild.construct_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.fastview","page":"Internal API reference","title":"Merzbild.fastview","text":"UnsafeVectorView only works for isbitstype types. For other types, we're already allocating lots of memory elsewhere, so creating a new View is fine.\n\nThis function looks type-unstable, but the isbitstype(T) test can be evaluated by the compiler, so the result is actually type-stable.\n\n\n\n\n\nFallback for non-contiguous arrays, for which UnsafeVectorView does not make sense.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.solve_triangular_system!","page":"Internal API reference","title":"Merzbild.solve_triangular_system!","text":"The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.UnsafeVectorView","page":"Internal API reference","title":"Merzbild.UnsafeVectorView","text":"Views in Julia still allocate some memory (since they need to keep a reference to the original array). This type allocates no memory and does no bounds checking. Use it with caution.\n\n\n\n\n\n","category":"type"},{"location":"reference_internal/#Merzbild.orthogonal_rotmat","page":"Internal API reference","title":"Merzbild.orthogonal_rotmat","text":"COMPUTE ORTHOGONAL ROTATION MATRIX.. The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\nCOMPUTE.. MATRIX   (C, S) SO THAT (C, S)(A) = (SQRT(A2+B2))                       (-S,C)         (-S,C)(B)   (   0          )    COMPUTE SIG = SQRT(A2+B2)       SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT       SIG MAY BE IN THE SAME LOCATION AS A OR B .\n\n\n\n\n\n","category":"function"},{"location":"reference_internal/#Merzbild.apply_householder!","page":"Internal API reference","title":"Merzbild.apply_householder!","text":"CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"function"},{"location":"overview_blocks/#Overview-of-basic-building-blocks","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"","category":"section"},{"location":"overview_blocks/#Particle-indexing:-ParticleIndexer-and-ParticleIndexerArray","page":"Overview of basic building blocks","title":"Particle indexing: ParticleIndexer and ParticleIndexerArray","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"One of the main parts of the code is the ParticleIndexer struct. It contains the starting and ending indices of the particles of a single species in a single cell. During collisions, the number of the particles of a certain species in a cell may increase, either due to inelastic processes, or due to particle splitting in variable-weight collisions. These new particles are \"tacked onto\" the end of the whole array of particles of the species. Thus, each  ParticleIndexer instance potentially tracks two blocks of particles that are all in a single cell: the ones that were there before collisions were performed, and the new ones that got created during collisions and are at the end of the array.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"(Image: particle_indexer_trim)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The figure above shows a graphical representation of the meaning of some of the fields of the ParticleIndexer struct. Assume we have a set of 10 particles in 3 different cells (different cells are colour-coded), with particles 1, 2, 3, 7, 8, 9, 10 located in cell 1, particles 4, 5 located in cell 2, and particle 6 located in cell 3. The ParticleIndexer struct corresponding to cell 1 will then have the following values for its fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"particle_indexer_cell_1.start1 = 1\nparticle_indexer_cell_1.end1 = 3\nparticle_indexer_cell_1.start2 = 7\nparticle_indexer_cell_1.end2 = 10","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The struct also has additional utility fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ParticleIndexer.n_group1 = ParticleIndexer.end1 - ParticleIndexer.start1 + 1 stores the number of particles in the first block\nParticleIndexer.n_group2 = ParticleIndexer.end2 - ParticleIndexer.start2 + 1 stores the number of particles in the second block\nParticleIndexer.n_local = ParticleIndexer.n_group1 + ParticleIndexer.n_group2 stores the total number of particles of this species in this cell.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The fields of the ParticleIndexer struct are not really intended for manual manipulation unless one is developing new sorting or merging routines, in which case one might have to set the starting and ending fields oneself. Most of the time, the existing sorting/collision/merging routines take care of keeping the particle indexers updated and correct.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Since we are usually interested in multi-species and/or multi-dimensional simulations, an array of ParticleIndexer instances is needed to keep track of the particles of different species in different cells. For this purpose Merzbild.jl provides the ParticleIndexerArray struct. It has two fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ParticleIndexerArray.indexer: a 2-dimensional array of ParticleIndexer instances with dimensions n_cells*n_species\nParticleIndexerArray.n_total: a 1-dimensional vector of length n_species with per-species total particle counts ","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Thus, to iterate over the particles of a specific species in a specific cell, one uses an instance of the ParticleIndexerArray (called pia in the code by convention):","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"for i in pia.indexer[cell,species].start1:pia.indexer[cell,species].end1\n    # do something with particles[species][i]\nend\n\nif pia.indexer[cell,species].start2 > 0\n    for i in pia.indexer[cell,species].start2:pia.indexer[cell,species].end2\n        # do something with particles[species][i]\n    end\nend","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Some utility functions are available for updating particle indexer arrays for developing new functionality: Merzbild.update_particle_indexer_new_lower_count! and Merzbild.update_particle_indexer_new_particle!. It is assumed that if the number of particles in the second block pointed to by a ParticleIndexer instance is 0, then the value of start2 is set to a value smaller than 0, so to iterate over the particles in the second block one can either do a check similar to the pia.indexer[cell,species].start2 > 0 check seen above, or check if pia.indexer[cell,species].n_group2 <= 0. See also the section on Particle buffers and contiguous indexing.","category":"page"},{"location":"overview_blocks/#Particles:-Particle-and-ParticleVector","page":"Overview of basic building blocks","title":"Particles: Particle and ParticleVector","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now that we can index particles, we need to create some lists of particles to index. For that, we need to define what a particle is. For this purpose, a Particle struct is available in the code. It has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"w: the computational weight of the particle (in a fixed-weight DSMC simulation, this is the F_num parameter)\nv: the 3-dimensional velocity vector of the particle\nx: the 3-dimensional position vector of the particle","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Each species has its own list of particles associated with it, so a particles variable in the simulation could have the following the type Vector{Vector{Particle}}. Then particles[species_1] would correspond to the list of all particles of chemical species species_1. pia.indexer[cell,species_1] would then be used to index the particles of species_1 in a specific cell cell.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The drawback of using Vector{Vector{Particle}} is that for non-spatially homogeneous simulations, the particles need to be sorted after each convection step, and this would involving constantly re-writing the position and velocity vectors. To reduce the computational cost of sorting, an additional abstraction layer is added via the struct ParticleVector that is intended to be used instead of  a simple Vector{Particle} instance. An instance of ParticleVector has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"particles: the underlying vector of particles\nindex: the sorted indices of the particles\ncell: used in particle sorting to keep track of new assigned cells\nbuffer: a LIFO queue used to track which particles from particles are not being used (i.e. allocated in memory but not present in the simulation)\nnbuffer: the number of elements in buffer","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Given a ParticleVector instance pv, one can still transparently access a particle at index i as pv[i]. This access operation however uses the sorted index list to get the actual index of the particle, so pv[i] is equivalent to pv.particles[pv.index[i]]. During particle sorting, only the indices in index are shuffled around, which is computationally cheaper than sorting the particles directly.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"(Image: particle_vector_trim)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The figure above shows the how the underlying particles (top array) are indexed via the help of the index field of the ParticleVector struct, and finally how the indices of the particles in a specific cell are indexed by the ParticleIndexer instance. In the example above, the different colors correspond to different grid cells. It can be seen that the array of Particle instances (\"underlying Particle vector\") is unsorted. The indices (ParticleVector.index) are however sorted. Thus, ParticleVector.index[1] points to the 1-st particle in the underlying Particle array, and ParticleVector.index[2] points to the 4-th particle.  ParticleVector.index[6] points to the 2-nd particle, and so on. It may be that due to creation of new particles during collisions some particles in the same cell are at the very end of the array (as they just got created). In the example above, particles 9 and 10 are in the same cell as particles 1, 4, 5, 7, 8. Therefore the corresponding ParticleIndexer instance for this cell will have start1=1, end1=5 (pointing to the first block of indices), and start2=9, end2=9 (pointing to the second block of indices).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"For all practical purposes, it should be sufficient to deal with particles in a ParticleVector instance pv by directly accessing them as pv[i]; the index and cell fields need to be changed only when one is writing new sorting routines.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"For a more in-depth overview of particle indexing, especially relevant for multi-dimensional simulations where particles might be frequently deleted due to merging or outflow, the reader is referred to the documentation on contiguous indexing, which describes additional concepts associated with the indexing approach used in Merzbild.jl and provides some tips on improving performance in the listed scenarios.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"To summarize, for multi-species multi-dimensional simulations, one needs to use a Vector{ParticleVector} instance, each element of which (of type ParticleVector) corresponds to a vector of particles of a specific species. If one does not intend to sort particles (i.e. a 0-D simulation), one can in theory use a simple Vector{Vector{Particle}} instance, however, some of the particle sampling routines assume a ParticleVector instance (as they write the cell index data).","category":"page"},{"location":"overview_blocks/#Physical-data:-Species","page":"Overview of basic building blocks","title":"Physical data: Species","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"To sample particles, we need to know some properties of the chemical species that they represent. This is done via instances of the Species struct, which have the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"name: the name of the species\nmass: the mass of the species\ncharge: the charge of the species (in terms of elementary charge)\ncharge_div_mass: the charge of the species (in Coulombs) divided by the mass of the species","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Data about chemical species can be loaded by using the load_species_data function, which reads a TOML file with the relevant species information.","category":"page"},{"location":"overview_blocks/#Sampling-particles","page":"Overview of basic building blocks","title":"Sampling particles","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to sample particles of a certain species from a specific distribution, Merzbild.jl provides several functions. For fixed-weight DSMC simulations, one can use the sample_particles_equal_weight! to sample equal-weight particles from either a Maxwell or a BKW distribution. For variable-weight DSMC simulations, one can of course also use the same function (there is no inherent difference between fixed- and variable-weight DSMC simulations in Merzbild).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"However, in case variable-weight particles are allowed, one can also sample them from a distribution by evaluating that distribution of a discrete velocity grid. This functionality is provided by the sample_on_grid! function and its more specific version sample_maxwellian_on_grid! that assumes a Maxwell distribution. Sampling on a grid can lead to very high particle counts (for example, sampling on a 30x30x30 grid will lead to creation of up to 27000 particles in each physical cell), so care must be taken, and particles might need to be merged immediately after having been created.","category":"page"},{"location":"overview_blocks/#Computing-macroscopic-physical-properties:-PhysProps","page":"Overview of basic building blocks","title":"Computing macroscopic physical properties: PhysProps","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now that we have a vector of particles, we can compute some macroscopic properties (density, velocity, etc.). To store and use these properties where they might be needed, the PhysProps struct is provided. An instance of PhysProps has the following fields:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"ndens_not_Np: a boolean value used to distinguish between the meanings of the n field (see below) and ensure consistency\nn_cells: number of grid cells\nn_species: number of species in the simulation\nn_moments: number of total moments computed (see below how moments are defined)\nlpa: vector of length n_species storing the lengths of the particle arrays (i.e. how many elements have been allocated, actual particle counts may be less)\nnp: array with dimensions n_cells*n_species, stores the number of particles of each species in each grid cell\nn: array with dimensions n_cells*n_species, stores either the number of physical particles of each species in each grid cell or the number density of each species in each grid cell, see below for explanation\nv: array with dimensions 3*n_cells*n_species, stores the x, y, and z components of the macroscopic velocity of each species in each grid cell \nT: array with dimensions n_cells*n_species, stores the temperature of each species in each grid cell\nmoment_powers: vector of length n_moments, stores which total moments are being computed\nmoments: array with dimensions n_moments*n_cells*n_species, stores the total moments of each species in each grid cell\nTref: a reference temperature set during initialization of a PhysProps instance used to scale the moments so that for an equilibrium distribution at a temperature of T_ref all moments are equal to 1.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"One can see that the definition of the n field is somewhat ambiguous - it can either mean the total number of particles in a cell, or the number density in a cell (equal to the number of particles in the cell divided by the cell volume). To distinguish between these two cases, the following convention is assumed, one can provide a value of ndens_not_NP during instantiation (by default it is false, i.e. the number of physical particles is computed and not the number density).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"If we don't need to compute the total moments, then we can create a PhysProps instance by simply passing a ParticleIndexerArray instance to the constructor, as it already has the required information on the number of grid cells and species. So we can simply do this: props = PhysProps(pia).","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The compute_props! function computes the macroscopical physical properties of all species in all cells in the simulation. Currently this computes only the number of particles in a cell, regardless of the value of the ndens_not_Np field.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"There is an optimized version of this function, which assumes the particles are only indexed by the first group of a ParticleIndexer instance: compute_props_sorted!; it also does not computed any moments. This is the case immediately after sorting the particles on a grid. If a grid is passed as a parameter, it will compute either the number of particles in a cell or the number density in a cell depending on the value of ndens_not_NP field of the PhysProps instance passed to the function.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The avg_props! function can also be used to time-average physical properties; this requires use of two PhysProps instances, one of which holds the values of the physical properties at the current timestep, and the other one holds the values of the averaged physical properties. Similarly to the previous case, trying to average one PhysProps instance \"into\" another PhysProps instance with a different value of the ndens_not_NP field will raise an error.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"The total moment of order N is defined as","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"M_N = frac1sum_i w_isum_i w_i left(v_xi^2+v_yi^2+v_zi^2right)^fracN2","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Here the summation is over all particles of a specific species in a particular grid cell. Since computing the moments is expensive, a different function needs to be called to compute all the physical properties and the moments: compute_props_with_total_moments!. If it is called and a PhysProps instance with n_moments = 0 is passed to it, it will fall back to the standard compute_props! to avoid unnecessary computations.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Support for computing mixed moments of the form ","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"M_abc = frac1sum_i w_isum_i w_i v_xi^a v_yi^b v_zi^c","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"is planned in future versions of Merzbild.jl.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"NOTE: the computation of total moments is planned to be decoupled from PhysProps and moved into a separate structure.","category":"page"},{"location":"overview_blocks/#Writing-output:-NCDataHolder","page":"Overview of basic building blocks","title":"Writing output: NCDataHolder","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Finally, once the properties have been computed, we need to output them. Merzbild.jl uses the binary NetCDF format for its output, specifically the NetCDF4 version of the format. The functionality is provided by the NetCDF.jl and NCDatasets.jl libraries. The testing code relies on NCDatasets.jl as originally Merzbild.jl used the library throughout the whole code; however, the NetCDF.jl library was found to be significantly faster when used for output, so all the non-testing code has been ported to NetCDF.jl. The NCDatasets.jl dependency will be dropped in a future version once tests are ported to NetCDF.jl.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to write the physical properties to a NetCDF file, one needs to create an NCDataHolder instance. It keeps track of the variables being output, the file handle, and the number of times data has been written to a file. It also keeps track of whether the ndens output variable actually corresponds to the number of particles in a cell or to the number density in a cell, based on the flag in the PhysProps instance used to initialize the NCDataHolder instance. (In a future version of Merzbild.jl, it is planned to change the output variable name based on the ndens_not_Np flag value in the PhysProps instance used in the constructor.)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"We can construct an NCDataHolder instance like this:","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"NCDataHolder(\"output_filename.nc\", species_data, phys_props)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Additional global attributes can be written to the file if they are passed as a dictionary using the global_attributes keyword of the constructor. Additionally, it is possible to pass a list of variable names that should be skipped during output (i.e. they won't be written to the NetCDF file), a more detailed description is given in the public API reference.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In order to write the physical properties to a file at a certain timestep, we need to call","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"write_netcdf(ds, phys_props, timestep)","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Here ds is the NCDataHolder instance, and timestep is the number of the timestep of the simulation (it also gets written to the output). Additionally, the sync_freq keyword parameter can be set to control how often the file is flushed (synchronized) to disk.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Finally, at the end of the simulation we need to close the file, so we call","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"close_netcdf(ds)","category":"page"},{"location":"overview_blocks/#Computing-surface-properties-due-to-particle-surface-interactions:-SurfProps","page":"Overview of basic building blocks","title":"Computing surface properties due to particle-surface interactions: SurfProps","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Details on calculation of surface properties due to particle-surface interactions can be found in the section on 1D DSMC simulations. Time-averaging works exactly the same as for PhysProps, via use of the avg_props function. Output is performed similarly, via an NCDataHolderSurf struct and calls to write_netcdf_surf_props.","category":"page"},{"location":"overview_blocks/#Example:-bringing-it-all-together","page":"Overview of basic building blocks","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"An example of particle sampling, property computation, and output for a 0-D single-species gas is presented here.","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"using Merzbild\nusing Random\n\n# set our random seed for reproducibility\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# load particle data\nparticles_data_path = joinpath(\"data\", \"particles.toml\")\nspecies_data = load_species_data(particles_data_path, \"Ar\")\n\n# init particle vector for a 1000 particles\nn_particles = 1000\nparticles = [ParticleVector(n_particles)]\n\n# set number density to 1e23\nndens = 1e23\n\n# and compute the particle weight Fnum\nFnum = ndens / n_particles\n\n# set particle temperature\nT = 500.0\n\n# create the particle indexer array for 1 cell and 1 species, assume 0 particles since we haven't\n# sampled any particles yet\npia = ParticleIndexerArray(0)\n\n# sample particles in a [0.0, 1.0]x[0.0, 1.0]x[0.0, 1.0] cell\nsample_particles_equal_weight!(rng, particles[1], pia, 1, 1, n_particles, T, species_data[1].mass, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0; distribution=:Maxwellian)\n\n# create struct for computation of physical properties\nphys_props = PhysProps(pia)\n\n# create struct for netCDF output\nds = NCDataHolder(\"output.nc\", species_data, phys_props)\n\n# compute physical properties \ncompute_props!(particles, pia, species_data, phys_props)\n\n# and output them (t=0)\nwrite_netcdf_phys_props(ds, phys_props, 0)\nclose_netcdf(ds)","category":"page"},{"location":"overview_blocks/#Summary","page":"Overview of basic building blocks","title":"Summary","text":"","category":"section"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Now we have an overview of how to","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"Create a structure to hold particles\nIndex the vector of particles\nLoad species' data\nSample particles from a distribution\nCompute macroscopic physical properties\nOutput these properties to disk","category":"page"},{"location":"overview_blocks/","page":"Overview of basic building blocks","title":"Overview of basic building blocks","text":"In the next section, an overview of how to simulate collisions will be given.","category":"page"},{"location":"overview_capabilities/#Overview-of-capabilities","page":"Overview of capabilities","title":"Overview of capabilities","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"This page provides an overview of the main capabilities of the code.","category":"page"},{"location":"overview_capabilities/#Grids,-fixed-and-variable-weight-DSMC","page":"Overview of capabilities","title":"Grids, fixed and variable weight DSMC","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":" 0D 1D\nFixed-weight DSMC ✅ ✅\nVariable-weight DSMC ✅ ✅","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Currently, simulations are either 0D (spatially homogeneous) or on a uniform 1D grid. For 1D simulations, specular and diffuse reflection models are available (along with a mixture of the two via an accommodation coefficient).","category":"page"},{"location":"overview_capabilities/#Collisions","page":"Overview of capabilities","title":"Collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The No-Time-Counter (NTC) approach of Bird (1994) is implemented for fixed-weight DSMC. The variable-weight NTC approach of Schmidt and Rutland (2000) is implemented for variable-weight DSMC. Event splitting (Oblapenko et al. (2022)) is implemented for neutral-electron interactions.","category":"page"},{"location":"overview_capabilities/#Fokker-Planck-collisions","page":"Overview of capabilities","title":"Fokker-Planck collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"As an alternative to DSMC, one can use the stochastic Fokker-Planck algorithm to simulate the particle collisions. Currently, the linear Fokker-Planck model of Gorhi, Torrilhon, and Jenny (2011) is implemented for fixed-weight particles.","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":" Linear Cubic\nFixed-weight Fokker-Planck ✅ ❌\nVariable-weight Fokker-Planck ❌ ❌","category":"page"},{"location":"overview_capabilities/#Particle-merging-algorithms","page":"Overview of capabilities","title":"Particle merging algorithms","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The following particle merging algorithms are available for variable-weight DSMC simulations:","category":"page"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"A grid-based merging algorithm as described in Oblapenko et al. (2020) (see also Vranic et al. (2015))\nThe octree merging algorithm of Martin and Cambier (2016)\nA Non-Negative Least Squares (NNLS)-based merging approach described in Oblapenko (2024)","category":"page"},{"location":"overview_capabilities/#Cross-sections","page":"Overview of capabilities","title":"Cross-sections","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The Variable-Hard Sphere (VHS) model is implemented for collisions of neutral particles. For neutral-electron collisions, LXCat data in XML format needs to be provided for the elastic scattering and electron-impact ionization cross-sections. Currently, only isotropic scattering is implemented for neutral-electron collisions.","category":"page"},{"location":"overview_capabilities/#Inelastic-collisions","page":"Overview of capabilities","title":"Inelastic collisions","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"In flows with neutrals, ions, and electrons, electron-impact ionization is supported. Variable weight DSMC simulations also support the Event Splitting (ES) collision algorithm of Oblapenko et al. (2022).","category":"page"},{"location":"overview_capabilities/#External-fields","page":"Overview of capabilities","title":"External fields","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Acceleration of charged particles by a constant electric field is supported.","category":"page"},{"location":"overview_capabilities/#I/O","page":"Overview of capabilities","title":"I/O","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"The code assumes the TOML format for the particle and VHS interaction data. XML is used for the LXCat data. Output of the computed macroscopic properties is in NetCDF4 format.","category":"page"},{"location":"overview_capabilities/#Parallel-computations","page":"Overview of capabilities","title":"Parallel computations","text":"","category":"section"},{"location":"overview_capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Multithreading is supported via domain decomposition, see the section on setting up multithreaded simulations for more details. Multithreaded variable-weight DSMC computations have not been tested yet.","category":"page"},{"location":"benchmarks/#Merzbild.jl-benchmarks","page":"Benchmarks","title":"Merzbild.jl benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Various benchmarks and comparisons to other open-source codes are provided here for reference test cases.","category":"page"},{"location":"benchmarks/#Couette-flow,-serial,-small-grid","page":"Benchmarks","title":"Couette flow, serial, small grid","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comparison with SPARTA are provided for a single-species (argon) Couette flow test case with 50000 particles and 50 cells (averaging over 36k timesteps after t>14000). The computation is serial. Timing in Merzbild.jl providedd by TimerOutputs.jl, timing in SPARTA provided by the inbuilt timers. No surface quantities are being computed. The input can be found in simulations/1D/couette_benchmarking.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Merzbild.jl version 0.7.0, run with  --check-bounds=no -O3.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"SPARTA version 20Jan2025, compiled with -O3.","category":"page"},{"location":"benchmarks/#Intel-Core-i9-13900K,-128-GB-RAM","page":"Benchmarks","title":"Intel Core i9-13900K, 128 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Ubuntu 22.04.5, Julia version 1.11.2, SPARTA compiled with gcc version 11.4.0.","category":"page"},{"location":"benchmarks/#Merzbild.jl","page":"Benchmarks","title":"Merzbild.jl","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"──────────────────────────────────────────────────────────────────────────\n                                 Time                    Allocations      \n                        ───────────────────────   ────────────────────────\n   Tot / % measured:         28.4s /  97.3%            126MiB /   9.8%    \n\nSection         ncalls     time    %tot     avg     alloc    %tot      avg\n──────────────────────────────────────────────────────────────────────────\nsort             50.0k    10.5s   37.9%   209μs     0.00B    0.0%    0.00B\nconvect          50.0k    6.29s   22.8%   126μs     0.00B    0.0%    0.00B\ncollide          2.50M    5.90s   21.3%  2.36μs     0.00B    0.0%    0.00B\nprops compute    36.0k    4.88s   17.7%   136μs     0.00B    0.0%    0.00B\nI/O                  1   85.4ms    0.3%  85.4ms   9.32MiB   75.3%  9.32MiB\navg physprops    36.0k   5.54ms    0.0%   154ns     0.00B    0.0%    0.00B\nsampling             1   2.52ms    0.0%  2.52ms   3.05MiB   24.7%  3.05MiB\n──────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#SPARTA","page":"Benchmarks","title":"SPARTA","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Loop time of 30.4417 on 1 procs for 50000 steps with 50000 particles\n\nMPI task timing breakdown:\nSection |  min time  |  avg time  |  max time  |%varavg| %total\n---------------------------------------------------------------\nMove    | 8.0618     | 8.0618     | 8.0618     |   0.0 | 26.48\nColl    | 10.862     | 10.862     | 10.862     |   0.0 | 35.68\nSort    | 2.793      | 2.793      | 2.793      |   0.0 |  9.18\nComm    | 0.0034328  | 0.0034328  | 0.0034328  |   0.0 |  0.01\nModify  | 8.719      | 8.719      | 8.719      |   0.0 | 28.64\nOutput  | 0.00057459 | 0.00057459 | 0.00057459 |   0.0 |  0.00\nOther   |            | 0.002392   |            |       |  0.01","category":"page"},{"location":"benchmarks/#M1-Pro-(Macbook-Pro),-32-GB-RAM","page":"Benchmarks","title":"M1 Pro (Macbook Pro), 32 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"MacOS 15.4.1, Julia version 1.11.2, SPARTA compiled with Apple clang version 17.0.0.","category":"page"},{"location":"benchmarks/#Merzbild.jl-2","page":"Benchmarks","title":"Merzbild.jl","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"──────────────────────────────────────────────────────────────────────────\n                                 Time                    Allocations      \n                        ───────────────────────   ────────────────────────\n   Tot / % measured:         33.5s /  97.7%            125MiB /   9.9%    \n\nSection         ncalls     time    %tot     avg     alloc    %tot      avg\n──────────────────────────────────────────────────────────────────────────\nsort             50.0k    11.6s   35.5%   232μs     0.00B    0.0%    0.00B\ncollide          2.50M    8.01s   24.4%  3.20μs     0.00B    0.0%    0.00B\nconvect          50.0k    7.44s   22.7%   149μs     0.00B    0.0%    0.00B\nprops compute    36.0k    5.60s   17.1%   156μs     0.00B    0.0%    0.00B\nI/O                  1   91.8ms    0.3%  91.8ms   9.30MiB   75.3%  9.30MiB\navg physprops    36.0k   5.33ms    0.0%   148ns     0.00B    0.0%    0.00B\nsampling             1   2.78ms    0.0%  2.78ms   3.05MiB   24.7%  3.05MiB\n──────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#SPARTA-2","page":"Benchmarks","title":"SPARTA","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Loop time of 47.4825 on 1 procs for 50000 steps with 50000 particles\n\nMPI task timing breakdown:\nSection |  min time  |  avg time  |  max time  |%varavg| %total\n---------------------------------------------------------------\nMove    | 12.001     | 12.001     | 12.001     |   0.0 | 25.28\nColl    | 13.299     | 13.299     | 13.299     |   0.0 | 28.01\nSort    | 2.8246     | 2.8246     | 2.8246     |   0.0 |  5.95\nComm    | 0.0020463  | 0.0020463  | 0.0020463  |   0.0 |  0.00\nModify  | 19.352     | 19.352     | 19.352     |   0.0 | 40.76\nOutput  | 0.0019748  | 0.0019748  | 0.0019748  |   0.0 |  0.00\nOther   |            | 0.0009062  |            |       |  0.00","category":"page"},{"location":"benchmarks/#Couette-flow,-serial,-large-grid","page":"Benchmarks","title":"Couette flow, serial, large grid","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The physical parameters for this test case are the same as for the previous one, but a larger (2000 cells) grid is used, with 250 particles per cell at t=0. So the number of grid cells is 40x higher than for the small grid test case, and the number of particles is 10x higher.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In addition, surface properties are also computed and averaged. The numerical setup corresponds to the simulations/1D/couette_with_surface_quantities.jl file with the following parameters parameters for the run command:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"run(1234, 300.0, 500.0, 5e-4, 5e22, 2000, 250, 2.59e-9, 1000, 50000, 14000; do_benchmark=true)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Setting do_benchmark to true turns off computation of the degree of particle index fragmentation.","category":"page"},{"location":"benchmarks/#Intel-Core-i9-13900K,-128-GB-RAM-2","page":"Benchmarks","title":"Intel Core i9-13900K, 128 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Ubuntu 22.04.5, Julia version 1.11.2, SPARTA compiled with gcc version 11.4.0.","category":"page"},{"location":"benchmarks/#Merzbild.jl-3","page":"Benchmarks","title":"Merzbild.jl","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"──────────────────────────────────────────────────────────────────────────────────────\n                                             Time                    Allocations      \n                                    ───────────────────────   ────────────────────────\n         Tot / % measured:                795s /  99.5%            192MiB /  17.1%    \n\nSection                     ncalls     time    %tot     avg     alloc    %tot      avg\n──────────────────────────────────────────────────────────────────────────────────────\nsort                         50.0k     269s   34.0%  5.37ms     0.00B    0.0%    0.00B\nconvect + surface compute    36.0k     209s   26.4%  5.80ms   2.20MiB    6.7%    64.0B\nprops compute                36.0k     131s   16.6%  3.63ms     0.00B    0.0%    0.00B\ncollide                       100M     114s   14.4%  1.14μs     0.00B    0.0%    0.00B\nconvect                      14.0k    68.1s    8.6%  4.86ms     0.00B    0.0%    0.00B\navg physprops                36.0k    196ms    0.0%  5.43μs     0.00B    0.0%    0.00B\nsampling                         1   35.1ms    0.0%  35.1ms   30.5MiB   93.3%  30.5MiB\navg surfprops                36.0k   12.6ms    0.0%   351ns     0.00B    0.0%    0.00B\nI/O                             15   2.26ms    0.0%   151μs   3.58KiB    0.0%     244B\n──────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#SPARTA-3","page":"Benchmarks","title":"SPARTA","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Loop time of 1155.34 on 1 procs for 50000 steps with 500000 particles\n\nMPI task timing breakdown:\nSection |  min time  |  avg time  |  max time  |%varavg| %total\n---------------------------------------------------------------\nMove    | 598.55     | 598.55     | 598.55     |   0.0 | 51.81\nColl    | 262.52     | 262.52     | 262.52     |   0.0 | 22.72\nSort    | 87.103     | 87.103     | 87.103     |   0.0 |  7.54\nComm    | 0.018935   | 0.018935   | 0.018935   |   0.0 |  0.00\nModify  | 207.14     | 207.14     | 207.14     |   0.0 | 17.93\nOutput  | 0.002845   | 0.002845   | 0.002845   |   0.0 |  0.00\nOther   |            | 0.01218    |            |       |  0.00","category":"page"},{"location":"benchmarks/#M1-Pro-(Macbook-Pro),-32-GB-RAM-2","page":"Benchmarks","title":"M1 Pro (Macbook Pro), 32 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"MacOS 15.4.1, Julia version 1.11.2, SPARTA compiled with Apple clang version 17.0.0.","category":"page"},{"location":"benchmarks/#Merzbild.jl-4","page":"Benchmarks","title":"Merzbild.jl","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"──────────────────────────────────────────────────────────────────────────────────────\n                                             Time                    Allocations      \n                                    ───────────────────────   ────────────────────────\n         Tot / % measured:               1164s /  99.5%            190MiB /  17.2%    \n\nSection                     ncalls     time    %tot     avg     alloc    %tot      avg\n──────────────────────────────────────────────────────────────────────────────────────\nconvect + surface compute    36.0k     359s   31.0%  10.0ms   2.20MiB    6.7%    64.0B\nsort                         50.0k     337s   29.0%  6.73ms     0.00B    0.0%    0.00B\nprops compute                36.0k     181s   15.6%  5.02ms     0.00B    0.0%    0.00B\ncollide                       100M     171s   14.8%  1.71μs     0.00B    0.0%    0.00B\nconvect                      14.0k     110s    9.5%  7.87ms     0.00B    0.0%    0.00B\navg physprops                36.0k    198ms    0.0%  5.51μs     0.00B    0.0%    0.00B\nsampling                         1   26.1ms    0.0%  26.1ms   30.5MiB   93.3%  30.5MiB\navg surfprops                36.0k   14.8ms    0.0%   410ns     0.00B    0.0%    0.00B\nI/O                             15   1.77ms    0.0%   118μs   3.58KiB    0.0%     244B\n──────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#SPARTA-4","page":"Benchmarks","title":"SPARTA","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Loop time of 1418.29 on 1 procs for 50000 steps with 500000 particles\n\nMPI task timing breakdown:\nSection |  min time  |  avg time  |  max time  |%varavg| %total\n---------------------------------------------------------------\nMove    | 885.53     | 885.53     | 885.53     |   0.0 | 62.44\nColl    | 274.42     | 274.42     | 274.42     |   0.0 | 19.35\nSort    | 45.409     | 45.409     | 45.409     |   0.0 |  3.20\nComm    | 0.0055656  | 0.0055656  | 0.0055656  |   0.0 |  0.00\nModify  | 212.91     | 212.91     | 212.91     |   0.0 | 15.01\nOutput  | 0.0032787  | 0.0032787  | 0.0032787  |   0.0 |  0.00\nOther   |            | 0.006827   |            |       |  0.00","category":"page"},{"location":"benchmarks/#Couette-flow,-multi-threaded,-large-grid","page":"Benchmarks","title":"Couette flow, multi-threaded, large grid","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The numerical and physical parameters are the same as for the serial large grid case (2000 cells, 250 particles per cell at t=0). The simulation file is simulations/1D/couette_multithreaded.jl.","category":"page"},{"location":"benchmarks/#Intel-Core-i9-13900K,-128-GB-RAM-3","page":"Benchmarks","title":"Intel Core i9-13900K, 128 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Ubuntu 22.04.5, Julia version 1.11.2. Shown is the speed-up compared to a serial execution on the same computer (see above). DLB denotes dynamic load balancing (currently not used).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":" 2 cores 4 cores 8 cores\nn_chunks=n_threads, no DLB 1.85 3.24 5.06","category":"page"},{"location":"benchmarks/#M1-Pro-(Macbook-Pro),-32-GB-RAM-3","page":"Benchmarks","title":"M1 Pro (Macbook Pro), 32 GB RAM","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"MacOS 15.4.1, Julia version 1.11.2. Shown is the speed-up compared to a serial execution on the same computer (see above). DLB denotes dynamic load balancing (currently not used).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":" 2 cores 4 cores 8 cores\nn_chunks=n_threads, no DLB 2.27 3.75 5.76","category":"page"},{"location":"overview_varweight/#Variable-weight-DSMC-simulations","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"For variable-weight DSMC simulation not much is different compared to fixed-weight DSMC simulations. Existing routines for computation of macroscopic properties, I/O, and even collisions can be re-used, since they all do not explicitly assume fixed particle weights.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"Two additional things are required, however: a way to sample particles with variable weights, and an algorithm to merge particles to avoid a blow-up of the number of particles due to collisions.","category":"page"},{"location":"overview_varweight/#Sampling-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Sampling variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"In order to obtain variable-weight particles, one can either use the sample_particles_equal_weight! multiple times with different Fnum values, or one can use the  sample_on_grid! function and its more specific version sample_maxwellian_on_grid!, as mentioned in the Overview of basic building blocks section.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"These approaches compute the values of a VDF function on a discrete velocity grid and then re-interpret the grid points and associated VDF values as particles. Thus one can get a good resolution of high-velocity tails (with the particles there having small weights). The function constructs the velocity grid via a Cartesian product of discrete grids for each velocity direction. In each direction, the interval -v_msqrt2kTmv_msqrt2kTm is discretized into nv subintervals. Here the multiplier v_m is specified by the v_mult parameter; so the discrete velocity grid spans several mean thermal velocities. In addition, only particles with a speed less than c_m sqrt2kTm are actually created, where c_m is specified by the cutoff_mult parameter. Finally, numerical noise may be added to the velocity via the noise parameter, and a velocity offset via the v_offset parameter; the spatial distribution of the particles is randomized in the cell. The function returns the total number of particles sampled (which may be less than nv^3 depending on the choice of the value of cutoff_mult).","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"An example of such sampling is shown below:","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# our number density\nndens = 1e23 \n\n# our temperature\nT0 = 300.0  \n\n# load species and interaction data\nspecies_data = load_species_data(\"data/particles.toml\", \"Ar\")\ninteraction_data = load_interaction_data(\"data/pseudo_maxwell.toml\", species_data)\n\n# number of velocity grid points in each velocity direction\nnv = 20  \n\n# some initial guess on # of particles in simulation\nnp_base = 40^3  \n\nparticles = [ParticleVector(np_base)]\n\n# sample from a BKW distribution at t=0\nvdf0 = (vx, vy, vz) -> bkw(vx, vy, vz, species_data[1].mass, T0, 0.0)\n\n# returns number of particles sampled\nn_sampled = sample_on_grid!(rng, vdf0, particles[1], nv, species_data[1].mass, T0, ndens,\n                            0.0, 1.0, 0.0, 1.0, 0.0, 1.0;\n                            v_mult=3.5, cutoff_mult=3.5, noise=0.0, v_offset=[0.0, 0.0, 0.0])\n\n# create the ParticleIndexerArray\npia = ParticleIndexerArray(n_sampled)","category":"page"},{"location":"overview_varweight/#Colliding-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Colliding variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"As mentioned above, the existing DSMC routines take care of the required particle splitting, so no specific adaptation is required for the variable-weight case. However, one needs to estimate (sigma g w)_max. The simplest approach is to use estimate_sigma_g_w_max function, but it requires a (fixed) value of Fnum - so one can simply compute it as ndens/n_sampled (i.e. the number density divided by the total number of sampled particles).","category":"page"},{"location":"overview_varweight/#Merging-variable-weight-particles","page":"Variable-weight DSMC simulations","title":"Merging variable-weight particles","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"In order to merge variable-weight particles, one needs to set up a merging algorithm and the associated data structures and parameters. A more detailed overview of merging algorithms will appear later in a Tutorials section; here, the Octree merging approach of Martin and Cambier (2016) is used. The algorithm groups particles into bins in velocity space, recursively refining the bins until the number of post-merge particles reaches the prescribed value. It then performs an N2 merge in each bin, replacing all particles in a bin with 2 particles.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"To set up this merging algorithm, one needs to create a OctreeN2Merge instance, specifying","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"The extent of the first (root) bin - whether it accounts for the extent of the particles or whether it is just taken to be very large\nHow bins are split (along the middle velocity, the mean velocity, or the median velocity)\nWhether the velocity bounds of each sub-bin are recomputed based on the particles in the bin or are based purely on the bounds of the parent bin and the splitting velocity\nMaximum number of bins\nMaximum refinement depth","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"For example, we can create an octree merging instance that splits velocity bins across the middle, sets the root bin bounds to the bounding box of the particle velocities, and inherits the bin bounds of the parent bin when splitting a bin. We also immediately merge our particles, setting a target particle number of 100.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"# set up the merging algorithm\noc = OctreeN2Merge(OctreeBinMidSplit; init_bin_bounds=OctreeInitBinMinMaxVel,\n                   bin_bounds_compute=OctreeBinBoundsInherit, max_Nbins=6000)\n\n# set Ntarget\nNtarget = 100\n\n# perform merging\nmerge_octree_N2_based!(rng, oc, particles[1], pia, 1, 1, Ntarget)","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"We can check the number of particles after the merging procedure by looking at pia.indexer[1,1].n_local (the number of particles of species 1 in cell 1), which should be equal to 100.","category":"page"},{"location":"overview_varweight/#Example:-bringing-it-all-together","page":"Variable-weight DSMC simulations","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"Now we can put the variable-weight collisions and merging into a timestep loop, performing merging by when pia.indexer[1,1].n_local > Nthreshold, where Nthreshold is the threshold number of particles. Alternatively, one can check phys_props.np[1,1] > Nthreshold, in case the physical properties are computed frequently enough. The following simulation computes the BKW relaxation problem.","category":"page"},{"location":"overview_varweight/","page":"Variable-weight DSMC simulations","title":"Variable-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\nspecies_data = load_species_data(\"data/particles.toml\", [\"Ar\", \"He\"])\nn_species = length(species_data)\n\n# number of timesteps to run simulation for\nn_t = 5000\n\n# we will have the number density of argon = 1e15, the number density of helium = 5e15\nn_particles_Ar = 2000\nn_particles_He = 10000\nFnum = 5e11\n\n# initial temperatures\nT0_Ar = 300.0\nT0_He = 2000.0\nT0_list = [T0_Ar, T0_He]\n\n# create the 2-element Vector of ParticleVectors for the 2 species\nparticles = [ParticleVector(n_particles_Ar), ParticleVector(n_particles_He)]\n\n# create the 2-species 1-cell particle indexer array filled with zeros\n# as we haven't sampled any particles yet\npia = ParticleIndexerArray([0, 0])\n\n# sample particles from a Maxwellian distribution\nsample_particles_equal_weight!(rng, particles[1], pia, 1, 2, n_particles_Ar,\n                               species_data[1].mass, T0_Ar, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\nsample_particles_equal_weight!(rng, particles[2], pia, 1, 2, n_particles_He,\n                               species_data[2].mass, T0_He, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\n\n\n# create the PhysProps instance to store computed properties\nphys_props = PhysProps(1, 2, [], Tref=T0_Ar)\n\n# create struct for I/O\nds = NCDataHolder(\"2species.nc\", species_data, phys_props)\n\n# compute and write physical properties at t=0\ncompute_props!(particles, pia, species_data, phys_props)\nwrite_netcdf(ds, phys_props, 0)\n\n# load interaction data\ninteraction_data = load_interaction_data(\"data/vhs.toml\", species_data)\n\n# create the 3-D array of collision factors\ncollision_factors::Array{CollisionFactors, 3} = create_collision_factors_array(n_species)\n\n# create the structure to store temporary collision data\ncollision_data = CollisionData()\n\n# estimate  (σ(g) * g * w)_max\nestimate_sigma_g_w_max!(collision_factors, interaction_data, species_data, T0_list, Fnum)\n\n# set our timestep\nΔt = 2.5e-3\n\n# set cell volume to 1.0 as we're doing a 0-D simulation\nV = 1.0\n\nfor ts in 1:n_t  # loop over time\n    for s2 in 1:n_species  # loop over first species\n        for s1 in s2:n_species  # loop over second species\n            if (s1 == s2)\n                # collisions between particles of same species\n                ntc!(rng, collision_factors[s1,s1,1], collision_data,\n                     interaction_data, particles[s1], pia, 1, s1, Δt, V)\n            else\n                # collisions between particles of different species\n                ntc!(rng, collision_factors[s1,s2,1], collision_data,\n                     interaction_data, particles[s1], particles[s2],\n                     pia, 1, s1, s2, Δt, V)\n            end\n        end\n    end\n\n    # we don't do convection, so we can take advantage of the fact that the particles stay sorted\n    # and compute the physical properties slightly faster without having to sort the particles\n    compute_props_sorted!(particles, pia, species_data, phys_props)\n\n    # write to output\n    write_netcdf(ds, phys_props, ts)\nend\n\n# close output file\nclose_netcdf(ds)","category":"page"},{"location":"contiguous_indexing/#Particle-buffers-and-contiguous-indexing","page":"Contiguous indexing","title":"Particle buffers and contiguous indexing","text":"","category":"section"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"This section discusses some more advanced concepts and associated issues concerning particle indexing in scenarios where particle counts may become lower during the course of a simulation.","category":"page"},{"location":"contiguous_indexing/#Particle-buffer","page":"Contiguous indexing","title":"Particle buffer","text":"","category":"section"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"As discussed in the overview of the basic building blocks of Merzbild.jl, a ParticleVector instance has a particles vector, an index array to index the particles, and buffer array to keep track of which particles in the particles vector are unused (as a LIFO queue).","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So to create a new particle in the simulation (assuming the ParticleVector instance pv has enough unused pre-allocated particles, otherwise one needs to call resize! first), one needs to do the following:","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Update the pia structure to keep track for which species in which cell and group the particle is being created\nGrab the index of the appropriate element in the buffer: i = pv.buffer[pv.nbuffer]  and decrease the number of elements in the buffer (pv.nbuffer -= 1)\nWrites this index i to the last position in the index array (the particle count in pia has already been updated):  pv.index[pia.n_total[species]] = i. ","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"A utility function update_buffer_index_new_particle! is available which takes care of all of these steps.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Summary: one needs to be aware of the buffer when creating new particles, to avoid any issues with over-writing existing particles.","category":"page"},{"location":"contiguous_indexing/#Contiguous-indexing","page":"Contiguous indexing","title":"Contiguous indexing","text":"","category":"section"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"One can iterate through all the particles in a simulation of a specific species by going through all the cells and then going through all the groups of particles:","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"for cell in 1:grid.n_cells\n    s = pia.indexer[cell, species].start1\n    e = pia.indexer[cell, species].end1\n    \n    for i in s:e\n        do_something!(particles[i])\n    end\n\n    if pia.indexer[cell, species].n_group2 > 0\n        s = pia.indexer[cell, species].start2\n        e = pia.indexer[cell, species].end2\n    \n        for i in s:e\n            do_something!(particles[i])\n        end\n    end\nend","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"However, it is more efficient to iterate in the following manner:","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"for i in 1:pia.n_total[species]\n    do_something!(particles[i]) \nend","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"This however requires the indexing to be contiguous, which means the following should hold:","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"pia.indexer[cell,species].end1 + 1 == pia.indexer[cell+1,species].start1, cell = 1,...,n_cells - 1\npia.indexer[n_cells,species].end1 + 1 == pia.indexer[1,species].start2\npia.indexer[cell,species].end2 + 1 == pia.indexer[cell+1,species].start2, cell = 1,...,n_cells - 1.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So this basically correspond to the indexing as defined by the indexer having no \"holes\". For this purposes, pia has the boolean contiguous property, which can be checked to decided how to iterate over particles.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"It is expected that a particle sorting routine restores continuity of indices. There is also a utility function squash_pia! which restores continuity of indices by moving around the indices in a ParticleVector instance, as well as the starts and ends of groups in the pia particle indexing structure.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Summary: If iterating over particles in more than one cell, one should not assume that the particle indices are contiguous, and the value of pia.contiguous should be checked first. Particle sorting or a call to squash_pia! restore continuity of indices.","category":"page"},{"location":"contiguous_indexing/#Deleting-particles","page":"Contiguous indexing","title":"Deleting particles","text":"","category":"section"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So how do these holes in the indexing actually appear?","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Deletion happens at the end of the group, if not, the ordering of the particles is changed by changing around the indices so that the particle to be deleted moves to the end of the group and then is deleted.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"A function delete_particle! is provided which does exactly this. A more specialized function delete_particle_end! deletes the last particle in the group.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So a hole might appear in the indexing if one is doing particle merging. For example, let's say we have 20 particles in two cells with 10 particles per cell, and the indexing looks like this: pia.indexer[1,1].start1 = 1, pia.indexer[1,1].end1 = 10, pia.indexer[2,1].start1 = 11,  pia.indexer[2,1].end1 = 20. If we merge particles in cell 1 down to 2 particles, the buffer in the ParticleVector instance pv will be updated, and pia.indexer[1,1].end1 will be set to 2, but the particles pv[3:10] can't be really accessed or used, unless we either 1) sort the particles 2) call squash_pia!. Some computations currently used the number of particles of a certain species to find where to place a newly created particle (for example, in the variable-weight NTC collision functions); without restoring continuity of the indexing, this will lead to erroneous results, as now the index of the last particle in the simulation pv[20] is no longer the same as the total number of particles in the simulation (which is 12 after the merge).","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So, for a multi-dimensional simulation with variable-weight DSMC, the correct collide-merge procedure might take on the following form:","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"\nfor cell in 1:grid.n_cells\n    ntc!(rng, collision_factors[1, 1, cell],\n         collision_data, interaction_data, particles[1], pia, cell, 1, Δt, grid.cells[cell].V)\n\n    if pia.indexer[cell,1].n_local > merge_threshold\n        # we need to merge\n        merge_octree_N2_based!(rng, oc, particles[1], pia, cell, 1, merge_target, grid)\n        # restore continuity of pia\n        squash_pia!(particles, pia)\n    end\nend","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"So if no merging took place, then no particle deletion happened, and one doesn't need to call squash_pia!. Of course, squash_pia! checks the value of pia.contiguous and does nothing if that value is set to true.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Summary: one needs to restore continuity of particle indexing if particles are deleted and created in a simulation, otherwise this might lead to erroneous results.","category":"page"},{"location":"contiguous_indexing/#Debugging","page":"Contiguous indexing","title":"Debugging","text":"","category":"section"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"Several utility functions are available to verify/help debug simulations.","category":"page"},{"location":"contiguous_indexing/","page":"Contiguous indexing","title":"Contiguous indexing","text":"pretty_print_pia prints out the start/end indices for all groups in all cells for particles of a given species. check_pia_is_correct verifies that the indexing of groups is consistent. check_unique_index checks that no two indices point to the same particle, as well as that no particles in the buffer are pointed to by indices used in the simulation. This function allocates a temporary array and is therefore slow for large numbers of particles.","category":"page"},{"location":"modelling_ionization/#Modelling-ionization-reactions","page":"Modelling ionization reactions","title":"Modelling ionization reactions","text":"","category":"section"},{"location":"modelling_ionization/","page":"Modelling ionization reactions","title":"Modelling ionization reactions","text":"Under construction...","category":"page"},{"location":"reference_public/#Merzbild.jl-public-API-reference","page":"Public API reference","title":"Merzbild.jl public API reference","text":"","category":"section"},{"location":"reference_public/#Particles","page":"Public API reference","title":"Particles","text":"","category":"section"},{"location":"reference_public/#Merzbild.Particle","page":"Public API reference","title":"Merzbild.Particle","text":"Particle\n\nA structure to store information about a single particle.\n\nFields\n\nw: the computational weight of the particle\nv: the 3-dimensional velocity vector of the particle\nx: the 3-dimensional position of the particle\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleVector","page":"Public API reference","title":"Merzbild.ParticleVector","text":"ParticleVector\n\nThe structure used to store particles, sort and keep track of particle indices, and keep track of unused particles. The lengths of the particles, index, cell, and buffer vectors are all the same (and stay the same during resizing of a ParticleVector instance). Only the first nbuffer elements of the buffer vector store indices of the actually unused particles.\n\nAccessing ParticleVector[i] will return a Particle, with the actual particle returned being ParticleVector.particles[ParticleVector.index[i]].\n\nFields\n\nparticles: the vector of particles of a single species\nindex: the vector of indices of the particles (these are sorted in grid sorting, not the particles themselves)\ncell: the vector storing information in which cell a particle is located (used in grid sorting routines)\nbuffer: a last-in-first-out (LIFO) queue keeping track of pre-allocated but unused particles\nnbuffer: the number of elements in the buffer\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleVector-Tuple{Any}","page":"Public API reference","title":"Merzbild.ParticleVector","text":"ParticleVector(np)\n\nCreate an empty ParticleVector instance of length np (all vectors will have length np).\n\nPositional arguments\n\nnp: the length of the ParticleVector instance to create\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Base.getindex-Tuple{ParticleVector, Any}","page":"Public API reference","title":"Base.getindex","text":"Base.getindex(pv::ParticleVector, i)\n\nReturns the underlying particle in a ParticleVector instance with index i.\n\nIs usually called as ParticleVector[i].\n\nPositional arguments\n\npv: ParticleVector instance\ni: the index of the particle to be selected\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Base.setindex!-Tuple{ParticleVector, Particle, Integer}","page":"Public API reference","title":"Base.setindex!","text":"Base.setindex!(pv::ParticleVector, p::Particle, i::Integer)\n\nSet the underlying particle in a ParticleVector instance with index i to a new particle.\n\nIs usually called as ParticleVector[i] = p.\n\nPositional arguments\n\npv: ParticleVector instance\np: the Particle instance to write\ni: the index of the particle to be written to\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Base.length-Tuple{ParticleVector}","page":"Public API reference","title":"Base.length","text":"Base.length(pv::ParticleVector)\n\nReturns the length of a ParticleVector instance.\n\nIs usually called as length(ParticleVector).\n\nPositional arguments\n\npv: ParticleVector instance\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Base.resize!-Tuple{ParticleVector, Integer}","page":"Public API reference","title":"Base.resize!","text":"Base.resize!(pv::ParticleVector, n::Integer)\n\nResize a ParticleVector instance.\n\nIs usually called as resize!(ParticleVector, n).\n\nPositional arguments\n\npv: ParticleVector instance\nn: the new length of the ParticleVector instance (i.e. the length of all the vector fields of the instance)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Particle-indexing","page":"Public API reference","title":"Particle indexing","text":"","category":"section"},{"location":"reference_public/#Merzbild.ParticleIndexer","page":"Public API reference","title":"Merzbild.ParticleIndexer","text":"ParticleIndexer\n\nThe structure used to index particles of a given species in a given cell. It is assumed that the particle indices are contiguous; they may be split across two groups of contiguous indices.\n\nFields\n\nn_local: the number of particles in the cell\nstart1: the first index in the first group of particle indices\nend1: the last index in the first group of particle indices\nn_group1: the number of particles in the first group (n_group1 = end1 - start1 + 1)\nstart2: the first index in the second group of particle indices, if no particles are present   in the group, it should be <= 0\nend2: the last index in the second group of particle indices\nn_group2: the number of particles in the second group (n_group2 = end2 - start2 + 1,   unless no particles are present in the second group)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleIndexer-Tuple{}","page":"Public API reference","title":"Merzbild.ParticleIndexer","text":"ParticleIndexer()\n\nCreate an empty ParticleIndexer. end1 and end2 are set to -1, the other fields are set to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexer-Tuple{Any}","page":"Public API reference","title":"Merzbild.ParticleIndexer","text":"ParticleIndexer(n_particles)\n\nCreate a ParticleIndexer given a number of particles. All particles are in group 1, with indices starting from 1.\n\nPositional arguments\n\nn_particles: the number of particles\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexerArray","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray\n\nA structure to store an array of ParticleIndexer instances for each species in each cell. It also stores information about the whether the ParticleIndexer instances for each species are \"contiguous\". A set of ParticleIndexer instances (for a specific species) are \"contiguous\" if the following conditions are fulfilled (assuming all cells contain particles and in all cells have both n_group1>0 and n_group2>0, for a more detailed explanation, one is referred to the documentation on contiguous indexing):\n\npia.indexer[cell,species].end1 + 1 == pia.indexer[cell+1,species].start1, cell = 1,...,n_cells - 1\npia.indexer[n_cells,species].end1 + 1 == pia.indexer[1,species].start2\npia.indexer[cell,species].end2 + 1 == pia.indexer[cell+1,species].start2, cell = 1,...,n_cells - 1\n\nFields\n\nindexer: the array of size (n_cells, n_species) (number of grid cells * number of species in the simulation) storing the ParticleIndexer instances\nn_total: vector of length n_species storing the total number of particles of each species\ncontiguous: vector of length n_species storing a boolean flag whether the ParticleIndexer instances for a species are \"contiguous\"\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ParticleIndexerArray-Tuple{Matrix{ParticleIndexer}, Any}","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray(indexer_arr::Array{ParticleIndexer,2}, n_total)\n\nCreates a ParticleIndexerArray from a 2-D array of ParticleIndexer instances.\n\nPositional arguments\n\nindexer_arr: the 2-D array of ParticleIndexer instances\nn_total: the vector of the total number of particles of each species\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexerArray-Tuple{Integer, Integer}","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray(n_cells::Integer, n_species::Integer)\n\nCreate an empty ParticleIndexerArray given the number of cells and species\n\nPositional arguments\n\nn_cells: the number of grid cells\nn_species: the number of species\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexerArray-Tuple{Integer}","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray(n_particles::Integer)\n\nCreate a single-species/single-cell ParticleIndexerArray and set up the indexing for n_particles in group 1 in cell 1.\n\nPositional arguments\n\nn_particles: the number of particles (integer number)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexerArray-Tuple{T} where T<:(AbstractVector)","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray(n_particles::T) where T<:AbstractVector\n\nCreate a multi-species/single-cell ParticleIndexerArray and set up the indexing for n_particles[species] in group 1 in cell 1 for all species.\n\nPositional arguments\n\nn_particles: the number of particles of each species (vector-like)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ParticleIndexerArray-Tuple{Any, Array{Species}}","page":"Public API reference","title":"Merzbild.ParticleIndexerArray","text":"ParticleIndexerArray(grid, species_data::Array{Species}) where T<:AbstractVector\n\nCreate an empty multi-species/multi-cell ParticleIndexerArray.\n\nPositional arguments\n\ngrid: the simulation grid\nspecies_data: array of Species data for all of the species in the simulation\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.squash_pia!","page":"Public API reference","title":"Merzbild.squash_pia!","text":"squash_pia!(pv, pia, species)\n\nRestore the continuity of indices in a ParticleVector and associatedParticleIndexerArrayinstance for a specific species. If for this species the instance hascontiguous == true`, nothing will be done.\n\nPositional arguments\n\npv: the ParticleVector\npia: the ParticleIndexerArray instance\nspecies: the index of the species for which to restore continuity of indices\n\n\n\n\n\nsquash_pia!(particles, pia)\n\nRestore the continuity of indices in a list of ParticleVectors and the associated ParticleIndexerArray instance for all species. If for a specific species the instance has contiguous == true, nothing will be done.\n\nPositional arguments\n\nparticles: the list of ParticleVectors for all species in the flow\npia: the ParticleIndexerArray instance\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.count_disordered_particles","page":"Public API reference","title":"Merzbild.count_disordered_particles","text":"count_disordered_particles(pv, pia, species)\n\nCount number of particles of species for which pv.index[i] != i + offset(cell). The larger this count, the less orderly the layout of particles in memory, which can potentially lead to decreased performance. This only considers particles present in the simulation, i.e. i<=pia.n_total[species], assumes contiguous indexing, and that particles are only pointed to by the first group of a ParticleIndexer, which is the case after particles have been sorted.\n\nIn case use_offset is false, the value of offset is always 0, so the function simply counts all particles where pv.index[i] != i. If use_offset is set to true, for each cell cell, the offset is whilst iterating over the particles in a cell. So in case the indexing in a cell is simply offset by a constant value, or a subset of indices are offset by a constant value, and particles are still laid out continuously in memory, this provides a more accurate measurement of the degree of fragmentation of the particle array.\n\nPositional arguments\n\npv: the ParticleVector instance for which to compute the metric\npia: the ParticleIndexerArray instance\nspecies: the index of the species for which the metric is computed\n\nKeyword arguments\n\nuse_offset: whether to account for cell-specific offsets in the indexing\n\nReturns\n\nThe number of particles where the index to the index array and the value of the index array do not coincide.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.check_unique_index","page":"Public API reference","title":"Merzbild.check_unique_index","text":"check_unique_index(pv, pia, species)\n\nTest that for all particles in a simulation, no two indices are the same, i.e. no two particles i and j, i!=j point to the same underlying particle. This function allocates a temporary array and is thus intended for debugging/verifying code and not for efficient simulations. It also checks that any particles present in the buffer are not pointed to by the indexing.\n\nPositional arguments\n\npv: the ParticleVector instance for which to check indexing\npia: the ParticleIndexerArray instance\nspecies: the species for which to check indexing\n\nReturns\n\nIf a particle exists to which more than 1 index is pointing, and particles in the buffer ARE NOT pointed to by the indicies, returns (false, n_index), where n_index is the number of indices pointing to the same particle.\n\nIf a particle exists to which more than 1 index is pointing, and particles in the buffer ARE pointed to by the indicies, returns (false, -n_index), where n_index is the number of indices pointing to the same particle.\n\nIf no particles exist to which more than 1 index is pointing, but a particle in a buffer is pointed to by the indexing, returns (false, -1).\n\nIf indexing is correct, returns (true, 0).\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.check_pia_is_correct","page":"Public API reference","title":"Merzbild.check_pia_is_correct","text":"check_pia_is_correct(pia, species)\n\nCheck that a ParticleIndexerArray instance entries are correct. This means that for each cell for each species, the following should hold:     * n_local == n_group1 + n_group2     * if n_group1 > 0, then n_group1 == end1 - start1 + 1     * if n_group1 == 0, then start1 == 0, end1 == -1     * if n_group2 > 0, then n_group1 == end2 - start2 + 1     * if n_group2 == 0, then start2 == 0, end2 == -1     * pia.n_total[species] == sum([pia.indexer[cell, species].n_local for cell in 1:n_cells])\n\nPositional arguments\n\npia: the ParticleIndexerArray instance for which to check consistency\nspecies: the species for which to check indexing\n\nReturns\n\nIf indexing is incorrect in a cell i, returns (false, i).\n\nIf the total number of particles as given by cell-wise particle indices is not equal to pia.n_total[species], returns (false, 0).\n\nIf indexing is correct, returns (true, 0).\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.pretty_print_pia","page":"Public API reference","title":"Merzbild.pretty_print_pia","text":"pretty_print_pia(pia)\n\nDisplay a ParticleIndexerArray instance by showing the starting/ending indices of the groups over all cells for a specific species.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\nspecies: the index of the species for which the indices are displayed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Loading-species-and-interaction-data","page":"Public API reference","title":"Loading species and interaction data","text":"","category":"section"},{"location":"reference_public/#Merzbild.Species","page":"Public API reference","title":"Merzbild.Species","text":"Species\n\nA structure to store information about a chemical species.\n\nFields\n\nname: the name of the species\nmass: the molecular mass of the species\ncharge: the charge of the species in terms of elementary charge (i.e. 1, -1, etc.)\ncharge_div_mass: the charge of the species divided by its mass, C/kg\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.Interaction","page":"Public API reference","title":"Merzbild.Interaction","text":"Interaction\n\nStructure to store interaction parameters for a 2-species interaction. The VHS model uses the following power law: sigma_VHS = C g^(1 - 2 omega_VHS), where omega is the exponent of the VHS potential, and C is the pre-computed factor: C = pi D_VHS^2 (2 T_refVHSm_r)^(omega_VHS - 05) frac1Gamma(25 - omega_VHS).\n\nFields\n\nm_r: collision-reduced mass\nμ1: relative mass of the first species\nμ2: relative mass of the second species\nvhs_d: diameter for the VHS potential\nvhs_o: exponent for the VHS potential\nvhs_Tref: reference temperature for the VHS potential\nvhs_muref: reference viscosity for the VHS potential\nvhs_factor: pre-computed factor for calculation of the VHS cross-section\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.load_species_data","page":"Public API reference","title":"Merzbild.load_species_data","text":"load_species_data(species_filename, species_names)\n\nLoad a vector of species data (mass, charge, etc.) from a TOML file.\n\nPositional arguments\n\nspecies_filename: the path to the TOML file containing the data\nspecies_names: a list of the names of the species for which to load the data\n\nReturns\n\nVector of Species filled with data loaded from the file. \n\n\n\n\n\nload_species_data(species_filename, species_name::String)\n\nLoad a vector of species data (mass, charge, etc.) from a TOML file for a single species.\n\nPositional arguments\n\nspecies_filename: the path to the TOML file containing the data\nspecies_name: the name of the species for which to load the data\n\nReturns\n\nVector of Species filled with data loaded from the file.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_interaction_data","page":"Public API reference","title":"Merzbild.load_interaction_data","text":"load_interaction_data(interactions_filename, species_data)\n\nLoad interaction data from a TOML file given a list of species' data (list of Species instances). It will load interaction data for all possible pair-wise interactions of the species in the list.\n\nThe resulting 2-D array has the interaction data for Species[i] with Species[k] in position [i,k]. It is not symmetric, as the relative collision masses μ1 and μ2 are swapped when comparing the Interaction instances in positions [i,k] and [k,i]. If no data is found, the function throws an error.\n\nPositional arguments\n\ninteractions_filename: the path to the TOML file containing the data\nspecies_data: list of Species instances for which to search for the interaction data\n\nReturns\n\n2-dimensional array of Interaction instances of size (n_species, n_species)\n\nThrows\n\nKeyError if interaction data not found in the file.\n\n\n\n\n\nload_interaction_data(interactions_filename, species_data)\n\nLoad interaction data from a TOML file given a list of species' data (list of Species instances), filling in dummy VHS data in case no entry is found in the TOML file. Useful for interactions where the VHS model doesn't make sense, for example electron-neutral interactions.\n\nIt will load interaction data for all possible pair-wise interactions of the species in the list. The resulting 2-D array has the interaction data for Species[i] with Species[k] in position [i,k]. It is not symmetric, as the relative collision masses μ1 and μ2 are swapped when comparing the Interaction instances in positions [i,k] and [k,i].\n\nPositional arguments\n\ninteractions_filename: the path to the TOML file containing the data\nspecies_data: list of Species instances for which to search for the interaction data\ndummy_vhs_d: value to use for the VHS diameter if no interaction data found in the file\ndummy_vhs_o: value to use for the VHS exponent if no interaction data found in the file\ndummy_vhs_Tref: value to use for the VHS reference temperature if no interaction data found in the file\n\nReturns\n\n2-dimensional array of Interaction instances of size (n_species, n_species)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_interaction_data_with_dummy","page":"Public API reference","title":"Merzbild.load_interaction_data_with_dummy","text":"load_interaction_data_with_dummy(interactions_filename, species_data)\n\nLoad interaction data from a TOML file given a list of species' data (list of Species instances), filling in dummy VHS data in case no entry is found in the TOML file. Useful for interactions where the VHS model doesn't make sense, for example electron-neutral interactions. Uses a value of 1e-10 for the dummy VHS diameter, 1.0 for the dummy VHS exponent, and 273.0 for the dummy VHS reference temperature.\n\nIt will load interaction data for all possible pair-wise interactions of the species in the list. The resulting 2-D array has the interaction data for Species[i] with Species[k] in position [i,k]. It is not symmetric, as the relative collision masses μ1 and μ2 are swapped when comparing the Interaction instances in positions [i,k] and [k,i].\n\nPositional arguments\n\ninteractions_filename: the path to the TOML file containing the data\nspecies_data: list of Species instances for which to search for the interaction data\n\nReturns\n\n2-dimensional array of Interaction instances of size (n_species, n_species)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_species_and_interaction_data","page":"Public API reference","title":"Merzbild.load_species_and_interaction_data","text":"load_species_and_interaction_data(species_filename, interactions_filename, species_names; fill_dummy=true)\n\nGiven a list of species' names, load the species and interaction data (filling with dummy data if needed).\n\nPositional arguments\n\nspecies_filename: the path to the TOML file containing the species' data\ninteractions_filename: the path to the TOML file containing the interaction data\nspecies_name: the name of the species for which to load the data\n\nKeyword arguments\n\nfill_dummy: if true, fill interaction data with computed dummy values if no entry found for a species pair in the interaction file\n\nReturns\n\nVector of Species instances\n2-dimensional array of Interaction instances of size (n_species, n_species)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.load_electron_neutral_interactions","page":"Public API reference","title":"Merzbild.load_electron_neutral_interactions","text":"load_electron_neutral_interactions(species_data, filename, databases, scattering_laws, energy_splits)\n\nLoad electron-neutral interaction data from an LXCAT format XML file for a set of given neutral species.\n\nPositional arguments\n\nspecies_data: vector of Species data for the neutral species\nfilename: path to XML file\ndatabases: dictionary of (species.name => database) pairs, specifying the name\n\nof the cross-section database in the XML file to use for the species \n\nscattering_laws: vector of ScatteringLaw instances to use for each species\nenergy_splits: vector of ElectronEnergySplit instances to use for each species\n\nReturns\n\nElectronNeutralInteractions structure containing the electron-neutral interaction data.\n\nThrows\n\nDataMissingException if data not found or not all required data present.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Sampling","page":"Public API reference","title":"Sampling","text":"","category":"section"},{"location":"reference_public/#Merzbild.maxwellian","page":"Public API reference","title":"Merzbild.maxwellian","text":"maxwellian(vx, vy, vz, m, T)\n\nEvaluate the Maxwell distribution with temperature T for a species with mass m     at a velocity (vx, vy, vz)\n\nPositional arguments\n\nvx: x velocity\nvy: y velocity\nvz: z velocity\nm: species' mass\nT: temperature\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.bkw","page":"Public API reference","title":"Merzbild.bkw","text":"bkw(vx, vy, vz, m, T, scaled_time)\n\nEvaluate the Bobylev-Krook-Wu (BKW) distribution with temperature T for a species with mass m     at a velocity (vx, vy, vz) and scaled time scaled_time\n\nPositional arguments\n\nvx: x velocity\nvy: y velocity\nvz: z velocity\nm: species' mass\nT: temperature\nscaled_time: the scaled_time\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_on_grid!","page":"Public API reference","title":"Merzbild.sample_on_grid!","text":"sample_on_grid!(rng, vdf_func, particles, nv, m, T, n_total,\n                xlo, xhi, ylo, yhi, zlo, zhi; v_mult=3.5, cutoff_mult=3.5, noise=0.0,\n                v_offset=[0.0, 0.0, 0.0])\n\nSample particles by evaluating a distribution on a discrete velocity grid, considering only points inside a sphere of a given radius (the value of the VDF at points outside of the sphere will be 0.0). The values of the VDF at the grid points will then be the computational weights of the particles, and the particles velocities are taken to be the velocities of the corresponding grid nodes (with additional uniformly distributed noise). Note: this can produce a large amount of particles for fine grids (as the number of grid nodes scales as nv^3.) The grid is assumed to have the same number of nodes nv in each direction, and the extent is computed as v_mult * v_thermal, where v_thermal is the thermal velocity sqrt(2kTm), and v_mult is a user-defined parameter. The positions of the particles are assumed to be randomly distributed in a cuboid.\n\nPositional arguments\n\nrng: The random number generator\nvdf_func: the distribution function to be evaluated which takes the x, y, and z velocities as parameters\nparticles: the Vector-like structure holding the particles\nnv: the number of grid nodes in each direction\nm: the molecular mass of the species\nT: the temperature used to compute the thermal velocity\nn_total: the total computational weight (number of physical particles) to be sampled\nxlo: the lower bound of the x coordinates of the particles\nxhi: the upper bound of the x coordinates of the particles\nylo: the lower bound of the y coordinates of the particles\nyhi: the upper bound of the y coordinates of the particles\nzlo: the lower bound of the z coordinates of the particles\nzhi: the upper bound of the z coordinates of the particles\n\nKeyword arguments\n\nv_mult: the value by which the thermal velocity is multiplied to compute the extent of the velocity grid\ncutoff_mult: the value by which the thermal velocity is multiplied to compute the radius for the sphere    used to cut-off the higher velocities\nnoise: controls the amount of noise added to the particle velocities (the noise is uniformly distributed   on the interval [-noise*dv, noise*dv], where dv is the grid spacing)\nv_offset: the streaming velocity vector to be added to the particle velocities\n\nReturns\n\nThe number of particles created\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_maxwellian_on_grid!","page":"Public API reference","title":"Merzbild.sample_maxwellian_on_grid!","text":"sample_maxwellian_on_grid!(rng, particles, nv, m, T, n_total,\n                           xlo, xhi, ylo, yhi, zlo, zhi; v_mult=3.5, cutoff_mult=3.5, noise=0.0,\n                           v_offset=[0.0, 0.0, 0.0])\n\nSample particles by evaluating a Maxwellian on a discrete velocity grid, considering only points inside a sphere of a given radius (the value of the VDF at points outside of the sphere will be 0.0). The values of the VDF at the grid points will then be the computational weights of the particles, and the particles velocities are taken to be the velocities of the corresponding grid nodes (with additional uniformly distributed noise). Note: this can produce a large amount of particles for fine grids (as the number of grid nodes scales as nv^3.) The grid is assumed to have the same number of nodes nv in each direction, and the extent is computed as v_mult * v_thermal, where v_thermal is the thermal velocity sqrt(2kTm), and v_mult is a user-defined parameter. The positions of the particles are assumed to be randomly distributed in a cuboid.\n\nPositional arguments\n\nrng: The random number generator\nparticles: the Vector-like structure holding the particles\nnv: the number of grid nodes in each direction\nm: the molecular mass of the species\nT: the temperature used to compute the thermal velocity\nn_total: the total computational weight (number of physical particles) to be sampled\nxlo: the lower bound of the x coordinates of the particles\nxhi: the upper bound of the x coordinates of the particles\nylo: the lower bound of the y coordinates of the particles\nyhi: the upper bound of the y coordinates of the particles\nzlo: the lower bound of the z coordinates of the particles\nzhi: the upper bound of the z coordinates of the particles\n\nKeyword arguments\n\nv_mult: the value by which the thermal velocity is multiplied to compute the extent of the velocity grid\ncutoff_mult: the value by which the thermal velocity is multiplied to compute the radius for the sphere    used to cut-off the higher velocities\nnoise: controls the amount of noise added to the particle velocities (the noise is uniformly distributed   on the interval [-noise*dv, noise*dv], where dv is the grid spacing)\nv_offset: the streaming velocity vector to be added to the particle velocities\n\nReturns\n\nThe function returns the number of particles created\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sample_particles_equal_weight!","page":"Public API reference","title":"Merzbild.sample_particles_equal_weight!","text":"sample_particles_equal_weight!(rng, particles, pia, cell, species,\n                                    nparticles, m, T, Fnum, xlo, xhi, ylo, yhi, zlo, zhi;\n                                    distribution=:Maxwellian, vx0=0.0, vy0=0.0, vz0=0.0)\n\nSample equal-weight particles of a specific species in a specific cell from a distribution. The positions of the particles are assumed to be randomly distributed in a cuboid. Note: this does not work if applied twice in a row to the same cell.\n\nPositional arguments\n\nrng: the random number generator\nparticles: the Vector-like structure holding the particles\npia: the ParticleIndexerArray\ncell: the cell index\nspecies: the species index\nnparticles: the number of particles to sample\nm: species' mass\nT: temperature\nFnum: the computational weight of the particles\nxlo: the lower bound of the x coordinates of the particles\nxhi: the upper bound of the x coordinates of the particles\nylo: the lower bound of the y coordinates of the particles\nyhi: the upper bound of the y coordinates of the particles\nzlo: the lower bound of the z coordinates of the particles\nzhi: the upper bound of the z coordinates of the particles\n\nKeyword arguments\n\ndistribution: the distribution to sample from (either :Maxwellian or :BKW)\nvx0: the x-velocity offset to add to the particle velocities\nvy0: the y-velocity offset to add to the particle velocities\nvz0: the z-velocity offset to add to the particle velocities\n\n\n\n\n\nsample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ppc::Integer, T, Fnum)\n\nSample particles from a Maxwellian distribution in each cell of a 1-D uniform grid given the number of particles per cell.\n\nPositional arguments\n\nrng: the random number generator\ngrid1duniform: the 1-D uniform grid\nparticles: the ParticleVector of particles\npia: the ParticleIndexerArray\nspecies: the index of the species to be sampled for\nspecies_data: Vector of Species data\nppc: number of particles per cell to be sampled\nT: the temperature\nFnum: the computational weight of the particles\n\n\n\n\n\nsample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ppc::Integer, T, Fnum, cell_chunk)\n\nSample particles from a Maxwellian distribution in a sequentially ordered subset of cells of a 1-D uniform grid given the number of particles per cell.\n\nPositional arguments\n\nrng: the random number generator\ngrid1duniform: the 1-D uniform grid\nparticles: the ParticleVector of particles\npia: the ParticleIndexerArray\nspecies: the index of the species to be sampled for\nspecies_data: Vector of Species data\nppc: number of particles per cell to be sampled\nT: the temperature\nFnum: the computational weight of the particles\ncell_chunk: the list of cell indices or range in which to sample particles, should be ordered in increasing order\n\n\n\n\n\nsample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ndens::Float64, T, Fnum)\n\nSample particles from a Maxwellian distribution in each cell in a sequentially ordered subset of cells of a 1-D uniform grid given the target number density. If the computed number of particles is not an integer value, the fractional remainder is used to probabilistically sample an extra particle, so that on average, the expected number density is achieved.\n\nPositional arguments\n\nrng: the random number generator\ngrid1duniform: the 1-D uniform grid\nparticles: the ParticleVector of particles\npia: the ParticleIndexerArray\nspecies: the index of the species to be sampled for\nspecies_data: Vector of Species data\nndens: target number density\nT: the temperature\nFnum: the computational weight of the particles\n\n\n\n\n\nsample_particles_equal_weight!(rng, grid1duniform, particles, pia, species, species_data, ndens::Float64, T, Fnum)\n\nSample particles from a Maxwellian distribution in each cell of 1-D uniform grid given the target number density. If the computed number of particles is not an integer value, the fractional remainder is used to probabilistically sample an extra particle, so that on average, the expected number density is achieved.\n\nPositional arguments\n\nrng: the random number generator\ngrid1duniform: the 1-D uniform grid\nparticles: the ParticleVector of particles\npia: the ParticleIndexerArray\nspecies: the index of the species to be sampled for\nspecies_data: Vector of Species data\nndens: target number density\nT: the temperature\nFnum: the computational weight of the particles\ncell_chunk: the list of cell indices or range in which to sample particles, should be ordered in increasing order\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Computing-grid-and-surface-macroscopic-properties","page":"Public API reference","title":"Computing grid and surface macroscopic properties","text":"","category":"section"},{"location":"reference_public/#Merzbild.PhysProps","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps\n\nStructure to store computed physical properties in a physical cell.\n\nFields\n\nndens_not_Np: whether the n field stores number density (if true) and not the number of physical particles in a cell (if false)\nn_cells: number of physical cells\nn_species: number of species\nn_moments: number of total moments computed\nlpa: length of the particle array (vector of length n_species)\nnp: number of particles (array of shape (n_cells, n_species))\nn: number density or number of physical particles in a cell (array of shape (n_cells, n_species))\nv: per-species flow velocity in a cell (array of shape (3, n_cells, n_species))\nT: per-species temperature in a cell (array of shape (n_cells, n_species))\nmoment_powers: powers of the total moments computed (vector of length n_moments)\nmoments: values of the total moments computed (array of shape (n_moments, n_cells, n_species))\nTref: reference temperature used to scale moments\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any, Any, Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(n_cells, n_species, moments_list; ndens_not_Np=false, Tref=300.0)\n\nConstruct physical properties given the number of cells and species, as well as the list of the orders of total moments to compute. The total moment of order M is defined as int sqrtv_x^2+v_y^2+v_z^2^M f(v_xv_yv_z)dv_x dv_y dv_z.\n\nPositional arguments\n\nn_cells: number of cells\nn_species: number of species\n\nKeyword arguments\n\nndens_not_Np: whether the n field stores number density (if true) and not the number of physical particles in a cell (if false)\nTref: reference temperature used to compute the total moments of a Maxwellian distribution which   are used to scale the total moments\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(pia, moments_list; ndens_not_Np=false, Tref=300.0)\n\nConstruct physical properties given a ParticleIndexerArray instance, as well as the list of the orders of total moments to compute. The total moment of order M is defined as int sqrtv_x^2+v_y^2+v_z^2^M f(v_xv_yv_z)dv_x dv_y dv_z.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\nn_species: number of species\n\nKeyword arguments\n\nndens_not_Np: whether the n field stores number density (if true) and not the number of physical particles in a cell (if false)\nTref: reference temperature used to compute the total moments of a Maxwellian distribution which   are used to scale the total moments\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.PhysProps-Tuple{Any}","page":"Public API reference","title":"Merzbild.PhysProps","text":"PhysProps(pia; ndens_not_Np=false)\n\nConstruct physical properties given a ParticleIndexerArray instance, with no computation of the total moments.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\n\nKeyword arguments\n\nndens_not_Np: whether the n field stores number density (if true) and not the number of physical particles in a cell (if false)\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.SurfProps","page":"Public API reference","title":"Merzbild.SurfProps","text":"SurfProps\n\nStructure to store computed surface properties.\n\nFields\n\nn_elements: number of physical cells\nn_species: number of species\nareas: the vector of surface element areas\ninv_areas: the vector of the inverse surface element areas\nnormals: the array of surface element normals with shape  (3, n_elements)\nnp: number of particles impacting the surface elements, array of shape (n_elements, n_species)\nflux_incident: incident mass flux per surface element, array of shape (n_elements, n_species)\nflux_reflected: reflected mass flux per surface element, array of shape (n_elements, n_species)\nforce: force acting per surface element, array of shape (3, n_elements, n_species)\nnormal_pressure: normal pressure per surface element, array of shape (n_elements, n_species)\nshear_pressure: shear pressure per surface element, array of shape (3, n_elements, n_species)\nkinetic_energy_flux: kinetic energy flux per surface element, array of shape (n_elements, n_species)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.SurfProps-NTuple{4, Any}","page":"Public API reference","title":"Merzbild.SurfProps","text":"SurfProps(n_elements, n_species, area, normals)\n\nPositional arguments\n\nn_elements\nn_species\nareas\nnormals\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.SurfProps-Tuple{Any, Grid1DUniform}","page":"Public API reference","title":"Merzbild.SurfProps","text":"SurfProps(pia, grid::Grid1DUniform)\n\nCreate a SurfProps struct for a 1-D grid, with element 1 corresponding to the left wall and element 2 corresponding to the right wall. The areas of the wall are assumed to be equal to 1, the normals are parallel to the x axis.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ngrid: the Grid1DUniform grid\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.compute_props!","page":"Public API reference","title":"Merzbild.compute_props!","text":"compute_props!(particles, pia, species_data, phys_props)\n\nCompute the physical properties of all species in all cells and store the result in a PhysProps instance. This function does not compute the total moments, even if phys_props.n_moments > 0.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.compute_props_with_total_moments!","page":"Public API reference","title":"Merzbild.compute_props_with_total_moments!","text":"compute_props_with_total_moments!(particles, pia, species_data, phys_props)\n\nCompute the physical properties of all species in all cells and store the result in a PhysProps instance. This function computes the total moments.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.compute_props_sorted!","page":"Public API reference","title":"Merzbild.compute_props_sorted!","text":"compute_props_sorted!(particles, pia, species_data, phys_props, cell_chunk)\n\nCompute the physical properties of all species in a subset of cells and store the result in a PhysProps instance, assuming the particles are sorted. This function does not compute the total moments, even if phys_props.n_moments > 0. Currently this does not compute the length of the particle array.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\ncell_chunk: the list of cell indices or range of cell indices in which to compute the properties\n\n\n\n\n\ncompute_props_sorted!(particles, pia, species_data, phys_props)\n\nCompute the physical properties of all species in all cells and store the result in a PhysProps instance, assuming the particles are sorted. This function does not compute the total moments, even if phys_props.n_moments > 0. Currently this does not compute the length of the particle array.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\n\n\n\n\n\ncompute_props_sorted!(particles, pia, species_data, phys_props, grid::G, cell_chunk) where {G<:AbstractGrid}\n\nCompute the physical properties of all species in a subset of cells and store the result in a PhysProps instance, assuming the particles are sorted. This function does not compute the total moments, even if phys_props.n_moments > 0. If ndens_not_Np is true, the number density will be computed based on the volumes of the grid cells; otherwise, the number of physical particles in each cell will be computed. Currently this does not compute the length of the particle array.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\ngrid: the physical grid\ncell_chunk: the list of cell indices or range of cell indices in which to compute the properties\n\n\n\n\n\ncompute_props_sorted!(particles, pia, species_data, phys_props, grid::AbstractGrid)\n\nCompute the physical properties of all species in all cells and store the result in a PhysProps instance, assuming the particles are sorted. This function does not compute the total moments, even if phys_props.n_moments > 0. If ndens_not_Np is true, the number density will be computed based on the volumes of the grid cells; otherwise, the number of physical particles in each cell will be computed. Currently this does not compute the length of the particle array.\n\nPositional arguments\n\nparticles: the Vector of ParticleVectors containing all the particles in a simulation\npia: the ParticleIndexerArray instance\nspecies_data: the Vector of SpeciesData\nphys_props: the PhysProps instance in which the computed physical properties are stored\ngrid: the physical grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.avg_props!","page":"Public API reference","title":"Merzbild.avg_props!","text":"avg_props!(phys_props_avg, phys_props::PhysProps, n_avg_timesteps)\n\nUsed to time-average computed physical properties, not including the total moments. For each instantaneous value of a property computed and stored in phys_props, it is divided by n_avg_timesteps and added to phys_props_avg.\n\nPositional arguments\n\nphys_props_avg: the PhysProps instance used to store the time-averaged properties\nphys_props: the PhysProps instance holding the current values of the properties   to be used for the averaging at the current timestep\nn_avg_timesteps: the number of timesteps over which the averaging is performed\n\nThrows\n\nErrorException if phys_props_avg computes number density and phys_props computes number of physical particles, or vice versa.\n\n\n\n\n\navg_props!(surf_props_avg, surf_props::SurfProps, n_avg_timesteps)\n\nUsed to time-average computed surface properties. For each instantaneous value of a property computed and stored in surf_props, it is divided by n_avg_timesteps and added to surf_props_avg.\n\nPositional arguments\n\nsurf_props_avg: the SurfProps instance used to store the time-averaged properties\nsurf_props: the SurfProps instance holding the current values of the properties   to be used for the averaging at the current timestep\nn_avg_timesteps: the number of timesteps over which the averaging is performed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.clear_props!","page":"Public API reference","title":"Merzbild.clear_props!","text":"clear_props!(phys_props::PhysProps)\n\nClear all data from PhysProps, for use when physical properties are averaged over timesteps and averaging over a new set of timesteps needs to be started.\n\nPositional arguments\n\nphys_props: the PhysProps instance to be cleared\n\n\n\n\n\nclear_props!(surf_props::SurfProps)\n\nClear all data from a SurfProps instance, either at the start of a new convection step, or when physical properties are averaged over timesteps and averaging over a new set of timesteps needs to be started.\n\nPositional arguments\n\nsurf_props: the SurfProps instance to be cleared\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Collision-computations","page":"Public API reference","title":"Collision computations","text":"","category":"section"},{"location":"reference_public/#Merzbild.CollisionData","page":"Public API reference","title":"Merzbild.CollisionData","text":"CollisionData\n\nStructure to store temporary collision data for a specific collision (relative velocity, collision energy, post-collision velocities, etc.)\n\nFields\n\nv_com: vector of center-of-mass velocity\ng: magnitude of relative velocity\nE_coll: relative translational energy of the colliding particles\nE_coll_eV: relative translational energy of the colliding particles in electron-volt\nE_coll_electron_eV: collisional energy of the an electron in electron-volt for electron-neutral collisions\ng_vec: vector of pre-collisional relative velocity\ng_vec_new: vector of post-collisional relative velocity\ng_new_1: magnitude of post-collisional relative velocity of the first particle in the collision pair\ng_new_2: magnitude of post-collisional relative velocity of the second particle in the collision pair\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionData-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionData","text":"CollisionData()\n\nCreate an empty CollisionData instance.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.CollisionFactors","page":"Public API reference","title":"Merzbild.CollisionFactors","text":"CollisionFactors\n\nStructure to store NTC-related collision factors for collisions between particles of two species in a given cell.\n\nFields\n\nn1: the number of particles of the first species in the cell\nn2: the number of particles of the second species in the cell\nsigma_g_w_max: estimate of the (sigma g w)_max (sigma is the total collision cross-section,   g is the relative collision velocity, w is the computational weight of the particles)\nn_coll: number of collisions to be tested\nn_coll_performed: number of collisions actually performed\nn_eq_w_coll_performed: number of collisions between particles with equal weights actually performed\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionFactors-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionFactors","text":"CollisionFactors()\n\nCreate an empty CollisionFactors instance (all values set to 0).\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.CollisionDataFP","page":"Public API reference","title":"Merzbild.CollisionDataFP","text":"CollisionData\n\nStructure to store temporary collision data for the particle Fokker-Planck approach.\n\nFields\n\nvel_ave: average velocity of the particles in the cell\nmean: mean value of the sampled velocities\nstddev: standard deviation of the sampled velocities\nxvel_rand: pre-allocated storage for sampled x-velocity components\nyvel_rand: pre-allocated storage for sampled y-velocity components\nzvel_rand: pre-allocated storage for sampled z-velocity components\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.CollisionDataFP-Tuple{}","page":"Public API reference","title":"Merzbild.CollisionDataFP","text":"CollisionDataFP()\n\nCreate an empty CollisionDataFP instance.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.CollisionDataFP-Tuple{Any}","page":"Public API reference","title":"Merzbild.CollisionDataFP","text":"CollisionDataFP(n_particles_in_cell)\n\nCreate an empty CollisionDataFP instance, pre-allocating the arrays for sampled normal variables for n_particles_in_cell.\n\nPositional arguments\n\nn_particles_in_cell: estimate of expected maximum number of particles in cell\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"create_collision_factors_array(n_species)\n\nCreate a 3-dimensional array of collision factors for all interaction pairs for a 0-D case (1 spatial cell), with shape (n_species,n_species,1).\n\nPositional arguments\n\nn_species: number of species in the flow\n\nReturns\n\n3-dimensional array of CollisionFactors instances with shape (n_species,n_species,1).\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"create_collision_factors_array(n_species, n_cells)\n\nCreate a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape (n_species,n_species,n_cells).\n\nPositional arguments\n\nn_species: number of species in the flow\nn_cells: number of cells in the simulation\n\nReturns\n\n3-dimensional array of CollisionFactors instances with shape (n_species,n_species,n_cells).\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{ParticleIndexerArray}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"create_collision_factors_array(pia)\n\nCreate a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape (n_species,n_species,n_cells).\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\n\nReturns\n\n3-dimensional array of CollisionFactors instances with shape (n_species,n_species,n_cells).\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Real, Real}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"create_collision_factors_array(pia, interactions, species_data, T::Real, Fnum::Real; mult_factor=1.0)\n\nCreate a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape (n_species,n_species,n_cells). This will fill the array with the estimates (sigma g w)_max for all species in all cells, assuming a constant particle computational weight Fnum, a VHS cross-section, and that all species have a single temperature that is constant across all cells.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ninteractions: the 2-dimensional array of Interaction instances (of shape (n_species, n_species)) of all the pair-wise interactions\nspecies_data: the vector of Species instances of the species in the flow \nT: the temperatures of the flow\nFnum: the constant computational weight of the particles\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\nReturns\n\n3-dimensional array of CollisionFactors instances with shape (n_species,n_species,n_cells) fille with estimated values of (sigma g w)_max.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_collision_factors_array-Tuple{Any, Any, Any, Any, Real}","page":"Public API reference","title":"Merzbild.create_collision_factors_array","text":"create_collision_factors_array(pia, interactions, species_data, T_list, Fnum::Real; mult_factor=1.0)\n\nCreate a 3-dimensional array of collision factors for all interaction pairs for all cells in the simulation, with shape (n_species,n_species,n_cells). This will fill the array with the estimates (sigma g w)_max for all species in all cells, assuming a constant particle computational weight Fnum, a VHS cross-section, and that the temperature of each species is constant across all cells.\n\nPositional arguments\n\npia: the ParticleIndexerArray instance\ninteractions: the 2-dimensional array of Interaction instances (of shape (n_species, n_species)) of all the pair-wise interactions\nspecies_data: the vector of Species instances of the species in the flow \nT_list: the list of temperatures of the species\nFnum: the constant computational weight of the particles\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\nReturns\n\n3-dimensional array of CollisionFactors instances with shape (n_species,n_species,n_cells) fille with estimated values of (sigma g w)_max.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.create_computed_crosssections","page":"Public API reference","title":"Merzbild.create_computed_crosssections","text":"create_computed_crosssections(electron_neutral_interactions)\n\nCreate a vector of ComputedCrossSection instances for the electron-neutral interactions.\n\nPositional arguments\n\nelectron_neutral_interactions: the ElectronNeutralInteractions instance for which the   cross-sections will be computed\n\nReturns\n\nVector of ComputedCrossSection of length electron_neutral_interactions.n_neutrals.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max","text":"estimate_sigma_g_w_max(interaction, species1, species2, T1, T2, Fnum; mult_factor=1.0)\n\nEstimate (sigma g w)_max for a two-species interaction, assuming a constant particle computational weight Fnum and a VHS cross-section. The relative velocity g is estimated as g = 05 (sqrt2T_1 k_B  m_1 + sqrt2T_2 k_B  m_2), where T_1 and m_1 are the temperature and mass of the first species (species1), and  T_2 and m_2 are the temperature and mass of the second species (species2). This relative velocity estimate is then plugged into the VHS cross-section model to compute sigma. The result is then multiplied by Fnum and an (optional) factor mult_factor.\n\nPositional arguments\n\ninteraction: the Interaction instance for the interacting species\nspecies1: the Species instance of the first interacting species\nspecies2: the Species instance of the second interacting species\nT1: the temperature of the first interacting species\nT2: the temperature of the second interacting species\nFnum: the constant computational weight of the particles\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\nReturns\n\nthe estimate of (sigma g w)_max\n\n\n\n\n\nestimate_sigma_g_w_max(interaction, species, T, Fnum; mult_factor=1.0)\n\nEstimate (sigma g w)_max for a single-species interaction, assuming a constant particle computational weight Fnum and a VHS cross-section. Uses the same methodology as the estimate for a two-species interaction.\n\nPositional arguments\n\ninteraction: the Interaction instance for the interacting species\nspecies: the Species instance of the interacting species\nT: the temperature of the interacting species\nFnum: the constant computational weight of the particles\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\nReturns\n\nthe estimate of (sigma g w)_max\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max!","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max!","text":"estimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0)\n\nEstimate (sigma g w)_max for all species in all cells, assuming a constant particle computational weight Fnum, a VHS cross-section, and that each species' temperature is constant across all cells. Uses the same methodology as the estimate for a two-species interaction.\n\nPositional arguments\n\ncollision_factors: 3-dimensional array of CollisionFactors of shape (n_species, n_species, n_cells)\ninteractions: the 2-dimensional array of Interaction instances (of shape (n_species, n_species)) of all the pair-wise interactions\nspecies_data: the vector of Species instances of the species in the flow \nT_list: the list of temperatures of the species\nFnum: the constant computational weight of the particles\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\n\n\n\n\nestimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0)\n\nEstimate (sigma g w)_max for all species in all cells, assuming a species-specific computational weights Fnum, a VHS cross-section, and that each species' temperature is constant across all cells. Uses the same methodology as the estimate for a two-species interaction.\n\nPositional arguments\n\ncollision_factors: 3-dimensional array of CollisionFactors of shape (n_species, n_species, n_cells)\ninteractions: the 2-dimensional array of Interaction instances (of shape (n_species, n_species)) of all the pair-wise interactions\nspecies_data: the vector of Species instances of the species in the flow \nT_list: the list of temperatures of the species\nFnum: a list of the computational weights of the species\n\nKeyword arguments\n\nmult_factor: a factor by which to multiply the result (default value is 1.0)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.estimate_sigma_g_w_max_ntc_n_e!","page":"Public API reference","title":"Merzbild.estimate_sigma_g_w_max_ntc_n_e!","text":"estimate_sigma_g_w_max_ntc_n_e!(rng, collision_factors, collision_data, interaction,\n                                n_e_interactions, n_e_cs, particles_n, particles_e,\n                                pia, cell, species_n, species_e, Δt, V; min_coll=5, n_loops=3)\n\nEstimate (sigma g w)_max for an electron-neutral interaction by stochastically choosing particle pairs multiple times and computing (sigma g w) for each pair. The number of collisions is computed using the standard variable-weight NTC formula, the value of min_coll is added to this number, and particles are randomly sampled. The whole procedure is repeated n_loops times, so that an increased value (sigma g w)_max can have an impact on the computed number of pairs to select during the next loop iteration.\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors for the species in question in the cell\ncollision_data: CollisionData instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nn_e_interactions: the ElectronNeutralInteractions instance\nn_e_cs: the ComputedCrossSections instance\nparticles_n: ParticleVector of the particles of neutral species\nparticles_e: ParticleVector of the particles of the electron species\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies_n: the index of the neutral species\nspecies_e: the index of the electron species\nΔt: timestep\nV: cell volume\n\nKeyword arguments:\n\nmin_coll: the minimum number of pairs to test\nn_loops: the number of loops to perform (in each loop the number of collisions is computed using the   estimated value of  (sigma g w)_max)\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.ntc!-NTuple{10, Any}","page":"Public API reference","title":"Merzbild.ntc!","text":"ntc!(rng, collision_factors, collision_data, interaction, particles, pia,\n     cell, species, Δt, V)\n\nPerform elastic collisions between particles of same species using the NTC algorithm and the VHS cross-section model.\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors for the species in question in the cell\ncollision_data: CollisionData instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nparticles: ParticleVector of the particles being collided\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies: the index of the species for which collisions are performed\nΔt: timestep\nV: cell volume\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ntc!-NTuple{12, Any}","page":"Public API reference","title":"Merzbild.ntc!","text":"ntc!(rng, collision_factors, collision_data, interaction,\n     particles_1, particles_2, pia,\n     cell, species1, species2, Δt, V)\n\nPerform elastic collisions between particles of different species using the NTC algorithm and the VHS cross-section model.\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors for the species in question in the cell\ncollision_data: CollisionData instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nparticles_1: ParticleVector of the particles of the first species being collided\nparticles_2: ParticleVector of the particles of the second species being collided\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies1: the index of the first species for which collisions are performed\nspecies1: the index of the second species for which collisions are performed\nΔt: timestep\nV: cell volume\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.ntc_n_e!","page":"Public API reference","title":"Merzbild.ntc_n_e!","text":"ntc_n_e!(rng, collision_factors, collision_data, interaction,\n         n_e_interactions, n_e_cs, particles_n, particles_e, particles_ion,\n         pia, cell, species_n, species_e, species_ion, Δt, V)\n\nPerform electron-neutral elastic scattering and electron-impact ionization collisions.\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors for the species in question in the cell\ncollision_data: CollisionData instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nn_e_interactions: the ElectronNeutralInteractions instance\nn_e_cs: the ComputedCrossSections instance\nparticles_n: ParticleVector of the particles of neutral species\nparticles_e: ParticleVector of the particles of the electron species\nparticles_ion: ParticleVector of the particles of the ion species\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies_n: the index of the neutral species\nspecies_e: the index of the electron species\nspecies_ion: the index of the ion species\nΔt: timestep\nV: cell volume\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.ntc_n_e_es!","page":"Public API reference","title":"Merzbild.ntc_n_e_es!","text":"ntc_n_e_es!(rng, collision_factors, collision_data, interaction,\n         n_e_interactions, n_e_cs, particles_n, particles_e, particles_ion,\n         pia, cell, species_n, species_e, species_ion, Δt, V)\n\nPerform electron-neutral elastic scattering and electron-impact ionization collisions using the event splitting approach of Oblapenko et al. (2022)\n\nPositional arguments\n\nrng: the random number generator\ncollision_factors: the CollisionFactors for the species in question in the cell\ncollision_data: CollisionData instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nn_e_interactions: the ElectronNeutralInteractions instance\nn_e_cs: the ComputedCrossSections instance\nparticles_n: ParticleVector of the particles of neutral species\nparticles_e: ParticleVector of the particles of the electron species\nparticles_ion: ParticleVector of the particles of the ion species\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies_n: the index of the neutral species\nspecies_e: the index of the electron species\nspecies_ion: the index of the ion species\nΔt: timestep\nV: cell volume\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Fokker-Planck-computations","page":"Public API reference","title":"Fokker-Planck computations","text":"","category":"section"},{"location":"reference_public/#Merzbild.fp_linear!","page":"Public API reference","title":"Merzbild.fp_linear!","text":"fp_linear!(rng, collision_data_fp, interaction, species_data, particles, pia, cell, species, Δt, V)\n\nModel single-species elastic collisions using a linear Fokker-Planck approximation.\n\nPositional arguments\n\nrng: the random number generator\ncollision_data_fp: CollisionDataFP instance used for storing collisional quantities\ninteraction: 2-dimensional array of Interaction instances for all possible species pairs\nspecies_data: the vector of SpeciesData\nparticles: ParticleVector of the particles being collided\npia: the ParticleIndexerArray\ncell: the index of the cell in which collisions are performed\nspecies: the index of the species for which collisions are performed\nΔt: timestep\nV: cell volume\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Electron-neutral-interactions","page":"Public API reference","title":"Electron-neutral interactions","text":"","category":"section"},{"location":"reference_public/#Merzbild.ElectronNeutralInteractions","page":"Public API reference","title":"Merzbild.ElectronNeutralInteractions","text":"ElectronNeutralInteractions\n\nStructure to hold data on electron-neutral interactions. The neutral_indexer field is used to obtain the index of the species inside the structure, given an index of the neutral species in the full list of species in the simulation. For example, if we have a following list of species in the simulation: [e-, He, Ar+, He+, Ar], n_neutrals=2, the ElectronNeutralInteractions instance stores data for interactions of electrons with [He, Ar], and neutral_indexer[2] = 1, neutral_indexer[5] = 2.\n\nFields\n\nn_neutrals: number of neutral species for which the data has been loaded\nneutral_indexer: array that maps indices of neutral species   in the full list of species to local indices in the ElectronNeutralInteractions structure\nelastic: an array of ElasticScattering instances (of length n_neutrals) holding the cross-section data on elastic scattering   for each neutral species\nionization: an array of Ionization instances (of length n_neutrals) holding the cross-section data on electron-impact ionization   for each neutral species\nexcitation_sink: an array of ExcitationSink instances (of length n_neutrals)   holding the cross-section data on electron-impact electronic excitation for each neutral species\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ComputedCrossSections","page":"Public API reference","title":"Merzbild.ComputedCrossSections","text":"ComputedCrossSections\n\nStructure to hold data on computed cross-sections of electron-neutral interactions for a specific neutral species.\n\nFields\n\nn_excitations: number of electron-impact excitation reactions\ncs_total: the computed total cross-section (sum of cross-sections of all processes)\ncs_elastic: the computed elastic scattering cross-section\ncs_ionization: the computed electron-impact ionization cross-section\ncs_excitation: the computed electron-impact electronic excitation cross-section\nprob_vec: a vector of probabilities of the processes (of length 2+n_excitations). prob_vec[1] is the probability of elastic scattering,   prob_vec[2] is the probability of electron-impact ionization, prob_vec[3:2+n_excitations] are the probabilities   of th \ncdf_prob_vec: a vector of cumulative probabilities of the processes (of length 3+n_excitations), used for sampling a specific process:   cfd_prob_vec[1] = 0.0, cfd_prob_vec[n] = cfd_prob_vec[n-1] + prob_vec[n-1], n>1\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ElectronEnergySplit","page":"Public API reference","title":"Merzbild.ElectronEnergySplit","text":"ElectronEnergySplit ElectronEnergySplitEqual=1 ElectronEnergySplitZeroE=2\n\nEnum for various splittings of electron energy in electron-impact ionization reactions. ElectronEnergySplitEqual corresponds to energy being shared equally amongst the electrons, ElectronEnergySplitZeroE corresponds to the one-takes-all sharing model.\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ScatteringLaw","page":"Public API reference","title":"Merzbild.ScatteringLaw","text":"ScatteringLaw ScatteringIsotropic=1 ScatteringOkhrimovskyy=2\n\nEnum for various scattering laws in electron-neutral interactions. ScatteringIsotropic corresponds to isotropic scattering, ScatteringOkhrimovskyy to the scattering model of A. Okhrimovskyy et al., 2002.\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merging","page":"Public API reference","title":"Merging","text":"","category":"section"},{"location":"reference_public/#Grid-merging","page":"Public API reference","title":"Grid merging","text":"","category":"section"},{"location":"reference_public/#Merzbild.GridN2Merge","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge\n\nStruct for merging using a grid in velocity space. Particles in each cell are merged down. Particles outside of the grid are merged based on the octant they are in. So for an N:2 merge one would expect at most 2*(Nx*Ny*Nz+8) post-merge particles, where Nx, Ny, Nz are the number of grid cells in each velocity direction. The grid bounds in each direction can be computed using the mean thermal velocity of the particles and the mean streaming velocity: [v0-extent_multiplier*sqrt(2*k_B*T/m),v0+extent_multiplier*sqrt(2*k_B*T/m)]. Here T is the temperature of the species in question, m is the molecular mass, v0 is the mean velocity and extent_multiplier is a user-defined parameter (3.5 is a reasonable choice) defining the extent of the grid.\n\nFields\n\nNx: number of grid cells in x velocity direction\nNy: number of grid cells in y velocity direction\nNz: number of grid cells in z velocity direction\nNyNz: product of Ny and Nz\nNtotal: total number of grid cells (equal to Nx*Ny*Nz+8, as we account for the external octants)\nextent_multiplier: the vector of factors by which to multiply the thermal velocity to determine the grid bounds   in each velocity direction\nextent_v_lower: the lower bounds of the velocity grid in each velocity direction\nextent_v_upper: the upper bounds of the velocity grid in each velocity direction\nextent_v_mid: (extent_v_lower + extent_v_upper)/2\nΔv: the grid cell size in each velocity direction\nΔv_inv: the inverse grid cell size in each velocity direction\ndirection_vec: used to store randomly sampled direction signs\ncells: vector of GridCell instances for each grid cell, as well as the external octants\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, Int64, Int64, T}} where T<:AbstractArray","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::T) where T <: AbstractArray\n\nCreate velocity grid-based merging.\n\nPositional arguments\n\nNx: number of cells in vx direction\nNy: number of cells in vy direction\nNz: number of cells in vz direction\nextent_multiplier: the vector of factors by which to multiply the thermal velocity to determine the grid bounds\n\nin each velocity direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Union{Tuple{T}, Tuple{Int64, T}} where T<:AbstractArray","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(N::Int, extent_multiplier::T) where T <: AbstractArray\n\nCreate velocity grid-based merging with equal number of cells in each direction.\n\nPositional arguments\n\nN: number of cells in each velocity direction\nextent_multiplier: the vector of factors by which to multiply the thermal velocity to determine the grid bounds\n\nin each velocity direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int, extent_multiplier::Float64)\n\nCreate velocity grid-based merging with equal multipliers in each direction.\n\nPositional arguments\n\nNx: number of cells in vx direction\nNy: number of cells in vy direction\nNz: number of cells in vz direction\nextent_multiplier: the factor by which to multiply the thermal velocity to determine the grid bounds\n\nin each velocity direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Int64, Int64, Float64, Float64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(Nx::Int, Ny::Int, Nz::Int,\n            extent_multiplier_x::Float64,\n            extent_multiplier_y::Float64,\n            extent_multiplier_z::Float64)\n\nCreate velocity grid-based merging\n\nNx: number of cells in vx direction\nNy: number of cells in vy direction\nNz: number of cells in vz direction\nextent_multiplier_x: the factor by which to multiply the thermal velocity to determine the grid bounds\n\nin the x-velocity direction\n\nextent_multiplier_y: the factor by which to multiply the thermal velocity to determine the grid bounds\n\nin the y-velocity direction\n\nextent_multiplier_z: the factor by which to multiply the thermal velocity to determine the grid bounds\n\nin the z-velocity direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridN2Merge-Tuple{Int64, Float64}","page":"Public API reference","title":"Merzbild.GridN2Merge","text":"GridN2Merge(N::Int, extent_multiplier::Float64)\n\nCreate velocity grid-based merging with equal number of cells in each direction and equal multipliers in each direction.\n\nPositional arguments\n\nN: number of cells in each velocity direction\nextent_multiplier: the factor by which to multiply the thermal velocity to determine the grid bounds\n\nin each velocity direction\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.merge_grid_based!","page":"Public API reference","title":"Merzbild.merge_grid_based!","text":"merge_grid_based!(rng, merging_grid, particles, pia, cell, species, species_data, phys_props)\n\nMerge particles using a velocity grid-based merging approach. A Cartesian grid in velocity space is used to group particles together (particles outside of the grid are group by velocity octant), and in each cell/octant, particles are merged down to 2 particles. The extent of the grid is based on the temperature for the species in question in the physical grid cell being considered, as stored in the phys_props parameter.\n\nPositional arguments:\n\nrng: the random number generator instance\nmerging_grid: the grid merging (GridN2Merge) instance defining the velocity space grid\nparticles: the ParticleVector instance of the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the cell index\nspecies: the species index\nspecies_data: the array of Species data\nphys_props: the PhysProps instance containing the computed temperature\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#NNLS-merging","page":"Public API reference","title":"NNLS merging","text":"","category":"section"},{"location":"reference_public/#Merzbild.NNLSMerge","page":"Public API reference","title":"Merzbild.NNLSMerge","text":"NNLSMerge\n\nStruct for keeping track of merging-related quantities for NNLS-based merging.\n\nFields\n\nv0: vector of the mean velocity of the particles\nvref: reference velocity magnitude for scaling\ninv_vref: inverse of reference velocity magnitude for scaling\nEx: standard deviation of x velocity of particles\nEy: standard deviation of y velocity of particles\nEz: standard deviation of z velocity of particles\nw_total: total computational of the particles\nminvx: minimum x velocity of the particles\nmaxvx: maximum x velocity of the particles\nminvy: minimum y velocity of the particles\nmaxvy: maximum y velocity of the particles\nminvz: minimum z velocity of the particles\nmaxvz: maximum z velocity of the particles\nn_moments: number of velocity moments to preserve\nrhs_vector: vector of computed moments\nresidual: residual of solution\nmim: vector of 3-tuples of multi-indices for the velocity moments to preserve\ntot_order: vector of total orders of the velocity moments to preserve\nwork: NNLSWorkspace instance\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.NNLSMerge-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.NNLSMerge","text":"NNLSMerge(multi_index_moments, init_np; rate_preserving=false)\n\nCreate NNLS-based merging. Mass, momentum, directional energy are always conserved: if not in the list multi_index_moments of moments to preserve, the corresponding moment multi-indices will be added automatically. These indices are (0,0,0) for mass, (1,0,0), (0,1,0), (0,0,1) for momentum, and (2,0,0), (0,2,0), (0,0,2) for directional energies.\n\nPositional arguments\n\nmulti_index_moments: vector of mixed moments to preserve of the form [(i1, j1, k1), (i2, j2, k2), ...]`\ninit_np: assumption on pre-merge number of particles to pre-allocate memory for\n\nKeyword arguments:\n\nrate_preserving: used for rate-preserving merging of electrons, preserves approximate elastic collision and ionization rates\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.compute_multi_index_moments","page":"Public API reference","title":"Merzbild.compute_multi_index_moments","text":"compute_multi_index_moments(n)\n\nCompute all mixed moment multi-indices of total order up to n, i.e. all 3-tuples (i,j,k)such thati+j+k <= n`.\n\nPositional arguments\n\nn: maximum total order\n\nReturns\n\nVector of 3-tuples of moment multi-indices.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.merge_nnls_based!","page":"Public API reference","title":"Merzbild.merge_nnls_based!","text":"merge_nnls_based!(rng, nnls_merging, particles, pia, cell, species, vref; n_rand_pairs=0, max_err=1e-11,\n                  centered_at_mean=true, v_multipliers=[0.5, 1.0], iteration_mult=2)\n\nPerform NNLS-based merging. The NNLS system is scaled to improve numerical stability, the scaling algorithm is set by the scaling parameter. Even if scaling is done using the computed variances, vref might be used in case those variances are small.\n\nTo improve stability, additional fictitious particles can be created by randomly choosing particle pairs and creating new particles with a velocity and position that is a mean of the velocity and position of the randomly chosen pair; these particles are added as additional columns to the matrix. An additional fictitious particle can be created at the local mean velocity via the centered_at_mean parameter. Additionally, particles can be created with velocities that are a multiple of the computed velocity variance of the system of pre-merge particles in each direction. For a given variance multiplier (an entry in the v_multipliers parameter, which is a vector of multipliers), 8 particles are added, one in each octant. Each of the particles velocity components is given either by the value of the multiplier times the velocity variance of that component (times +1 or -1 depending on the octant), or, if this value is outside of the bounding box, the closest bounding value of the velocity component in that direction is used instead and also multiplied by the variance multiplier.\n\nPositional arguments\n\nrng: the random number generator instance\nnnls_merging: the NNLSMerge instance\nparticles: the ParticleVector instance containing the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\n\nKeyword arguments\n\nvref: the reference velocity used to scale the velocities\nscaling: how to scale entries in the LHS and RHS of the NNLS system - either based on   the reference velocity vref (scaling=:vref)   or on the computed variances in each direction (scaling=:variance)\nn_rand_pairs: the number of additional random pairs to sample to create additional entries in the matrix   to potentially improve the stability of the algorithm\nmax_err: maximum allowed value of the residual of the NNLS system\ncentered_at_mean: whether to add a particle centered at the mean velocity of the system of particles\nv_multipliers: the multipliers for the velocity variances of the particles to add aditional particles to the system\niteration_mult: the number by which the number of columns of the NNLS system matrix is multiplied, this gives the maximum   number of iterations of the NNLS algorithm\n\nReturns\n\nIf the residual exceeds max_err or the number of non-zero elements in the solution vector is equal to the original number of particles, -1 is returned to signify a failure of the merging algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.merge_nnls_based_rate_preserving!","page":"Public API reference","title":"Merzbild.merge_nnls_based_rate_preserving!","text":"merge_nnls_based_rate_preserving!(rng, nnls_merging,\n                                       interaction, electron_neutral_interactions, computed_cs,\n                                       particles, pia, cell, species, neutral_species_index,\n                                       ref_cs_elatic, ref_cs_ion; scaling=:variance,\n                                       vref=1.0, n_rand_pairs=0, max_err=1e-11,\n                                       centered_at_mean=true, v_multipliers=[0.5, 1.0], iteration_mult=2)\n\nPerform NNLS-based merging of electrons that conserves approximate elastic scattering and electron-impact ionization rates. The NNLS system is scaled to improve numerical stability, the scaling algorithm is set by the scaling parameter. Even if scaling is done using the computed variances, vref might be used in case those variances are small.\n\nTo improve stability, additional fictitious particles can be created by randomly choosing particle pairs and creating new particles with a velocity and position that is a mean of the velocity and position of the randomly chosen pair; these particles are added as additional columns to the matrix. An additional fictitious particle can be created at the local mean velocity via the centered_at_mean parameter. Additionally, particles can be created with velocities that are a multiple of the computed velocity variance of the system of pre-merge particles in each direction. For a given variance multiplier (an entry in the v_multipliers parameter, which is a vector of multipliers), 8 particles are added, one in each octant. Each of the particles velocity components is given either by the value of the multiplier times the velocity variance of that component (times +1 or -1 depending on the octant), or, if this value is outside of the bounding box, the closest bounding value of the velocity component in that direction is used instead and also multiplied by the variance multiplier. The reference velocity is also used in conjunction with the reference cross-sections to scale the parts of the NNLS matrix and RHS corresponding to conservation of electron-neutral collision rates.\n\nPositional arguments\n\nrng: the random number generator instance\nnnls_merging: the NNLSMerge instance\ninteraction: the Interaction instance describing the electron-neutral interaction being considered\nelectron_neutral_interactions:  the ElectronNeutralInteractions instance storing the tabulated cross-section   data used to compute the rates\ncomputed_cs: the vector of ComputedCrossSection instances in which the computed values will be stored\nparticles: the ParticleVector instance containing the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\nneutral_species_index: the index of the neutral species which is the collision partner in the electron-neutral   collisions for which approximate rates are being preserved.\nref_cs_elatic: the reference elastic scattering cross-section used to scale the rates\nref_cs_ion: the reference electron-impact ionization cross-section used to scale the rates\n\nKeyword arguments\n\nvref: the reference velocity used to scale the velocities and the electron-neutral collision rates\nscaling: how to scale entries in the LHS and RHS of the NNLS system - either based on   the reference velocity vref (scaling=:vref)   or on the computed variances in each direction (scaling=:variance)\nn_rand_pairs: the number of additional random pairs to sample to create additional entries in the matrix   to potentially improve the stability of the algorithm\nmax_err: maximum allowed value of the residual of the NNLS system\ncentered_at_mean: whether to add a particle centered at the mean velocity of the system of particles\nv_multipliers: the multipliers for the velocity variances of the particles to add aditional particles to the system\niteration_mult: the number by which the number of columns of the NNLS system matrix is multiplied, this gives the maximum   number of iterations of the NNLS algorithm\n\nReturns\n\nIf the residual exceeds max_err or the number of non-zero elements in the solution vector is equal to the original number of particles, -1 is returned to signify a failure of the merging algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Octree-merging","page":"Public API reference","title":"Octree merging","text":"","category":"section"},{"location":"reference_public/#Merzbild.OctreeBinSplit","page":"Public API reference","title":"Merzbild.OctreeBinSplit","text":"OctreeBinSplit OctreeBinMidSplit=1 OctreeBinMeanSplit=2 OctreeBinMedianSplit=3\n\nEnum defining how the velocity along which the bin is split is chosen.\n\nPossible values:\n\nOctreeBinMidSplit: the bin is split along the middle velocity\nOctreeBinMeanSplit: the bin is split along the mean velocity of the particles in the bin\nOctreeBinMedianSplit: the bin is split along the median velocity of the particles in the bin\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeInitBin","page":"Public API reference","title":"Merzbild.OctreeInitBin","text":"OctreeInitBin OctreeInitBinMinMaxVel=1 OctreeInitBinMinMaxVelSym=2 OctreeInitBinC=3\n\nEnum defining how the bounds of the initial bin are computed.\n\nPossible values:\n\nOctreeInitBinMinMaxVel: the minimum and maximum velocities of the particles being merged are used to compute the bounds\nOctreeInitBinMinMaxVelSym: the minimum and maximum velocities of the particles being merged are used to compute the bounds,   but the bounds are then symmetrized in each velocity direction: [-max(abs(min_v), abs(max_v)), max(abs(min_v), abs(max_v))]\nOctreeInitBinC: the initial bounds are set to [-c, c]in each direction, wherec`` speed of light \n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeBinBounds","page":"Public API reference","title":"Merzbild.OctreeBinBounds","text":"OctreeBinBounds OctreeBinBoundsInherit=1 OctreeBinBoundsRecompute=2\n\nEnum defining how the bounds of a split sub-octant bin are computed.\n\nPossible values:\n\nOctreeBinBoundsInherit: the splitting velocity and the appropriate bounds of the parent bin are inherited\nOctreeBinBoundsRecompute: the bounds are recomputed based on the particles in the bin\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeN2Merge","page":"Public API reference","title":"Merzbild.OctreeN2Merge","text":"OctreeN2Merge\n\nStruct for N:2 Octree merging.\n\nFields\n\nmax_Nbins: maximum possible number of bins\nNbins: number of bins currently used\nbins: Vector of OctreeCell instances used to compute the properties required for bin refinement\nfull_bins: Vector of OctreeFullCell instances used to compute the post-merge particles in each bin\nn_particles: total number of particles being merged\nbin_start: denotes start of indices of particles in bin i in the particle_indexes_sorted array\nbin_end: denotes end of indices of particles in bin i in the particle_indexes_sorted array\nparticle_indexes_sorted: Vector of particle indices of the particles being merged\nparticle_octants: Vector of particle octants for each particle used during radix sort\nparticles_sort_output: Vector of integer indices used to store particle indices during radix sort\nparticle_in_bin_counter: MVector of size 8, stores the number of particles in each bin\nnonempty_counter: MVector of size 8, stores the number of particles in each non-empty bin   (the octants to which these bins correspond to are in nonempty_bins)\nnonempty_bins: MVector of size 8, a sequential list of non-empty octants\nndens_counter: MVector of size 8, used in bin splitting, stores number density in each (non-empty) bin\nbin_bounds_compute: enum of OctreeBinBounds type defining whether bin bounds are fully defined   by the parent bin and splitting velocity (vel_middle), or whether they are recomputed for each new sub-octant bin\nsplit: enum of OctreeBinSplit type defining how bins are split\nvel_middle: used to store the velocity along which a bin is split into octants\nv_min_parent: used in bin splitting to store the vector of the per-component lower bounds of the velocities in the cell\nv_max_parent: used in bin splitting to store the vector of the per-component upper bounds of the velocities in the cell\ndirection_vec: used to store randomly sampled direction signs\ninit_bin_bounds: enum of OctreeInitBin type defining how the bounds of the top-level bin are set\nmax_depth: maximum allowed depth of a bin\ntotal_post_merge_np: used to keep track of number of post-merge particles\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.OctreeN2Merge-Tuple{Merzbild.OctreeBinSplit}","page":"Public API reference","title":"Merzbild.OctreeN2Merge","text":"OctreeN2Merge(split::OctreeBinSplit; init_bin_bounds=OctreeInitBinMinMaxVel, bin_bounds_compute=OctreeBinBoundsInherit,\n          max_Nbins=4096, max_depth=10)\n\nCreate an Octree N:2 merging instance.\n\nPositional arguments:\n\nsplit: a enum of OctreeBinSplit type which tells how to split a bin into sub-bins\n\nKeyword arguments:\n\ninit_bin_bounds: a enum of OctreeInitBin type which defines how the bounds of the top-level bin are set\nbin_bounds_compute: a enum of OctreeBinBounds type which defines whether the bounds of sub-bins are recomputed   based on the minimum/maximum velocities of the particles in those sub-bins, or the bounds are inherited from the   bin that was split\nmax_Nbins: maximum number of bins allowed (this only counts leaf-level bins)\nmax_depth: maximum depth of a sub-bin starting from the top-level bin containing all particles (which has a depth of 0)\n\nReturns: OctreeN2Merge instance with everything set to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.merge_octree_N2_based!","page":"Public API reference","title":"Merzbild.merge_octree_N2_based!","text":"merge_octree_N2_based!(rng, octree, particles, pia, cell, species, target_np)\n\nPerform N:2 merging without checking whether particle positions end up outside of the simulation domain.\n\nPositional arguments\n\nrng: the random number generator instance\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance containing the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\ntarget_np: the target post-merge number of particles; the post-merge number of particles will not exceed this value   but may be not exactly equal to it\n\n\n\n\n\nmerge_octree_N2_based!(rng, octree, particles, pia, cell, species, target_np, grid)\n\nPerform N:2 merging, checking whether particle positions end up outside of the simulation domain, and pushing them back into the domain if needed.\n\nPositional arguments\n\nrng: the random number generator instance\noctree: the OctreeN2Merge instance\nparticles: the ParticleVector instance containing the particles to be merged\npia: the ParticleIndexerArray instance\ncell: the index of the grid cell in which particles are being merged\nspecies: the index of the species being merged\ntarget_np: the target post-merge number of particles; the post-merge number of particles will not exceed this value   but may be not exactly equal to it\ngrid: the Grid1DUniform grid\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Grids-and-particle-sorting","page":"Public API reference","title":"Grids and particle sorting","text":"","category":"section"},{"location":"reference_public/#Merzbild.AbstractGrid","page":"Public API reference","title":"Merzbild.AbstractGrid","text":"AbstractGrid\n\nAbstract grid type\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.Grid1DUniform","page":"Public API reference","title":"Merzbild.Grid1DUniform","text":"Grid1DUniform\n\n1-D Uniform grid for a domain 0L\n\nFields\n\nL: length of the domain\nnx: number of cells\nΔx: cell size\ninv_Δx: inverse of cell size\ncells: Vector of Cell1D elements\nmin_x: minimum allowed x coordinate for particles (slightly larger than 0)\nmax_x: maximum allowed x coordinate for particles (slightly smaller than L)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.Grid1DUniform-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.Grid1DUniform","text":"Grid1DUniform(L, nx; wall_offset=1e-12)\n\nCreate 1-D uniform grid for a domain 0 L with nx cells\n\nPositional arguments\n\nL: length of the domain\nnx: number of cells\n\nKeyword arguments\n\nwall_offset: specifies a small relative offset from the walls so that particles   never end up with a coordinate of exactly 0 or L, otherwise some   sorting routines may produce cell indices outside of the 1:nx range.   The offset is computed as Δx * wall_offset, where Δx is the cell size.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridSortInPlace","page":"Public API reference","title":"Merzbild.GridSortInPlace","text":"GridSortInPlace\n\nStruct for in-place sorting of particles.\n\nFields\n\ncell_counts: vector to store the number of particles in each cell + number of particles in all previous cells\nsorted_indices: vector to store sorted particle indices\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.GridSortInPlace-Tuple{Integer, Integer}","page":"Public API reference","title":"Merzbild.GridSortInPlace","text":"GridSortInPlace(n_cells::Integer, n_particles::Integer)\n\nCreate a GridSortInPlace instance given a number of grid cells and number of particles.\n\nPositional arguments\n\nn_cells: the number of grid cells\nn_particles: the (expected) number of particles in the simulation   (to pre-allocate the sorted_indices vector) - it is recommended   to set this to the maximum expected number of particles in the simulation to avoid resizing of arrays   during a simulation\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.GridSortInPlace-Union{Tuple{G}, Tuple{G, Integer}} where G<:AbstractGrid","page":"Public API reference","title":"Merzbild.GridSortInPlace","text":"GridSortInPlace(grid::G, n_particles::Integer) where {G<:AbstractGrid}\n\nCreate a GridSortInPlace instance given a grid and number of particles.\n\nPositional arguments\n\ngrid: the grid on which to sort the particles\nn_particles: the (expected) number of particles in the simulation   (to pre-allocate the sorted_indices vector) - it is recommended   to set this to the maximum expected number of particles in the simulation to avoid resizing of arrays   during a simulation\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.sort_particles!","page":"Public API reference","title":"Merzbild.sort_particles!","text":"sort_particles!(gridsort::GridSortInPlace, grid, particles, pia, species)\n\nSort particles on a grid using an in-place sorting algorithm. The pia instance is allowed to have non-contiguous indices (arising for example from merging).\n\nPositional arguments\n\ngridsort: the GridSortInPlace structure\ngrid: the grid (should have an n_cells field, and a get_cell function has to be defined for the grid type)\nparticles: the ParticleVector of particles to be sorted\npia: the ParticleIndexerArray instance\nspecies: the index of the species being sorted\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-movement","page":"Public API reference","title":"Particle movement","text":"","category":"section"},{"location":"reference_public/#Merzbild.convect_particles!","page":"Public API reference","title":"Merzbild.convect_particles!","text":"convect_particles!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, particles, pia, species, species_data, Δt)\n\nConvect particles on a 1-D uniform grid.\n\nPositional arguments\n\nrng: the random number generator\ngrid: the grid on which the convection is performed\nboundaries: the MaxwellWalls1D struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)\nparticles: the ParticleVector of particles to be convected\npia: the ParticleIndexerArray instance\nspecies: the index of the species being convected\nspecies_data: the vector of Species data\nΔt: the convection timestep\n\n\n\n\n\nconvect_particles!(rng, grid::Grid1DUniform, boundaries::MaxwellWalls1D, surf_props::SurfProps, particles, pia, species, species_data, Δt)\n\nConvect particles on a 1-D uniform grid, computing surface properties if particles hit a surface.\n\nPositional arguments\n\nrng: the random number generator\ngrid: the grid on which the convection is performed\nboundaries: the MaxwellWalls1D struct describing the boundaries (it is assumed that the wall with index 1 is the left wall and   the wall with index 2 is the right wall)\nparticles: the ParticleVector of particles to be convected\npia: the ParticleIndexerArray instance\nspecies: the index of the species being convected\nspecies_data: the vector of Species data\nsurf_props: the SurfProps struct where the computed surface properties will be stored\nΔt: the convection timestep\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-surface-interactions","page":"Public API reference","title":"Particle-surface interactions","text":"","category":"section"},{"location":"reference_public/#Merzbild.MaxwellWallBC","page":"Public API reference","title":"Merzbild.MaxwellWallBC","text":"MaxwellWallBC\n\nA struct to hold information about a diffuse reflecting wall.\n\nFields\n\nT: temperature\nv: wall velocity vector\naccommodation: accommodation coefficient (a value of 0 corresponds to specular reflection,   a value of 1 corresponds to purely diffuse reflection)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.MaxwellWalls1D","page":"Public API reference","title":"Merzbild.MaxwellWalls1D","text":"MaxwellWalls1D\n\nA struct to hold information about all diffuse reflecting walls in the simulation.\n\nFields\n\nboundaries: a vector of MaxwellWallBC walls\nreflection_velocities_sq: array of pre-computed squared thermal reflection velocities (nwalls x nspecies)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.MaxwellWalls1D-Tuple{Any, Vararg{Float64, 6}}","page":"Public API reference","title":"Merzbild.MaxwellWalls1D","text":"MaxwellWalls1D(species_data, T_l::Float64, T_r::Float64, vy_l::Float64, vy_r::Float64, accomodation_l::Float64, accomodation_r::Float64)\n\nCreate a MaxwellWalls1D struct for a 1-D simulation with 2 walls (\"left\" and \"right\") with a velocity in     the y-direction only.\n\nPositional arguments\n\nspecies_data: vector of Species data\nT_l: temperature of left wall\nT_r: temperature of right wall\nvy_l: y-velocity of left wall\nvy_r: y-velocity of right wall\naccomodation_l: accommodation coefficient of left wall\naccomodation_r: accommodation coefficient of right wall\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#I/O","page":"Public API reference","title":"I/O","text":"","category":"section"},{"location":"reference_public/#Merzbild.write_grid","page":"Public API reference","title":"Merzbild.write_grid","text":"write_grid(nc_filename, grid::Grid1DUniform; global_attributes=Dict{Any,Any}())\n\nWrite grid info to a NetCDF file\n\nPositional arguments\n\nnc_filename: path to the NetCDF file\ngrid: the grid to be written out to a file\n\nKeyword arguments\n\nglobal_attributes: dictionary of additional global attributes to be written to the netCDF file\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.IOSkipList","page":"Public API reference","title":"Merzbild.IOSkipList","text":"IOSkipList\n\nStruct that holds track of which variables are not to be written to NetCDF file for physical properties computed on a grid. If the field value is true, the corresponding physical grid property will not be output to the file.\n\nFields\n\nskip_length_particle_array: whether the length of the particle array should be skipped\nskip_moments: whether the output of the total moments should be skipped\nskip_number_of_particles: whether the output of the number of particles should be skipped\nskip_number_density: whether the output of the number density/number of physical particles should be skipped\nskip_velocity: whether the output of the velocity should be skipped\nskip_temperature: whether the output of the temperature should be skipped\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.IOSkipList-Tuple{Any}","page":"Public API reference","title":"Merzbild.IOSkipList","text":"IOSkipList(list_of_variables_to_skip)\n\nConstruct an IOSkipList from a list of variable names. The possible names are: length_particle_array, moments, np or nparticles, ndens, v, T.\n\nPositional arguments\n\nlist_of_variables_to_skip: list of variable names to skip\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.IOSkipList-Tuple{}","page":"Public API reference","title":"Merzbild.IOSkipList","text":"IOSkipList()\n\nConstruct an empty IOSkipList.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.IOSkipListSurf","page":"Public API reference","title":"Merzbild.IOSkipListSurf","text":"IOSkipListSurf\n\nStruct that holds track of which variables are not to be written to NetCDF file for computed surface properties. If the field value is true, the corresponding physical grid property will not be output to the file.\n\nFields\n\nskip_number_of_particles: whether the output of the number of particles should be skipped\nskip_fluxes: whether the output of the incident/reflected fluxes should be skipped\nskip_force: whether the output of the force should be skipped\nskip_normal_pressure: whether the output of the normal pressure should be skipped\nskip_shear_pressure: whether the output of the shear pressure should be skipped\nskip_kinetic_energy_flux: whether the output of the kinetic energy flux should be skipped\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.IOSkipListSurf-Tuple{Any}","page":"Public API reference","title":"Merzbild.IOSkipListSurf","text":"IOSkipListSurf(list_of_variables_to_skip)\n\nConstruct an IOSkipListSurf from a list of variable names. The possible names are: np or nparticles, fluxes, force, normal_pressure, shear_pressure, \"kineticenergyflux\".\n\nPositional arguments\n\nlist_of_variables_to_skip: list of variable names to skip\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.IOSkipListSurf-Tuple{}","page":"Public API reference","title":"Merzbild.IOSkipListSurf","text":"IOSkipListSurf()\n\nConstruct an empty IOSkipListSurf\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolder","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"NCDataHolder <: AbstractNCDataHolder\n\nStruct that holds NetCDF-output related data for physical properties (grid properties) I/O.\n\nFields\n\nfilehandle: handle to the open NetCDF file\nndens_not_Np: whether the number density or the number of physical particles is being output\ntimestep_dim: timestep dimension that used to keep track of the number of output steps\nv_spn: variable to hold species' names (dimension n_species)\nv_timestep: variable to hold the simulation timestep number (dimension time)\nv_lpa: variable to hold lengths of particle arrays (dimension n_species x time)\nv_mompows: variable to hold list of total moment powers (dimension n_moments)\nv_moments: variable to hold total moments (dimension n_moments x n_cells x n_species x time)\nv_np:  variable to hold number of particles (dimension n_cells x n_species x time)\nv_ndens: variable to hold number density or the number of physical particles (dimension n_cells x n_species x time)\nv_v: variable to hold velocity (dimension 3 x n_cells x n_species x time)\nv_T: variable to hold temperature (dimension n_cells x n_species x time)\nn_species_1: constant vector [n_species, 1] (used for offsets during I/O)\nn_cells_n_species_1: constant vector [n_cells, n_species, 1] (used for offsets during I/O)\nn_v_n_cells_n_species_1: constant vector [3, n_cells, n_species, 1] (used for offsets during I/O)\ncurrtimesteps: vector [n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1: vector [1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1_1: vector [1, 1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1_1_1: vector [1, 1, 1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ntimestep: vector storing the current simulation timestep\nskip_list: IOSkipList instance of variables to skip during output\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.NCDataHolder-NTuple{4, Any}","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"NCDataHolder(nc_filename, names_skip_list, species_data, phys_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolder instance with a list of variables to skip.\n\nPositional arguments\n\nnc_filename: filename to write output to\nnames_skip_list: list of variable names to skip, see IOSkipList for more details\nspecies_data: the vector of Species data for the species in the simulation\nphys_props: the PhysProps instance which will be used for the computation and output of physical properties\n\nKeyword arguments\n\nglobal_attributes: dictionary of any additional attributes to write to the netCDF file as a global attribute\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolder-Tuple{Any, Any, Any}","page":"Public API reference","title":"Merzbild.NCDataHolder","text":"NCDataHolder(nc_filename, species_data, phys_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolder instance with an empty list of variable to skip,\n\nPositional arguments\n\nnc_filename: filename to write output to\nspecies_data: the vector of Species data for the species in the simulation\nphys_props: the PhysProps instance which will be used for the computation and output of physical properties\n\nKeyword arguments\n\nglobal_attributes: dictionary of any additional attributes to write to the netCDF file as a global attribute\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolderSurf","page":"Public API reference","title":"Merzbild.NCDataHolderSurf","text":"NCDataHolderSurf\n\nStruct that holds NetCDF-output related data for surface properties I/O.\n\nFields\n\nfilehandle: handle to the open NetCDF file\ntimestep_dim: timestep dimension that used to keep track of the number of output steps\nv_spn: variable to hold species' names (dimension n_species)\nv_timestep: variable to hold the simulation timestep number (dimension time)\nv_np:  variable to hold number of particles that hit the surface (dimension n_elements x n_species x time)\nv_flux_incident: variable to hold incident mass flux (dimension n_elements x n_species x time)\nv_flux_reflected: variable to hold reflected mass flux (dimension n_elements x n_species x time)\nv_force: variable to hold force (dimension 3 x n_elements x n_species x time)\nv_normal_pressure: variable to hold normal pressure (dimension n_elements x n_species x time)\nv_shear_pressure: variable to hold shear pressure (dimension 3 x n_elements x n_species x time)\nv_kinetic_energy_flux: variable to hold kinetic energy flux (dimension n_elements x n_species x time)\nn_species_1: constant vector [n_species, 1] (used for offsets during I/O)\nn_elements_n_species_1: constant vector [n_elements, n_species, 1] (used for offsets during I/O)\nn_v_n_elements_n_species_1: constant vector [3, n_elements, n_species, 1] (used for offsets during I/O)\ncurrtimesteps: vector [n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1: vector [1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1_1: vector [1, 1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ncurrtimesteps_1_1_1: vector [1, 1, 1, n_t_output], where n_t_output is the current output timestep (i.e. how many times the   properties have already been output, not the simulation timestep) (used for offsets during I/O)\ntimestep: vector storing the current simulation timestep\nskip_list: IOSkipListSurf instance of variables to skip during output\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.NCDataHolderSurf-NTuple{4, Any}","page":"Public API reference","title":"Merzbild.NCDataHolderSurf","text":"NCDataHolderSurf(nc_filename, names_skip_list, species_data, surf_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolderSurf instance with a list of variables to skip.\n\nPositional arguments\n\nnc_filename: filename to write output to\nnames_skip_list: list of variable names to skip, see IOSkipListSurf for more details\nspecies_data: the vector of Species data for the species in the simulation\nsurf_props: the SurfProps instance which will be used for the computation and output of surface properties\n\nKeyword arguments\n\nglobal_attributes: dictionary of any additional attributes to write to the netCDF file as a global attribute\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.NCDataHolderSurf-Tuple{Any, Any, Any}","page":"Public API reference","title":"Merzbild.NCDataHolderSurf","text":"NCDataHolderSurf(nc_filename, species_data, surf_props; global_attributes=Dict{Any,Any}())\n\nConstruct a NCDataHolderSurf instance with an empty list of variable to skip.\n\nPositional arguments\n\nPositional arguments\n\nnc_filename: filename to write output to\nspecies_data: the vector of Species data for the species in the simulation\nsurf_props: the SurfProps instance which will be used for the computation and output of surface properties\n\nKeyword arguments\n\nglobal_attributes: dictionary of any additional attributes to write to the netCDF file as a global attribute\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.write_netcdf-Tuple{Any, PhysProps, Any}","page":"Public API reference","title":"Merzbild.write_netcdf","text":" write_netcdf(ds, phys_props::PhysProps, timestep; sync_freq=0)\n\nWrite computed PhysProps to NetCDF file and synchronize file to disk if necessary.\n\nPositional arguments\n\nds: the NCDataHolder for the file to which the output will be written\nphys_props: the PhysProps instance containing the computed properties\ntimestep: the simulation timestep\n\nKeyword arguments\n\nsync_freq: if larger than 0 and if the number of timesteps output is proportional to sync_freq,   the data will be synchronized to disk. If set to 1, will sync data to disk at every timestep at which   data is written to the file.\n\nThrows\n\nErrorException if the NCDataHolder expects number density and the phys_props holds the number of physical particles, or vice versa.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.write_netcdf-Tuple{Any, SurfProps, Any}","page":"Public API reference","title":"Merzbild.write_netcdf","text":"write_netcdf(ds, surf_props::SurfProps, timestep; sync_freq=0)\n\nWrite SurfProps to NetCDF file and synchronize file to disk if necessary.\n\nPositional arguments\n\nds: the NCDataHolderSurf for the file to which the output will be written\nsurf_props: the SurfProps instance containing the computed properties\ntimestep: the simulation timestep\n\nKeyword arguments\n\nsync_freq: if larger than 0 and if the number of timesteps output is proportional to sync_freq,   the data will be synchronized to disk. If set to 1, will sync data to disk at every timestep at which   data is written to the file.\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.close_netcdf","page":"Public API reference","title":"Merzbild.close_netcdf","text":"close_netcdf(ds::AbstractNCDataHolder)\n\nClose NetCDF file.\n\nPositional arguments\n\nds: an AbstractNCDataHolder instance to close.\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Parallel-computations","page":"Public API reference","title":"Parallel computations","text":"","category":"section"},{"location":"reference_public/#Merzbild.ChunkExchanger","page":"Public API reference","title":"Merzbild.ChunkExchanger","text":"ChunkExchanger\n\nStruct used to organize exchange of particles between independent ParticleVector instances for chunked multi-threaded simulations. It is assumed that the cell indices within each chunk are contiguous, i.e. chunk[i+1] = chunk[i]+1. The n_local field of ParticleIndexer is left unused.\n\nGroup 1 of ParticleIndexer[chunk_id,cell] holds the range of particles that belong to cell cell that came from a particle chunk chunk_id via swapping.\n\nGroup 2 of ParticleIndexer[chunk_id,cell] holds the range of particles that belong to cell cell that came from a particle chunk chunk_id via pushing, i.e. they have been added to the end of the particle array.\n\nFields\n\nn_chunks: number of chunks used in the simulation\nn_cells: number of grid cells in the simulation\nindexer: array of ParticleIndexer instances of shape (n_chunks, n_cells)\n\n\n\n\n\n","category":"type"},{"location":"reference_public/#Merzbild.ChunkExchanger-Tuple{Any, Any}","page":"Public API reference","title":"Merzbild.ChunkExchanger","text":"ChunkExchanger(chunks, n_cells)\n\nCreate a ChunkExchanger for length(chunks) chunks and n_cells cell.\n\nPositional arguments\n\nchunks: list of cell chunks\nn_cells: total number of cells in the simulation\n\n\n\n\n\n","category":"method"},{"location":"reference_public/#Merzbild.exchange_particles!","page":"Public API reference","title":"Merzbild.exchange_particles!","text":"exchange_particles!(chunk_exchanger, particles_chunks, pia_chunks, cell_chunks, species)\n\nRedistribute particles between chunks based on their spatial cell ownership.\n\nThis function ensures each particle resides in the chunk responsible for its current cell. It performs symmetric swaps when possible, and pushes remaining particles if needed. The indexing metadata (chunk_exchanger and pia_chunks) is updated accordingly, and particles pushed to another chunk (not swapped) are added to the buffer for future re-use. The particles before the start of the re-distribution need to be sorted, so that no particles are indexed by the start2:end2 part of a ParticleIndexer.  After the operation, the n_total[species] value of pia_chunks[chunk_id] will not include particles that were pushed to another chunk (the appropriate n_group1, start1, end1 values will be set to 0, 0, -1). However indexing should not be relied on until particles are re-sorted, see (sort_particles_after_exchange!)[@ref].\n\nPositional arguments\n\nchunk_exchanger: the ChunkExchanger instance to track post-swap and post-push indices\nparticles_chunks: Vector of Vector of ParticleVector (per chunk and per species, i.e.   particles_chunks[chunk_id][species] is the correct order of access)\npia_chunks: Vector of ParticleIndexerArray instances for each chunk\ncell_chunks: cell ownership list for each chunk, i.e. cell_chunks[chunk_id] is a list   of cells belonging to chunk chunk_id; the cells within cell_chunks[chunk_id] should   be ordered in increasing order and be continuous:   i.e. cell_chunks[chunk_id][i] == cell_chunks[chunk_id][i-1] + 1\nspecies: the particle species being redistributed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.sort_particles_after_exchange!","page":"Public API reference","title":"Merzbild.sort_particles_after_exchange!","text":"sort_particles_after_exchange!(chunk_exchanger, gridsort, particles, pia, cell_chunk, species)\n\nRestore indexing of a ParticleVector and the associated ParticleIndexerArray after particles have been swapped and pushed between chunks.\n\nPositional arguments\n\nchunk_exchanger: the ChunkExchanger instance used to track post-swap and post-push indices\ngridsort: The GridSortInPlace associated with the chunk\nparticles_chunks: the ParticleVector for which to restore the indexing\npia: the ParticleIndexerArray instances associated with the chunk\ncell_chunk: list or range of cells belonging to the chunk\nspecies: the particle species being for which the indexing is being restored\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.reset!","page":"Public API reference","title":"Merzbild.reset!","text":"reset!(chunk_exchanger, chunk_id)\n\nReset all indexing of chunk_exchanger.indexer[chunk_id,:].\n\nPositional arguments\n\nchunk_exchanger: the ChunkExchanger instance\nchunk_id: the chunk for which to reset indexing\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Merzbild.reduce_surf_props!","page":"Public API reference","title":"Merzbild.reduce_surf_props!","text":"reduce_surf_props!(surf_props_target, surf_props_chunks)\n\nSum up the values of the computed surface properties for all SurfProps instances in  a surf_props_chunks list and store the sums in surf_props_target.\n\nPositional arguments\n\nsurf_props_target: the SurfProps instance which will hold the reduced values\nsurf_props_chunks: the list SurfProps instances to use for the reduction operation\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Particle-in-Cell","page":"Public API reference","title":"Particle-in-Cell","text":"","category":"section"},{"location":"reference_public/#Merzbild.accelerate_constant_field_x!","page":"Public API reference","title":"Merzbild.accelerate_constant_field_x!","text":"accelerate_constant_field_x!(particles, pia, cell, species, species_data, E, Δt)\n\nAccelerate particles with a constant electric field in the X direction\n\nPositional arguments\n\nparticles: vector-like structure of particles to be accelerated\npia: ParticleIndexerArray instance\ncell: index of the cell in which particles are being accelerated\nspecies: index of the species of the particles being accelerated\nspecies_data: a Vector{Species} instance with the species' data\nE: value of the electric field in V/m\nΔt: timestep for which the acceleration is performed\n\n\n\n\n\n","category":"function"},{"location":"reference_public/#Constants","page":"Public API reference","title":"Constants","text":"","category":"section"},{"location":"reference_public/#Merzbild.k_B","page":"Public API reference","title":"Merzbild.k_B","text":"Boltzmann constant, J/K\n\n\n\n\n\n","category":"constant"},{"location":"reference_public/#Misc","page":"Public API reference","title":"Misc","text":"","category":"section"},{"location":"reference_public/#Merzbild.DataMissingException","page":"Public API reference","title":"Merzbild.DataMissingException","text":"DataMissingException\n\nException for the case of missing tabulated cross-section data\n\nFields\n\nmsg: error message\n\n\n\n\n\n","category":"type"},{"location":"overview_fixedweight/#Fixed-weight-DSMC-simulations","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now that we can load species data, sample and index particles and compute macroscopic properties, we now look at performing collisions. Currently, the No Time Counter (NTC) algorithm of Bird is implemented for fixed-weight DSMC simulations.","category":"page"},{"location":"overview_fixedweight/#Loading-interaction-data:-Interaction","page":"Fixed-weight DSMC simulations","title":"Loading interaction data: Interaction","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"First, we need to load interaction data for the species the collisions of which we want to model. This data includes things like the collision-reduced mass and VHS parameters. The VHS parameters are collision species pair-specific. These data are stored in an Interaction instance. These Interaction instances are stored in a n_species x n_species matrix, where the (i,j)-th element contains the interaction data for collisions of particles of species i with  particles of species j.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"We can use the load_interaction_data function to create such a matrix of Interaction instances. It which reads a TOML file with the relevant interaction information, and uses the (already loaded) species data to compute quantities such as the collision-reduced mass. One can also use load_interaction_data_with_dummy function, which will not throw an error in case data for a specific interaction is missing in the TOML file, but will just create an interaction using the passed dummy parameters. This is relevant for electron-neutral interactions, for example, since  VHS collision parameters don't really make sense for such interactions, but are required to fill in the fields.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"An additional utility function load_species_and_interaction_data is also available, which loads both the species' and interaction data for those species at the same time.","category":"page"},{"location":"overview_fixedweight/#Storing-intermediate-collision-data:-CollisionData","page":"Fixed-weight DSMC simulations","title":"Storing intermediate collision data: CollisionData","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"During collisions, multiple vector quantities (such as the center of mass velocity, pre- and post-collision relative velocity) are computed for multiple collision pairs. In order to avoid excessive allocations and keep track of these quantities, the CollisionData structure exists. It does not need to be initialized in any special way; an instance of CollisionData must be created and simply passed to the collision routine, which will use it as required.","category":"page"},{"location":"overview_fixedweight/#NTC-specific-data:-CollisionFactors","page":"Fixed-weight DSMC simulations","title":"NTC-specific data: CollisionFactors","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"The No-Time Counter (NTC) collision algorithm requires an estimate of (sigma g w)_max for each species pair for each cell in the flow. The CollisionFactors data structure stores the values of this factor, as well as  other NTC-related parameters (number of collisions performed, number of collision partners). One needs to initialize a 3-dimensional array of CollisionFactors of shape  n_species x n_species x n_cells in order to store the required factors for each species' pair for all cells in the flow; this is done by calling create_collision_factors_array(n_species, n_cells). Some initial estimate for the values of (sigma g w)_max; the simplest way to do so for a fixed-weight DSMC simulation is to call the estimate_sigma_g_w_max!(collision_factors, interactions, species_data, T_list, Fnum; mult_factor=1.0) function. Version of the create_collision_factors_array function that automatically estimate (sigma g w)_max are also available.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"This will pre-compute  (sigma g w)_max based on a list of temperatures for each species by computing the average thermal velocities and calculating the value of the VHS collision cross-section:","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"g_thermal1 = sqrt(2 * T1 * k_B / species1.mass)\ng_thermal2 = sqrt(2 * T2 * k_B / species2.mass)\ng_thermal = 0.5 * (g_thermal1 + g_thermal2)\nreturn mult_factor * sigma_vhs(interaction, g_thermal) * g_thermal * Fnum","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Here mult_factor (default value of 1.0) is used to optionally increase or decrease the computed estimate; and the value w is assumed to be constant and is designated by Fnum. This approach computes the same value of (sigma g w)_max for all the cells in the domain; however, unless an initial condition with large gradients is used, this should not be an issue.","category":"page"},{"location":"overview_fixedweight/#NTC-collisions","page":"Fixed-weight DSMC simulations","title":"NTC collisions","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now that the interaction data has been loaded, the CollisionData instance to store intermediate collision-related quantities has been instantiated, the 3-dimensional array of CollisionFactors has been created, and the (sigma g w)_max values precomputed, one can perform collisions.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Single-species elastic VHS collisions can be performed by calling ntc!(rng, collision_factors, collision_data, interaction, particles, pia, cell, species, Δt, V). Here collision_factors is the specific instance of CollisionFactors, i.e. a specific element of the 3-dimensional array of CollisionFactors. Δt is the timestep, and V is the volume of the physical cell (for spatially homogeneous simulations this can be set to 1.0).","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Multi-species elastic VHS collisions are performed in a similar fashion, by calling ntc!(rng, collision_factors, collision_data, interaction, particles_1, particles_2, pia, cell, species1, species2, Δt, V).","category":"page"},{"location":"overview_fixedweight/#Example:-bringing-it-all-together","page":"Fixed-weight DSMC simulations","title":"Example: bringing it all together","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"An example of computation of collisions for a two-species mixture is presented here.","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"using Merzbild\nusing Random\n\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\nspecies_data = load_species_data(\"data/particles.toml\", [\"Ar\", \"He\"])\nn_species = length(species_data)\n\n# number of timesteps to run simulation for\nn_t = 5000\n\n# we will have the number density of argon = 1e15, the number density of helium = 5e15\nn_particles_Ar = 2000\nn_particles_He = 10000\nFnum = 5e11\n\n# initial temperatures\nT0_Ar = 300.0\nT0_He = 2000.0\nT0_list = [T0_Ar, T0_He]\n\n# create the 2-element Vector of ParticleVectors for the 2 species\nparticles = [ParticleVector(n_particles_Ar), ParticleVector(n_particles_He)]\n\n# create the 2-species 1-cell particle indexer array filled with zeros\n# as we haven't sampled any particles yet\npia = ParticleIndexerArray([0, 0])\n\n# sample particles from a Maxwellian distribution\nsample_particles_equal_weight!(rng, particles[1], pia, 1, 2, n_particles_Ar,\n                               species_data[1].mass, T0_Ar, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\nsample_particles_equal_weight!(rng, particles[2], pia, 1, 2, n_particles_He,\n                               species_data[2].mass, T0_He, Fnum,\n                               0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\n\n\n# create the PhysProps instance to store computed properties\nphys_props = PhysProps(1, 2, [], Tref=T0_Ar)\n\n# create struct for I/O\nds = NCDataHolder(\"2species.nc\", species_data, phys_props)\n\n# compute and write physical properties at t=0\ncompute_props!(particles, pia, species_data, phys_props)\nwrite_netcdf(ds, phys_props, 0)\n\n# load interaction data\ninteraction_data = load_interaction_data(\"data/vhs.toml\", species_data)\n\n# create the 3-D array of collision factors\ncollision_factors::Array{CollisionFactors, 3} = create_collision_factors_array(n_species)\n\n# create the structure to store temporary collision data\ncollision_data = CollisionData()\n\n# estimate  (σ(g) * g * w)_max\nestimate_sigma_g_w_max!(collision_factors, interaction_data, species_data, T0_list, Fnum)\n\n# set our timestep\nΔt = 2.5e-3\n\n# set cell volume to 1.0 as we're doing a 0-D simulation\nV = 1.0\n\nfor ts in 1:n_t  # loop over time\n    for s2 in 1:n_species  # loop over first species\n        for s1 in s2:n_species  # loop over second species\n            if (s1 == s2)\n                # collisions between particles of same species\n                ntc!(rng, collision_factors[s1,s1,1], collision_data,\n                     interaction_data, particles[s1], pia, 1, s1, Δt, V)\n            else\n                # collisions between particles of different species\n                ntc!(rng, collision_factors[s1,s2,1], collision_data,\n                     interaction_data, particles[s1], particles[s2],\n                     pia, 1, s1, s2, Δt, V)\n            end\n        end\n    end\n\n    # we don't do convection, so we can take advantage of the fact that the particles stay sorted\n    # and compute the physical properties slightly faster without having to sort the particles\n    compute_props_sorted!(particles, pia, species_data, phys_props)\n\n    # write to output\n    write_netcdf(ds, phys_props, ts)\nend\n\n# close output file\nclose_netcdf(ds)","category":"page"},{"location":"overview_fixedweight/#Summary","page":"Fixed-weight DSMC simulations","title":"Summary","text":"","category":"section"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Now we have an overview of how to","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"Load interaction-related data\nEstimate the factor required for the NTC collision algorithm\nPerform elastic collisions between particles of alike and unalike species","category":"page"},{"location":"overview_fixedweight/","page":"Fixed-weight DSMC simulations","title":"Fixed-weight DSMC simulations","text":"In the next section, an overview of simulating collisions with variable-weight particles will be given.","category":"page"},{"location":"#Merzbild.jl","page":"Home","title":"Merzbild.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Merzbild.jl is a Direct Simulation Monte Carlo (DSMC) code written purely in Julia. It provides all the necessary building blocks for building a DSMC simulation, i.e. particle indexing, collisions, file I/O. Combining these blocks together is left up to the user; examples can be found in the simulations directory. It supports variable-weight DSMC simulations and ionized flow simulations, PIC and Stochastic Fokker-Planck capabilities are in development.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goals are to provide a modular, thoroughly tested, easy-to-read and easy-to-extend code for quick implementation and testing of new ideas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Serial and multithreaded simulations are possible.","category":"page"},{"location":"#Brief-overview-of-capabilities","page":"Home","title":"Brief overview of capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently the code supports spatially homogeneous (0D) and 1D uniform grid simulations. The table below lists support for the fixed- and variable-weight versions of the code.","category":"page"},{"location":"","page":"Home","title":"Home","text":" 0D 1D\nFixed-weight DSMC ✅ ✅\nVariable-weight DSMC ✅ ✅\nFixed-weight Fokker-Planck Linear Linear","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more detailed overview of the capabilities is given on the Overview of capabilities page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output format is NetCDF4.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For now, Merzbild.jl needs to be cloned to be run. Once cloned, navigate to the directory, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"and in the Julia interpreter run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.resolve(); Pkg.instantiate();","category":"page"},{"location":"","page":"Home","title":"Home","text":"to install the required packages. Running Pkg.test() afterwards will install the test environment dependencies and run the tests.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the way to use the code is to","category":"page"},{"location":"","page":"Home","title":"Home","text":"clone it\ncreate a new file in the simulations directory\nadd include(\"path/to/src/merzbild.jl\") and using ..Merzbild to the file.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation assumes a certain level of pre-existing knowledge of the DSMC approach. Basic building blocks and operations (particle indexing, sampling, collisions, I/O) are covered in the Getting Started section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More specific examples (ionizing collisions, specific merging algorithms) will be published later in a Tutorials section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, a full API reference is present, split into the Merzbild.jl public API reference and Merzbild.jl internal API reference.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can for now cite the repository as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{oblapenko2024merzbild,\n  title={{M}erzbild.jl: A {J}ulia {DSMC} code},\n  author={Oblapenko, Georgii},\n  year={2024},\n  month={12},\n  howpublished={\\url{https://github.com/merzbild/Merzbild.jl}},\n  doi={10.5281/zenodo.14503197}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depending on the functionality used, other citations may be warranted, please look at the Overview of capabilities page to see which algorithms and models have been implemented in Merzbild.","category":"page"},{"location":"overview_1d/#1D-DSMC-simulations","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"In this section, setting up fixed-weight DSMC simulations on a uniform 1D grid will be discussed, along with computation of surface properties due to particle-surface interactions. Some of the concepts and algorithms used here are also applicable to other grids (upcoming), but some things are specific to the uniform 1D grids.","category":"page"},{"location":"overview_1d/#Creating-a-grid","page":"1D DSMC simulations","title":"Creating a grid","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Creating a 1D uniform grid is very easy, as one needs to specify only the domain length L and the number of cells nx:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"grid = Grid1DUniform(L, nx)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"The Grid1DUniform structure stores additional properties such as cell volume, required for collisions.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We can also immediately create the ParticleIndexerArray instance (assuming we have a single-species flow):","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"pia = ParticleIndexerArray(grid.n_cells, 1)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"The grid information can be written to a NetCDF file by calling write_grid:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"write_grid(\"grid_info.nc\", grid)","category":"page"},{"location":"overview_1d/#Sampling-particles-in-each-cell","page":"1D DSMC simulations","title":"Sampling particles in each cell","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"To sample equal-weight particles in each cell, we need to compute the required Fnum. If we want to have ppc particles and a number density of ndens, then we can compute Fnum as (since the grid is uniform, we can use the volume of any cell for the computation)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Fnum = grid.cells[1].V * ndens / ppc","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We then initialize an Vector of ParticleVector's to store our particles for each species:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"particles = [ParticleVector(n_particles)]","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"and perform the sampling:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"sample_particles_equal_weight!(rng, grid, particles[1], pia, 1,\n                               species_data, ndens, T, Fnum)","category":"page"},{"location":"overview_1d/#Particle-sorting","page":"1D DSMC simulations","title":"Particle sorting","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"We will need to sort particles on the grid in case we will be convecting them; therefore a structure for particle sorting needs to be created as well. An in-place bin sorting algorithm is used, it requires an estimate of the number of particles in the simulation to pre-allocate arrays. For a fixed-weight simulation where ppc (particles per cell) are sampled in each cell at the start and no particles are created during the course of the simulation, we can compute the estimate as n_particles = ppc * nx. So we can initialize the GridSortInPlace instance like this:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"n_particles = ppc * nx\n\ngridsorter = GridSortInPlace(grid, n_particles)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"If we want to sort our particles (held in a ParticleVector instance), we can simply call","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"species_id = 1\n\n# we assume that particles has type Vector{ParticleVector} (a ParticleVector per species)\nsort_particles!(gridsorter, grid, particles[species_id], pia, species_id)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Since sorting indices only can lead to increase fragmentation of the particle layout in memory, a function count_disordered_particles is available that counts the number of  non-continuously laid out particles; this can serve as a metric as to whether the underlying particles (and not just their indices) need to be re-sorted (currently not implemented).","category":"page"},{"location":"overview_1d/#Creating-boundary-conditions","page":"1D DSMC simulations","title":"Creating boundary conditions","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Next, we need to create boundary conditions for the left and right walls. Currently, a diffusely reflecting wall is implemented with a user-defined accommodation coefficient (if it is equal to 0, the reflection is fully specular; if it is equal to 1, the reflection is fully diffuse).","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"This type of boundary condition (which stores the wall temperature, wall velocity, and accommodation coefficient) is described by the MaxwellWallBC structure, which should be defined for each wall.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"However, it is not intended to be defined or used directly; instead, for a 1-D simulation, a higher-level MaxwellWalls1D structure is used, which holds not only the two MaxwellWallBC instances (for the left and right walls), but also some species-wise precomputed quantities for the diffuse reflection. The MaxwellWalls1D struct assumes that the wall velocity in the x and z directions is 0, but a non-zero y velocity may be specified.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"A MaxwellWalls1D instance can be initialized like this (this will create two walls with equal temperatures and y velocities in opposite directions):","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"boundaries = MaxwellWalls1D(species_data, T_wall, T_wall, -v_wall, v_wall, 1.0, 1.0)","category":"page"},{"location":"overview_1d/#Calculation-of-surface-properties","page":"1D DSMC simulations","title":"Calculation of surface properties","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"To compute surface properties due to particle-surface interactions, one needs to first set up the corresponding struct that will hold the computed values. This is done by.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"surf_props = SurfProps(pia, grid)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"If one wants to compute the properties on a given timestep, the structure needs to be passed to the convection routine –- otherwise they will not be computed, as one needs to know the particle properties before and after its interaction with a surface.","category":"page"},{"location":"overview_1d/#I/O-of-surface-properties","page":"1D DSMC simulations","title":"I/O of surface properties","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"To set up NetCDF output of computed surface properties, one has code similar to the one used for the output of grid quantities:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"ds_surf = NCDataHolderSurf(\"scratch/data/couette_example_surf.nc\", species_data, surf_props)\n\nfor t in 1:n_timesteps\n# simulation loop here\n    write_netcdf_surf_props(ds_surf, surf_props, t)  # write computed surface properties to file\nend","category":"page"},{"location":"overview_1d/#Performing-convection","page":"1D DSMC simulations","title":"Performing convection","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Having set up the grid and boundary conditions, we can convect particles. This is done by calling the convect_particles! function. The convection should be followed by particle sorting before any computations of physical properties are done.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"convect_particles!(rng, grid, boundaries, particles[species_id], pia, species_id, species_data, Δt)","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"The function convect_particles as called above will not compute surface properties. To do that, a SurfProps instance needs to be passed:","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"convect_particles!(rng, grid, boundaries, particles[species_id], pia, species_id, species_data, surf_props, Δt)","category":"page"},{"location":"overview_1d/#Bringing-it-all-together","page":"1D DSMC simulations","title":"Bringing it all together","text":"","category":"section"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"Now we can combine all the pieces to set up a simulation of a single-species Couette flow in a channel with a width of 0.5 mm, discretized with 50 cells. The y-velocity of the left wall is assumed to be -500 m/s, and that of the right wall 500 m/s; the temperature of both walls is 300 K. The solution is initialized with 100 particles per cell and a number density of 5e22 1/m^3. A timestep of 2.59 ns is used. The simulation runs for 50K steps and the solution is time-averaged after the first 14K steps.","category":"page"},{"location":"overview_1d/","page":"1D DSMC simulations","title":"1D DSMC simulations","text":"using Merzbild\nusing Random\n\n# set our random seed for reproducibility\nseed = 1\nRandom.seed!(seed)\nrng = Xoshiro(seed)\n\n# set physical and discretization parameters\nT_wall = 300.0\nv_wall = 500.0\nL = 5e-4\nndens = 5e22\nnx = 50\nppc = 100\nΔt = 2.59e-9\nn_timesteps = 50000\navg_start = 14000\n\n# load particle and interaction data\nparticles_data_path = joinpath(\"data\", \"particles.toml\")\nspecies_data = load_species_data(particles_data_path, \"Ar\")\ninteraction_data_path = joinpath(\"data\", \"vhs.toml\")\ninteraction_data::Array{Interaction, 2} = load_interaction_data(interaction_data_path, species_data)\n\n# create our grid and BCs\ngrid = Grid1DUniform(L, nx)\nboundaries = MaxwellWalls1D(species_data, T_wall, T_wall, -v_wall, v_wall, 1.0, 1.0)\n\n# init particle vector, particle indexer, grid particle sorter\n# we will not be creating or destroying any particles, so we can compute the exact number\n# of particles we will have in the simulation\nn_particles = ppc * nx\nparticles = [ParticleVector(n_particles)]\npia = ParticleIndexerArray(grid.n_cells, 1)\ngridsorter = GridSortInPlace(grid, n_particles)\n\n# sample particles\n# Fnum * ppc = Np in cell = ndens * V_cell\nFnum = grid.cells[1].V * ndens / ppc\nsample_particles_equal_weight!(rng, grid, particles[1], pia, 1,\n                                species_data, ndens, T_wall, Fnum)\n\n# create collision structs\ncollision_data = CollisionData()\n\n# create struct for computation of physical properties\nphys_props = PhysProps(pia)\n\n# create second struct for averaging of physical properties\nphys_props_avg = PhysProps(pia)\n\n# create struct for computation of surface properties\nsurf_props = SurfProps(pia, grid)\n\n# create second struct for averaging of surface properties\nsurf_props_avg = SurfProps(pia, grid)\n\n# create struct for time-averaged output netCDF for grid properties\nds_avg = NCDataHolder(\"scratch/data/couette_example.nc\",\n                      species_data, phys_props)\n\n# create struct for time-averaged output netCDF for surface properties\nds_surf_avg = NCDataHolderSurf(\"scratch/data/couette_example_surf.nc\",\n                               species_data, surf_props)\n\n# init collision factors\ncollision_factors = create_collision_factors_array(pia, interaction_data, species_data, T_wall, Fnum)\n\n# write out grid data\nwrite_grid(\"scratch/data/couette_$(L)_$(nx)_grid.nc\", grid)\n\n# number of timesteps we are averaging for\nn_avg = n_timesteps - avg_start + 1\n\nfor t in 1:n_timesteps\n\n    # output timestep every 1000 timesteps\n    if t % 1000 == 0\n        println(t)\n    end\n\n    # collide particles\n    for cell in 1:grid.n_cells\n        ntc!(rng, collision_factors[1, 1, cell],\n                collision_data, interaction_data, particles[1], pia, cell, 1, Δt, grid.cells[cell].V)\n    end\n\n    # convect particles\n    convect_particles!(rng, grid, boundaries, particles[1], pia, 1, species_data, surf_props, Δt)\n\n    # sort particles\n    sort_particles!(gridsorter, grid, particles[1], pia, 1)\n\n    # compute props and do averaging\n    if (t >= avg_start)\n        compute_props_sorted!(particles, pia, species_data, phys_props)\n        avg_props!(phys_props_avg, phys_props, n_avg)\n        avg_props!(surf_props_avg, surf_props, n_avg)\n    end\nend\n\nwrite_netcdf(ds_avg, phys_props_avg, n_timesteps)\nwrite_netcdf(ds_surf_avg, surf_props_avg, n_timesteps)\n\nclose_netcdf(ds_avg)\nclose_netcdf(ds_surf_avg)","category":"page"}]
}
